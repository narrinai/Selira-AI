<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chat with AI Companions | Selira AI</title>
  <meta name="description" content="Engage in meaningful conversations with AI companions. Experience intelligent, empathetic, and personalized interactions.">
  
  <!-- Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-XZXX201WKD"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-XZXX201WKD');
  </script>
  
  <!-- Auth0 Authentication System -->
  <script src="/js/auth0-login.js"></script>
  
  <!-- Mobile Navigation System -->
  <script src="/js/mobile-nav.js"></script>
  
  <!-- Age Verification System -->
  <script src="/js/age-verification.js"></script>
  
  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
  
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500;600;700&family=Inter:wght@300;400;500;600;700&display=swap');
    
    :root {
      /* Selira dark theme - matching index.html */
      --bg-primary: #0a0a0a;
      --bg-secondary: #1a1a1a;
      --bg-tertiary: #2a2a2a;
      --text-primary: #ffffff;
      --text-secondary: #b3b3b3;
      --text-muted: #888888;
      --accent: #d4a574;
      --accent-hover: #c19456;
      --accent-secondary: #ec4899;
      --border: #333333;
      --success: #10b981;
      --error: #ef4444;
      --radius-sm: 8px;
      --radius-md: 12px;
      --radius-lg: 16px;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background-color: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.6;
      overflow: hidden;
    }

    /* App Layout */
    .app-container {
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    /* Left Sidebar with Character List */
    .sidebar {
      width: 220px;
      background: var(--bg-secondary);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .sidebar-header {
      padding: 16px;
      border-bottom: 1px solid var(--border);
    }

    .sidebar-logo {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      text-decoration: none;
      color: inherit;
      transition: opacity 0.2s ease;
    }

    .sidebar-logo:hover {
      opacity: 0.8;
      text-decoration: none;
      color: inherit;
    }

    .sidebar-logo-text {
      font-family: 'Playfair Display', serif;
      font-size: 18px;
      font-weight: 700;
      color: var(--accent);
    }

    .back-btn {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 12px;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      font-weight: 600;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .back-btn:hover {
      background: var(--bg-secondary);
      border-color: var(--accent);
      color: var(--accent);
      text-decoration: none;
    }

    .sidebar-section {
      flex: 1;
      overflow-y: auto;
    }

    .section-header {
      padding: 16px 16px 8px;
      font-size: 10px;
      font-weight: 700;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .chat-list {
      padding: 0 8px;
    }

    .chat-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      margin-bottom: 2px;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .chat-item:hover, .chat-item.active {
      background: var(--bg-tertiary);
    }

    .chat-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      overflow: hidden;
      flex-shrink: 0;
      background: var(--bg-tertiary);
      flex-shrink: 0;
    }

    .chat-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .chat-info {
      flex: 1;
      min-width: 0;
    }

    .chat-name {
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 4px;
      font-size: 14px;
    }

    .chat-preview {
      color: var(--text-secondary);
      font-size: 12px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 100%;
      white-space: nowrap;
    }

    /* Main Chat Area */
    .chat-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* Chat Header */
    .chat-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 20px;
      border-bottom: 1px solid var(--border);
      background: var(--bg-secondary);
    }

    .character-info-header {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .character-avatar-header {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      overflow: hidden;
      border: 2px solid var(--accent);
    }

    .character-avatar-header img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .character-name-header {
      font-family: 'Playfair Display', serif;
      font-size: 20px;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 4px;
    }

    .character-status {
      color: var(--text-secondary);
      font-size: 14px;
    }

    .chat-actions {
      display: flex;
      gap: 8px;
    }

    .action-btn {
      width: 40px;
      height: 40px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
    }

    .action-btn:hover {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    /* Action Menu Dropdown */
    .action-menu-container {
      position: relative;
    }

    .action-menu {
      position: absolute;
      top: 50px;
      right: 0;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      min-width: 200px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      overflow: hidden;
    }

    .action-menu-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      color: var(--text-primary);
      cursor: pointer;
      transition: background 0.2s ease;
      font-size: 14px;
    }

    .action-menu-item:hover {
      background: var(--bg-tertiary);
    }

    .menu-icon {
      font-size: 16px;
      width: 20px;
      text-align: center;
    }

    /* Right Sidebar Character Details */
    .character-sidebar {
      width: 320px;
      background: var(--bg-secondary);
      border-left: 1px solid var(--border);
      padding: 20px;
      overflow-y: auto;
    }

    .character-profile {
      text-align: center;
      margin-bottom: 30px;
    }

    .character-avatar-large {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      overflow: hidden;
      margin: 0 auto 16px;
      border: 3px solid var(--accent);
    }

    .character-avatar-large img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .character-name-large {
      font-family: 'Playfair Display', serif;
      font-size: 24px;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 8px;
    }

    .character-creator {
      color: var(--accent);
      font-size: 14px;
      margin-bottom: 16px;
    }

    .character-description {
      color: var(--text-secondary);
      font-size: 14px;
      line-height: 1.5;
      margin-bottom: 20px;
    }

    .character-stats {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
    }

    .stat-item {
      text-align: center;
    }

    .stat-number {
      font-size: 18px;
      font-weight: 700;
      color: var(--text-primary);
    }

    .stat-label {
      font-size: 12px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .character-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 20px;
    }

    .character-tag {
      background: rgba(212, 165, 116, 0.2);
      color: var(--accent);
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
    }

    /* Chat Messages */
    .chat-messages {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
      background: var(--bg-primary);
    }

    .welcome-message {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      text-align: center;
      color: var(--text-secondary);
    }

    .welcome-icon {
      font-size: 48px;
      margin-bottom: 16px;
    }

    .welcome-message h3 {
      font-family: 'Playfair Display', serif;
      font-size: 24px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 8px;
    }

    .message-group {
      margin-bottom: 20px;
    }

    .message {
      display: flex;
      gap: 12px;
      margin-bottom: 16px;
      max-width: 80%;
    }

    .message.user {
      flex-direction: row-reverse;
      margin-left: auto;
    }

    .message-avatar {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      overflow: hidden;
      flex-shrink: 0;
    }

    .message-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    /* Typing indicator animation */
    .typing-dots {
      display: flex;
      gap: 4px;
      align-items: center;
      padding: 8px 0;
    }

    .typing-dots span {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-secondary);
      animation: typing 1.4s infinite;
    }

    .typing-dots span:nth-child(2) {
      animation-delay: 0.2s;
    }

    .typing-dots span:nth-child(3) {
      animation-delay: 0.4s;
    }

    @keyframes typing {
      0%, 60%, 100% {
        opacity: 0.3;
        transform: scale(0.8);
      }
      30% {
        opacity: 1;
        transform: scale(1);
      }
    }

    .message-content {
      background: var(--bg-secondary);
      padding: 12px 16px;
      border-radius: 18px;
      color: var(--text-primary);
      line-height: 1.4;
    }

    .message.user .message-content {
      background: var(--accent);
      color: white;
    }

    /* Chat Input */
    .chat-input-container {
      padding: 20px;
      border-top: 1px solid var(--border);
      background: var(--bg-secondary);
    }

    .image-prompt-suggestions {
      margin-bottom: 16px;
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease-in-out;
    }

    .image-prompt-suggestions.visible {
      max-height: 200px;
    }

    .suggestions-header {
      font-size: 12px;
      color: var(--text-secondary);
      margin-bottom: 8px;
      font-weight: 600;
    }

    .suggestion-buttons {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .suggestion-button {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 13px;
      color: var(--text-primary);
      cursor: pointer;
      text-align: left;
      transition: all 0.2s ease;
      line-height: 1.3;
    }

    .suggestion-button:hover {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    .chat-input-wrapper {
      display: flex;
      gap: 12px;
      align-items: flex-end;
    }

    #messageInput {
      flex: 1;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 12px 16px;
      color: var(--text-primary);
      font-family: inherit;
      font-size: 14px;
      resize: none;
      max-height: 120px;
      overflow-y: auto;
    }

    #messageInput:focus {
      outline: none;
      border-color: var(--accent);
    }

    .send-btn {
      width: 40px;
      height: 40px;
      background: var(--accent);
      border: none;
      border-radius: 50%;
      color: white;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
    }

    .send-btn:hover {
      background: var(--accent-hover);
      transform: scale(1.05);
    }

    .send-btn:disabled {
      background: var(--border);
      cursor: not-allowed;
      transform: none;
    }

    .input-footer {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      margin-top: 8px;
      font-size: 12px;
      color: var(--text-muted);
      gap: 12px;
    }

    .request-image-btn {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-secondary);
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .request-image-btn:hover {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    /* Character Search Modal */
    .search-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .search-modal.open {
      display: flex;
    }

    .modal-content {
      background: var(--bg-secondary);
      border-radius: var(--radius-lg);
      width: 90vw;
      max-width: 800px;
      max-height: 80vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 20px;
      border-bottom: 1px solid var(--border);
    }

    .modal-header h3 {
      font-family: 'Playfair Display', serif;
      font-size: 20px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .close-btn {
      width: 32px;
      height: 32px;
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 24px;
      cursor: pointer;
      border-radius: var(--radius-sm);
      transition: all 0.2s ease;
    }

    .close-btn:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .search-input-wrapper {
      padding: 20px;
      border-bottom: 1px solid var(--border);
    }

    #characterSearch {
      width: 100%;
      padding: 12px 16px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      color: var(--text-primary);
      font-size: 14px;
    }

    #characterSearch:focus {
      outline: none;
      border-color: var(--accent);
    }

    .character-grid {
      padding: 20px;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 16px;
      max-height: 400px;
      overflow-y: auto;
    }

    .character-option {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 16px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: center;
    }

    .character-option:hover {
      background: var(--bg-secondary);
      border-color: var(--accent);
      transform: translateY(-2px);
    }

    .character-option-avatar {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      overflow: hidden;
      border: 2px solid var(--accent);
    }

    .character-option-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .character-option-name {
      font-weight: 600;
      color: var(--text-primary);
      font-size: 14px;
    }

    .character-option-role {
      color: var(--text-secondary);
      font-size: 12px;
    }

    /* Mobile Responsive */
    @media (max-width: 768px) {
      body {
        overflow: hidden;
      }

      .app-container {
        height: 100vh;
        height: 100dvh; /* Use dynamic viewport height */
      }

      .sidebar {
        position: fixed;
        left: -220px;
        z-index: 100;
        transition: left 0.3s ease;
        height: 100vh;
        height: 100dvh;
      }

      .sidebar.open {
        left: 0;
      }

      .chat-main {
        margin-left: 0;
        height: 100vh;
        height: 100dvh;
        display: flex;
        flex-direction: column;
      }

      .character-sidebar {
        display: none;
      }

      .chat-header {
        padding: 12px 16px 12px 60px;
        flex-shrink: 0;
      }

      .character-info-header {
        gap: 12px;
      }

      .character-avatar-header {
        width: 40px;
        height: 40px;
      }

      .character-name-header {
        font-size: 18px;
      }

      .character-status {
        font-size: 12px;
      }

      .chat-actions {
        gap: 4px;
      }

      .action-btn {
        width: 36px;
        height: 36px;
        font-size: 16px;
      }

      .chat-messages {
        flex: 1;
        padding: 16px;
        overflow-y: auto;
        /* Ensure messages area takes available space */
        min-height: 0;
      }

      .chat-input-container {
        padding: 12px 16px;
        /* Ensure input stays at bottom */
        flex-shrink: 0;
        /* Add safe area padding for iOS */
        padding-bottom: calc(12px + env(safe-area-inset-bottom));
      }

      .chat-input-wrapper {
        gap: 8px;
      }

      #messageInput {
        font-size: 16px; /* Prevent zoom on iOS */
        padding: 10px 14px;
        border-radius: 16px;
      }

      .send-btn {
        width: 36px;
        height: 36px;
        font-size: 16px;
        flex-shrink: 0;
      }

      .input-footer {
        margin-top: 6px;
        font-size: 11px;
        flex-wrap: wrap;
        gap: 8px;
      }

      .request-image-btn {
        padding: 4px 8px;
        font-size: 10px;
      }

      .mobile-menu-btn {
        position: fixed;
        left: 16px;
        top: 16px;
        z-index: 1001;
        background: rgba(26, 26, 26, 0.95);
        border: 1px solid var(--border);
        border-radius: 8px;
        color: var(--text-primary);
        font-size: 18px;
        padding: 8px;
        cursor: pointer;
        backdrop-filter: blur(10px);
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .message {
        max-width: 90%;
        margin-bottom: 12px;
      }

      .message-content {
        padding: 10px 12px;
        border-radius: 16px;
        font-size: 14px;
        line-height: 1.4;
      }

      .message-avatar {
        width: 32px;
        height: 32px;
      }

      /* Fix for keyboard pushing content up */
      .chat-input-container {
        position: sticky;
        bottom: 0;
        background: var(--bg-secondary);
        border-top: 1px solid var(--border);
        /* Ensure the input stays visible above virtual keyboard */
        z-index: 10;
      }
      
      /* Additional mobile keyboard fixes for all browsers */
      @media (max-width: 768px) {
        /* Prevent viewport zoom when focusing inputs */
        input, textarea, select {
          font-size: 16px !important;
          -webkit-text-size-adjust: 100%;
          -webkit-appearance: none;
        }
        
        /* Alternative fixed positioning for input container */
        body.keyboard-open .chat-input-container {
          position: fixed;
          bottom: 0;
          left: 0;
          right: 0;
          z-index: 1000;
          background: var(--bg-secondary);
          border-top: 1px solid var(--border);
          padding-bottom: env(safe-area-inset-bottom, 0px);
        }
        
        /* Adjust messages area when keyboard is open */
        body.keyboard-open .chat-messages {
          padding-bottom: 100px;
        }
      }

      /* Additional mobile fixes */
      .app-container {
        /* Prevent content from jumping when virtual keyboard appears */
        position: relative;
      }

      /* Make sure messages scroll properly on mobile */
      .chat-messages::-webkit-scrollbar {
        display: none;
      }

      .chat-messages {
        -ms-overflow-style: none;
        scrollbar-width: none;
        /* Smooth scrolling */
        scroll-behavior: smooth;
      }

      /* iOS specific fixes */
      @supports (-webkit-appearance: none) {
        .chat-main {
          /* Fix for iOS Safari viewport height issues */
          height: -webkit-fill-available;
        }

        #messageInput {
          /* Prevent iOS Safari from zooming when focusing input */
          transform: scale(1);
          transition: transform 0.1s ease;
          /* Additional zoom prevention */
          -webkit-text-size-adjust: 100%;
        }

        #messageInput:focus {
          transform: scale(1);
          /* Ensure no zoom on focus */
          -webkit-text-size-adjust: 100%;
        }
        
        /* Fix for keyboard covering send button */
        .chat-input-container {
          /* Keep input container in view when keyboard appears */
          position: fixed;
          bottom: 0;
          left: 0;
          right: 0;
          background: var(--bg-secondary);
          border-top: 1px solid var(--border);
          padding-bottom: calc(12px + env(safe-area-inset-bottom, 0px));
          z-index: 1000;
        }
        
        /* Adjust chat messages to account for fixed input */
        .chat-messages {
          /* Add bottom padding to prevent content being hidden behind fixed input */
          padding-bottom: 120px;
        }
      }

      /* Sidebar overlay */
      .sidebar-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 99;
        display: none;
      }

      .sidebar-overlay.show {
        display: block;
      }
    }

    /* Hide character sidebar on medium screens */
    @media (max-width: 1200px) {
      .character-sidebar {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div class="app-container">
    <!-- Left Sidebar with Character List -->
    <aside class="sidebar" id="sidebar">
      <!-- Sidebar Header -->
      <div class="sidebar-header">
        <a href="/category" class="sidebar-logo">
          <div class="sidebar-logo-text">Selira</div>
        </a>
        <a href="/category" class="back-btn" title="Back to Characters">
          <span class="btn-icon">‚Üê</span>
          <span>Back</span>
        </a>
      </div>

      <!-- Recent Chats -->
      <div class="sidebar-section">
        <div class="section-header">
          <span>Today</span>
        </div>
        <div class="chat-list" id="chatList">
          <!-- Chat items will be populated dynamically from Airtable -->
          <div class="loading-chats" style="text-align: center; padding: 20px; color: var(--text-secondary); font-size: 14px;">
            <div style="margin-bottom: 8px;">üîÑ</div>
            Loading characters...
          </div>
        </div>
      </div>
    </aside>

    <!-- Main Chat Area -->
    <main class="chat-main">
      <!-- Mobile Menu Button -->
      <button class="mobile-menu-btn" onclick="toggleSidebar()" style="display: none;">‚ò∞</button>

      <!-- Chat Header -->
      <header class="chat-header" id="chatHeader">
        <div class="character-info-header">
          <div class="character-avatar-header" id="currentCharacterAvatar">
            <img src="/avatars/placeholder.webp" alt="Character" id="characterImage" onerror="this.style.display='none';">
          </div>
          <div class="character-details">
            <h2 class="character-name-header" id="currentCharacterName">Loading...</h2>
            <p class="character-status" id="currentCharacterStatus">@Selira</p>
          </div>
        </div>
        <div class="chat-actions">
          <div class="action-menu-container">
            <button class="action-btn" onclick="toggleActionMenu()" title="More options" id="actionMenuBtn">
              <span>‚ãÆ</span>
            </button>
            <div class="action-menu" id="actionMenu" style="display: none;">
              <div class="action-menu-item" onclick="toggleCharacterInfo(); closeActionMenu();">
                <span>Companion Information</span>
              </div>
            </div>
          </div>
          <button class="action-btn" onclick="clearChat()" title="Clear Chat">
            <span>üóëÔ∏è</span>
          </button>
        </div>
      </header>

      <!-- Chat Messages Area -->
      <div class="chat-messages" id="chatMessages">
        <div class="welcome-message" style="text-align: center; padding: 40px 20px; color: var(--text-secondary);">
          <div style="font-size: 48px; margin-bottom: 16px;">üí≠</div>
          <h3 style="color: var(--text-primary); margin-bottom: 8px;">Chat Cleared</h3>
          <p>Start a new conversation!</p>
        </div>
      </div>

      <!-- Chat Input -->
      <div class="chat-input-container" id="chatInputContainer">
        <!-- Image Prompt Suggestions -->
        <div class="image-prompt-suggestions" id="imagePromptSuggestions">
          <div class="suggestions-header">üí° Image suggestions from your companion:</div>
          <div class="suggestion-buttons" id="suggestionButtons">
            <!-- Suggestions will be populated by JavaScript -->
          </div>
        </div>

        <div class="chat-input-wrapper">
          <textarea 
            id="messageInput" 
            placeholder="Enter a message. Ex) Hello?" 
            rows="1"
            maxlength="2000"
          ></textarea>
          <button class="send-btn" id="sendBtn" onclick="sendMessage()">
            <span>‚û§</span>
          </button>
        </div>
        <div class="input-footer">
          <button class="request-image-btn" onclick="requestImage()" title="Get Image Suggestions">
            üí° Image Ideas
          </button>
          <span class="input-hint">Everything AI says is made up! Please follow your local laws and don't talk about underage content.</span>
        </div>
      </div>
    </main>

    <!-- Right Sidebar Character Details -->
    <aside class="character-sidebar" id="characterSidebar">
      <div class="character-profile">
        <div class="character-avatar-large">
          <img src="/avatars/placeholder.webp" alt="Character" id="sidebarCharacterImage" onerror="this.style.display='none';">
        </div>
        <h3 class="character-name-large" id="sidebarCharacterName">Loading...</h3>
        <p class="character-creator" id="sidebarCharacterCreator">@Selira</p>
        <p class="character-description" id="sidebarCharacterDescription">
          Loading character information...
        </p>
        
        <div class="character-stats">
          <div class="stat-item">
            <div class="stat-number" id="sidebarCharacterChats">51.4K</div>
            <div class="stat-label">Chats</div>
          </div>
          <div class="stat-item">
            <div class="stat-number" id="sidebarCharacterRating">4.7</div>
            <div class="stat-label">Rating</div>
          </div>
        </div>
        
        <div class="character-tags" id="sidebarCharacterTags">
          <span class="character-tag">Unfiltered</span>
          <span class="character-tag">Anime</span>
          <span class="character-tag">Wholesome</span>
          <span class="character-tag">Animal</span>
          <span class="character-tag">Femboy</span>
          <span class="character-tag">MILF</span>
          <span class="character-tag">Action</span>
          <span class="character-tag">Sci-Fi</span>
          <span class="character-tag">VTuber</span>
          <span class="character-tag">Fantasy</span>
          <span class="character-tag">Female</span>
        </div>
      </div>
    </aside>

    <!-- Character Search Modal -->
    <div class="search-modal" id="searchModal">
      <div class="modal-content">
        <div class="modal-header">
          <h3>Choose a Character</h3>
          <button class="close-btn" onclick="closeCharacterSearch()">√ó</button>
        </div>
        <div class="search-input-wrapper">
          <input type="text" id="characterSearch" placeholder="Search characters...">
        </div>
        <div class="character-grid" id="characterGrid">
          <!-- Sample characters -->
          <div class="character-option" onclick="selectCharacter('aragorn')">
            <div class="character-option-avatar">
              <img src="https://selira.ai/avatars/aragorn-1750067445.webp" alt="Aragorn">
            </div>
            <div class="character-option-name">Aragorn</div>
            <div class="character-option-role">Ranger King</div>
          </div>
          <div class="character-option" onclick="selectCharacter('harry-potter')">
            <div class="character-option-avatar">
              <img src="https://selira.ai/avatars/harry-potter-1750067058.webp" alt="Harry Potter">
            </div>
            <div class="character-option-name">Harry Potter</div>
            <div class="character-option-role">The Boy Who Lived</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Global variables - current character will be loaded from URL
    let currentCharacter = {
      name: 'Loading...',
      slug: 'loading',
      avatar: '/avatars/placeholder.webp',
      creator: '@Selira',
      description: 'Loading character information...',
      chats: '0',
      rating: '0.0',
      tags: ['Loading']
    };

    let chatHistory = [];
    let loadedCharacters = [];

    // Avatar URL correction function
    function fixAvatarUrl(avatarUrl) {
      if (!avatarUrl || avatarUrl === '/avatars/placeholder.webp') {
        return '/avatars/placeholder.webp';
      }
      
      // Fix common naming mismatches
      const avatarMappings = {
        '/avatars/emily.webp': '/avatars/emily-1754251534076.webp',
        '/avatars/aiko.webp': '/avatars/aiko-1754252402847.webp'
      };
      
      if (avatarMappings[avatarUrl]) {
        console.log(`üîß Fixed avatar URL: ${avatarUrl} -> ${avatarMappings[avatarUrl]}`);
        return avatarMappings[avatarUrl];
      }
      
      return avatarUrl;
    }

    // Mobile keyboard detection to keep send button visible
    function setupMobileKeyboardDetection() {
      if (window.innerWidth <= 768) {
        const messageInput = document.getElementById('messageInput');
        let initialViewportHeight = window.innerHeight;
        
        // Modern browsers: Use Visual Viewport API if available
        if (window.visualViewport) {
          function handleViewportChange() {
            const heightDiff = window.innerHeight - window.visualViewport.height;
            if (heightDiff > 150) {
              document.body.classList.add('keyboard-open');
              console.log('üéπ Keyboard open (Visual Viewport)');
            } else {
              document.body.classList.remove('keyboard-open');
              console.log('üéπ Keyboard closed (Visual Viewport)');
            }
          }
          
          window.visualViewport.addEventListener('resize', handleViewportChange);
        } else {
          // Fallback: Detect when keyboard opens/closes by monitoring viewport height changes
          window.addEventListener('resize', function() {
            const currentHeight = window.innerHeight;
            const heightDifference = initialViewportHeight - currentHeight;
            
            // If viewport height decreased significantly, keyboard is likely open
            if (heightDifference > 150) {
              document.body.classList.add('keyboard-open');
              console.log('üéπ Keyboard detected as open');
            } else {
              document.body.classList.remove('keyboard-open');
              console.log('üéπ Keyboard detected as closed');
            }
          });
        }
        
        // Also listen for focus/blur events on input as additional detection
        if (messageInput) {
          messageInput.addEventListener('focus', function() {
            setTimeout(() => {
              document.body.classList.add('keyboard-open');
            }, 300); // Delay to allow keyboard to appear
          });
          
          messageInput.addEventListener('blur', function() {
            setTimeout(() => {
              document.body.classList.remove('keyboard-open');
            }, 300); // Delay to allow keyboard to disappear
          });
        }
      }
    }

    // Initialize chat interface
    document.addEventListener('DOMContentLoaded', function() {
      console.log('üöÄ Selira AI Chat interface loading...');
      loadCharactersFromDatabase();
      initializeChatInterface();
      setupEventListeners();
      setupMobileKeyboardDetection();

      // Load active chats in sidebar immediately
      updateActiveChatsSidebar();

      // Refresh sidebar periodically (every 30 seconds)
      setInterval(updateActiveChatsSidebar, 30000);

      // Character from URL will be loaded after characters are fetched in loadCharactersFromDatabase
    });

    function initializeChatInterface() {
      // Set up character info
      updateCharacterDisplay();
      
      // Auto-resize textarea
      const messageInput = document.getElementById('messageInput');
      if (messageInput) {
        messageInput.addEventListener('input', function() {
          autoResizeTextarea();
          // Hide suggestions when user starts typing (unless they just used a suggestion)
          if (messageInput.value && !messageInput.value.startsWith('Send me a picture')) {
            hideImagePromptSuggestions();
          }
        });
        messageInput.addEventListener('keydown', handleKeyDown);
      }
    }

    function setupEventListeners() {
    }

    // Generate image prompt suggestions based on character
    function generateImagePromptSuggestions(character) {
      const name = character.name || 'companion';
      const tags = character.tags || [];
      const description = character.description || '';
      const ethnicity = character.ethnicity || 'diverse';
      const hairColor = character.hair_color || character.hairColor || 'brown';
      const hairLength = character.hair_length || character.hairLength || 'medium';
      const artStyle = character.companion_type || character.artStyle || 'realistic';

      // Base scenarios that work for most characters
      const baseScenarios = [
        `Send me a picture of ${name} in a cozy coffee shop, sitting by the window with soft natural lighting illuminating her ${hairLength} ${hairColor} hair.`,
        `Send me a picture of ${name} in an elegant outfit, posing confidently with a warm smile and gentle gaze.`,
        `Send me a picture of ${name} in a beautiful garden setting, surrounded by flowers with the golden hour light highlighting her features.`
      ];

      // Tag-specific scenarios
      const tagScenarios = {
        'Girlfriend': [
          `Send me a picture of ${name} in a romantic candlelit dinner setting, wearing an elegant dress with soft lighting accentuating her beauty.`,
          `Send me a picture of ${name} cuddling on a cozy couch, wearing comfortable clothes with a loving expression.`
        ],
        'Romance': [
          `Send me a picture of ${name} on a moonlit beach, her ${hairLength} ${hairColor} hair flowing in the gentle breeze as she gazes at the stars.`,
          `Send me a picture of ${name} in a field of roses, wearing a flowing dress with petals gently falling around her.`
        ],
        'Cute': [
          `Send me a picture of ${name} in adorable casual wear, making a playful expression with sparkling eyes.`,
          `Send me a picture of ${name} holding a cute plushie, sitting in a colorful room with a sweet innocent smile.`
        ],
        'Seductive': [
          `Send me a picture of ${name} in sophisticated lingerie, posing elegantly with confidence and allure.`,
          `Send me a picture of ${name} in a luxury bedroom setting, wearing silk pajamas with an inviting gaze.`
        ],
        'Maid': [
          `Send me a picture of ${name} in a classic maid outfit, gracefully cleaning in an elegant mansion with perfect posture.`,
          `Send me a picture of ${name} serving tea in a beautiful maid uniform, with a professional yet warm smile.`
        ],
        'Fantasy': [
          `Send me a picture of ${name} in a magical forest clearing, wearing flowing robes with mystical light surrounding her.`,
          `Send me a picture of ${name} casting spells in an enchanted tower, her ${hairColor} hair glowing with magical energy.`
        ],
        'Angel': [
          `Send me a picture of ${name} with beautiful white wings spread wide, standing in heavenly light with a serene expression.`,
          `Send me a picture of ${name} in flowing white robes on fluffy clouds, radiating divine beauty and grace.`
        ],
        'Monster': [
          `Send me a picture of ${name} with her unique monster features, posing playfully in a mysterious dark forest.`,
          `Send me a picture of ${name} showing her supernatural side while maintaining an alluring and captivating presence.`
        ],
        'Boss': [
          `Send me a picture of ${name} in a power suit at her executive office, commanding presence with confident authority.`,
          `Send me a picture of ${name} in professional attire during a business meeting, exuding leadership and elegance.`
        ],
        'Student': [
          `Send me a picture of ${name} in a school uniform, studying in a bright classroom with focused determination.`,
          `Send me a picture of ${name} in casual student clothes on campus, carrying books with a cheerful expression.`
        ],
        'Teacher': [
          `Send me a picture of ${name} in professional teacher attire, standing confidently in front of a classroom blackboard.`,
          `Send me a picture of ${name} in smart business casual, grading papers in a cozy office with warm lighting.`
        ]
      };

      // Art style specific additions
      const artStyleAdditions = {
        'anime': ' in beautiful anime art style with vibrant colors and detailed animation quality',
        'realistic': ' in photorealistic style with natural lighting and detailed features'
      };

      // Build suggestions array
      let suggestions = [...baseScenarios];

      // Add tag-specific suggestions
      tags.forEach(tag => {
        if (tagScenarios[tag]) {
          suggestions.push(...tagScenarios[tag]);
        }
      });

      // Add art style modifier to all suggestions
      const styleModifier = artStyleAdditions[artStyle] || '';
      suggestions = suggestions.map(suggestion => suggestion + styleModifier);

      // Return 3 random suggestions
      const shuffled = suggestions.sort(() => 0.5 - Math.random());
      return shuffled.slice(0, 3);
    }

    // Show image prompt suggestions
    function showImagePromptSuggestions() {
      if (!currentCharacter || !currentCharacter.name) return;

      const suggestions = generateImagePromptSuggestions(currentCharacter);
      const suggestionContainer = document.getElementById('suggestionButtons');
      const suggestionsDiv = document.getElementById('imagePromptSuggestions');

      if (!suggestionContainer || !suggestionsDiv) return;

      // Clear existing suggestions
      suggestionContainer.innerHTML = '';

      // Add new suggestion buttons
      suggestions.forEach(suggestion => {
        const button = document.createElement('button');
        button.className = 'suggestion-button';
        button.textContent = suggestion;
        button.onclick = () => useSuggestion(suggestion);
        suggestionContainer.appendChild(button);
      });

      // Show suggestions
      suggestionsDiv.classList.add('visible');
    }

    // Hide image prompt suggestions
    function hideImagePromptSuggestions() {
      const suggestionsDiv = document.getElementById('imagePromptSuggestions');
      if (suggestionsDiv) {
        suggestionsDiv.classList.remove('visible');
      }
    }

    // Use a suggestion (put it in the input field)
    function useSuggestion(suggestion) {
      const messageInput = document.getElementById('messageInput');
      if (messageInput) {
        messageInput.value = suggestion;
        messageInput.focus();
        autoResizeTextarea();
      }
      hideImagePromptSuggestions();
    }

    function autoResizeTextarea() {
      const textarea = document.getElementById('messageInput');
      textarea.style.height = 'auto';
      textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
    }

    function handleKeyDown(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    }

    function updateCharacterDisplay() {
      // Update header
      document.getElementById('currentCharacterName').textContent = currentCharacter.name;
      document.getElementById('currentCharacterStatus').textContent = currentCharacter.creator;
      const headerImage = document.getElementById('characterImage');
      if (currentCharacter.avatar && currentCharacter.avatar !== '/avatars/placeholder.webp') {
        headerImage.src = fixAvatarUrl(currentCharacter.avatar);
        headerImage.style.display = 'block';
        headerImage.onerror = function() { this.style.display = 'none'; };
      } else {
        headerImage.style.display = 'none';
      }
      
      // Update sidebar
      document.getElementById('sidebarCharacterName').textContent = currentCharacter.name;
      document.getElementById('sidebarCharacterCreator').textContent = currentCharacter.creator;
      document.getElementById('sidebarCharacterDescription').textContent = currentCharacter.description;
      const sidebarImage = document.getElementById('sidebarCharacterImage');
      if (currentCharacter.avatar && currentCharacter.avatar !== '/avatars/placeholder.webp') {
        sidebarImage.src = fixAvatarUrl(currentCharacter.avatar);
        sidebarImage.style.display = 'block';
        sidebarImage.onerror = function() { this.style.display = 'none'; };
      } else {
        sidebarImage.style.display = 'none';
      }
      document.getElementById('sidebarCharacterChats').textContent = currentCharacter.chats;
      document.getElementById('sidebarCharacterRating').textContent = currentCharacter.rating;
      
      // Update tags
      const tagsContainer = document.getElementById('sidebarCharacterTags');
      if (tagsContainer && currentCharacter.tags) {
        tagsContainer.innerHTML = currentCharacter.tags.map(tag =>
          `<span class="character-tag">${tag}</span>`
        ).join('');
      }

      // Hide any existing suggestions when character changes
      hideImagePromptSuggestions();
    }

    function showCharacterSearch() {
      document.getElementById('searchModal').classList.add('open');
      document.getElementById('characterSearch').focus();
    }

    function closeCharacterSearch() {
      document.getElementById('searchModal').classList.remove('open');
    }

    function selectCharacter(slug) {
      // Update character based on selection
      // This would normally fetch from API
      console.log('Selected character:', slug);
      closeCharacterSearch();
    }

    async function sendMessage() {
      const messageInput = document.getElementById('messageInput');
      const message = messageInput.value.trim();

      if (!message) return;

      // Check authentication first
      const isAuthenticated = window.isUserAuthenticated ? window.isUserAuthenticated() : false;
      const user = window.getCurrentUser ? window.getCurrentUser() : null;

      if (!isAuthenticated || !user) {
        // Show login prompt instead of sending message
        console.log('üîí User not authenticated, showing login prompt');

        // Show custom popup with login/register options
        const modal = document.createElement('div');
        modal.style.cssText = `
          position: fixed; top: 0; left: 0; right: 0; bottom: 0;
          background: rgba(0,0,0,0.8); z-index: 10000;
          display: flex; align-items: center; justify-content: center;
          backdrop-filter: blur(8px);
        `;

        modal.innerHTML = `
          <div style="
            background: var(--bg-secondary); border: 1px solid var(--accent);
            border-radius: 16px; padding: 32px; max-width: 400px; margin: 20px;
            text-align: center;
          ">
            <h2 style="color: var(--accent); margin: 0 0 16px 0; font-family: 'Playfair Display', serif;">
              Login Required
            </h2>
            <p style="color: var(--text-secondary); margin: 0 0 24px 0; line-height: 1.6;">
              Please login or create an account to chat with AI companions on Selira AI.
            </p>
            <div style="display: flex; gap: 12px; justify-content: center;">
              <button onclick="window.openLoginModal('login'); this.closest('[style*=fixed]').remove();" style="
                background: var(--accent); color: white; border: none;
                padding: 12px 24px; border-radius: 8px; font-weight: 600;
                cursor: pointer; font-size: 14px;
              ">Login</button>
              <button onclick="window.openLoginModal('signup'); this.closest('[style*=fixed]').remove();" style="
                background: transparent; color: var(--text-primary);
                border: 1px solid var(--border); padding: 12px 24px;
                border-radius: 8px; font-weight: 600; cursor: pointer;
                font-size: 14px;
              ">Sign Up</button>
              <button onclick="this.closest('[style*=fixed]').remove();" style="
                background: transparent; color: var(--text-secondary);
                border: 1px solid var(--border); padding: 12px 24px;
                border-radius: 8px; font-weight: 600; cursor: pointer;
                font-size: 14px;
              ">Cancel</button>
            </div>
          </div>
        `;

        document.body.appendChild(modal);
        modal.addEventListener('click', (e) => {
          if (e.target === modal) modal.remove();
        });

        // Clear the input
        messageInput.value = '';
        autoResizeTextarea();
        return;
      }

      // Check if this is an image request
      if (message.toLowerCase().startsWith('send me a picture')) {
        await handleImageRequest(message);
        messageInput.value = '';
        autoResizeTextarea();
        return;
      }

      // Add user message
      addMessage(message, 'user');
      messageInput.value = '';
      autoResizeTextarea();

      // User message will be saved together with AI response

      // Show typing indicator
      const typingIndicator = addTypingIndicator();

      try {
        // Use authenticated user data
        const auth0_id = user.sub || user.uid || user.auth0_id;
        const user_email = user.email;

        console.log('üë§ Authenticated user:', {
          auth0_id: auth0_id,
          email: user_email
        });

        // Memory sync for authenticated users
        console.log('üß† Memory sync enabled - loading memories...');
        await loadMemoriesForContext(currentCharacter.slug, auth0_id);
        
        // Get chat history for context
        const chatHistory = getChatHistoryForContext(currentCharacter.slug);
        
        // Call OpenRouter chat API
        console.log('ü§ñ Sending message to AI:', { 
          character: currentCharacter.slug, 
          auth0_id: auth0_id,
          message: message.substring(0, 50) + '...',
          history_length: chatHistory.length
        });
        
        const response = await fetch('/.netlify/functions/openrouter-chat', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            message: message,
            character_slug: currentCharacter.slug,
            auth0_id: auth0_id,
            user_email: user_email, // Add user email for message saving
            model: 'mistralai/mistral-nemo',
            local_history: chatHistory, // Send localStorage history for context
            memories: window.currentMemories || [] // Send loaded memories for AI context
          })
        });
        
        if (!response.ok) {
          throw new Error(`API Error: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('‚úÖ Received AI response:', data.response?.substring(0, 100) + '...');
        console.log('ü§ñ Model used:', data.model_used);
        console.log('üíæ Saved to DB:', data.saved_to_db);
        
        // Remove typing indicator
        typingIndicator.remove();
        
        // Add AI response (clean, without debug info)
        const responseText = data.response || "I'm having trouble responding right now. Please try again!";
        addMessage(responseText, 'ai');
        
        // Save both user and AI message to localStorage
        saveBothMessagesToStorage(currentCharacter.slug, message, data.response);

        // Update sidebar to reflect new activity
        updateActiveChatsSidebar();
        
        // Memory saving re-enabled now that functions are working
        console.log('üß† Memory saving enabled - saving important memories...');
        await saveMemoryIfImportant(currentCharacter.slug, message, data.response, auth0_id);
        
      } catch (error) {
        console.error('‚ùå Error sending message:', error);
        
        // Remove typing indicator
        if (typingIndicator && typingIndicator.parentNode) {
          typingIndicator.remove();
        }
        
        // Add error message with more detail
        addMessage(`I'm having trouble connecting right now (${error.message}). Please try again in a moment!`, 'ai');
      }
    }

    // Debug function to test OpenRouter API
    async function testOpenRouterAPI() {
      try {
        // Get current user data for test
        const user = window.getCurrentUser();
        const testAuth0Id = user?.sub || 'anonymous';
        const testEmail = user?.email || 'anonymous';
        const testCharSlug = currentCharacter?.slug || 'orion-nightfall';

        console.log('üß™ Testing with:', { testCharSlug, testEmail });

        const response = await fetch('/.netlify/functions/openrouter-chat', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            message: 'Hello, how are you?',
            character_slug: testCharSlug,
            auth0_id: testAuth0Id,
            user_email: testEmail,
            model: 'mistralai/mistral-nemo'
          })
        });
        
        console.log('üß™ Test API Response Status:', response.status);
        const data = await response.text();
        console.log('üß™ Test API Response:', data);
        
      } catch (error) {
        console.error('üß™ Test API Error:', error);
      }
    }

    // Auto-test API on load (remove later)
    setTimeout(testOpenRouterAPI, 2000);

    // Load chat history for current character
    async function loadChatHistory(characterSlug) {
      try {
        const user = JSON.parse(localStorage.getItem('user') || '{}');
        const auth0_id = user.sub || user.auth0_id || user.email || 'anonymous';
        
        // Skip for anonymous users
        if (auth0_id === 'anonymous') {
          console.log('üë§ Anonymous user - no chat history to load');
          return;
        }
        
        console.log('üìö Loading chat history for:', characterSlug);
        
        const response = await fetch('/.netlify/functions/get-chat-history-selira', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            auth0_id: auth0_id,
            character_slug: characterSlug,
            limit: 20
          })
        });
        
        if (response.ok) {
          const data = await response.json();
          if (data.success && data.messages && data.messages.length > 0) {
            console.log('‚úÖ Loaded', data.messages.length, 'previous messages');
            displayChatHistory(data.messages);
          } else {
            console.log('üí≠ No previous chat history found');
          }
        } else {
          console.log('‚ö†Ô∏è Failed to load chat history:', response.status);
        }
        
      } catch (error) {
        console.error('‚ùå Error loading chat history:', error);
      }
    }

    // Display loaded chat history
    function displayChatHistory(messages) {
      const messagesContainer = document.getElementById('chatMessages');
      
      // Clear existing messages
      messagesContainer.innerHTML = '';
      
      messages.forEach(msg => {
        const sender = msg.MessageType === 'user' ? 'user' : 'ai';
        addMessage(msg.Content, sender, false); // false = don't scroll to bottom yet
      });
      
      // Scroll to bottom after all messages loaded
      setTimeout(() => {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }, 100);
    }

    // Save both messages to localStorage (prevents duplicates)
    function saveBothMessagesToStorage(characterSlug, userMessage, aiResponse) {
      try {
        const storageKey = `chat_${characterSlug}`;
        let chatHistory = JSON.parse(localStorage.getItem(storageKey) || '[]');
        
        // Add user message
        chatHistory.push({
          type: 'user',
          content: userMessage,
          timestamp: Date.now()
        });
        
        // Add AI response 
        chatHistory.push({
          type: 'ai', 
          content: aiResponse,
          timestamp: Date.now() + 1 // Slightly after user message
        });
        
        // Keep only last 50 messages
        chatHistory = chatHistory.slice(-50);
        
        localStorage.setItem(storageKey, JSON.stringify(chatHistory));
        console.log('üíæ Saved conversation to localStorage:', characterSlug, chatHistory.length, 'messages');
        
      } catch (error) {
        console.error('‚ùå Error saving to localStorage:', error);
      }
    }

    // Save chat to localStorage for persistence (legacy function - use saveBothMessagesToStorage)
    function saveChatToStorage(characterSlug, userMessage, aiResponse) {
      // This function is kept for compatibility but shouldn't create duplicates
      console.log('‚ö†Ô∏è Legacy save function called - use saveBothMessagesToStorage instead');
    }

    // Load chat history from localStorage
    function loadChatHistoryFromStorage(characterSlug) {
      try {
        // Clean up duplicates first
        const chatHistory = cleanupChatHistory(characterSlug);
        
        if (chatHistory.length > 0) {
          console.log('üìö Loading', chatHistory.length, 'clean messages from localStorage for:', characterSlug);
          console.log('üì¶ First message preview:', chatHistory[0]);
          
          const messagesContainer = document.getElementById('chatMessages');
          messagesContainer.innerHTML = '';
          
          chatHistory.forEach(msg => {
            if (msg.type === 'image') {
              // Handle image messages
              const imageData = msg.content;
              addImageMessage(imageData.imageUrl, imageData.prompt, imageData.style, false);
            } else {
              // Handle regular text messages
              addMessage(msg.content, msg.type, false);
            }
          });
          
          setTimeout(() => {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
          }, 100);
          
        } else {
          console.log('üí≠ No chat history in localStorage for:', characterSlug);
          console.log('üîç Checking localStorage keys:', Object.keys(localStorage).filter(k => k.startsWith('chat_')));
        }
        
      } catch (error) {
        console.error('‚ùå Error loading from localStorage:', error);
      }
    }


    // Get chat history for AI context (last 10 messages)
    function getChatHistoryForContext(characterSlug) {
      try {
        // Get cleaned history
        const fullHistory = cleanupChatHistory(characterSlug);
        
        // Get last 10 messages for context (exclude current message being sent)
        const contextHistory = fullHistory.slice(-10).map(msg => {
          if (msg.type === 'image') {
            // Convert image messages to text for AI context
            return {
              role: 'assistant',
              content: `I generated an image for you: "${msg.content.prompt}" in ${msg.content.style} style.`
            };
          } else {
            return {
              role: msg.type === 'user' ? 'user' : 'assistant',
              content: msg.content
            };
          }
        });
        
        console.log('üß† Sending context history:', contextHistory.length, 'messages');
        return contextHistory;
        
      } catch (error) {
        console.error('‚ùå Error getting context history:', error);
        return [];
      }
    }

    function addMessage(content, sender, autoScroll = true) {
      const messagesContainer = document.getElementById('chatMessages');
      const welcomeMessage = messagesContainer.querySelector('.welcome-message');
      
      if (welcomeMessage) {
        welcomeMessage.remove();
      }
      
      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${sender}`;
      
      if (sender === 'ai') {
        messageDiv.innerHTML = `
          <div class="message-avatar">
            <img src="${fixAvatarUrl(currentCharacter.avatar)}" alt="${currentCharacter.name}" onerror="this.style.display='none'">
          </div>
          <div class="message-content">${content}</div>
        `;
      } else {
        messageDiv.innerHTML = `
          <div class="message-content">${content}</div>
        `;
      }
      
      messagesContainer.appendChild(messageDiv);
      
      if (autoScroll) {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }
    }

    function clearChat() {
      // Clear chat from UI
      const messagesContainer = document.getElementById('chatMessages');
      messagesContainer.innerHTML = `
        <div class="welcome-message" style="text-align: center; padding: 40px 20px; color: var(--text-secondary);">
          <div style="font-size: 48px; margin-bottom: 16px;">üí≠</div>
          <h3 style="color: var(--text-primary); margin-bottom: 8px;">Chat Cleared</h3>
          <p>Start a new conversation with ${currentCharacter.name}!</p>
        </div>
      `;
      
      // Clear chat history from localStorage
      if (currentCharacter.slug) {
        const storageKey = `chat_${currentCharacter.slug}`;
        localStorage.removeItem(storageKey);
        console.log('üóëÔ∏è Cleared chat history for:', currentCharacter.slug);

        // Update sidebar after clearing
        updateActiveChatsSidebar();
      }
    }

    // Clean up duplicate messages in localStorage
    function cleanupChatHistory(characterSlug) {
      try {
        const storageKey = `chat_${characterSlug}`;
        const rawHistory = JSON.parse(localStorage.getItem(storageKey) || '[]');
        
        // Remove consecutive duplicates
        const cleanHistory = [];
        let lastMessage = null;
        
        rawHistory.forEach(msg => {
          if (!lastMessage || 
              lastMessage.content !== msg.content || 
              lastMessage.type !== msg.type) {
            cleanHistory.push(msg);
            lastMessage = msg;
          }
        });
        
        if (cleanHistory.length !== rawHistory.length) {
          localStorage.setItem(storageKey, JSON.stringify(cleanHistory));
          console.log('üßπ Cleaned chat history:', rawHistory.length, '‚Üí', cleanHistory.length);
        }
        
        return cleanHistory;
        
      } catch (error) {
        console.error('‚ùå Error cleaning chat history:', error);
        return [];
      }
    }

    function toggleSidebar() {
      const sidebar = document.getElementById('sidebar');
      const overlay = document.querySelector('.sidebar-overlay');
      
      sidebar.classList.toggle('open');
      
      // Create overlay if it doesn't exist
      if (!overlay && sidebar.classList.contains('open')) {
        const newOverlay = document.createElement('div');
        newOverlay.className = 'sidebar-overlay show';
        newOverlay.onclick = closeSidebar;
        document.body.appendChild(newOverlay);
      } else if (overlay) {
        overlay.classList.toggle('show', sidebar.classList.contains('open'));
        if (!sidebar.classList.contains('open')) {
          setTimeout(() => overlay.remove(), 300);
        }
      }
    }

    function closeSidebar() {
      const sidebar = document.getElementById('sidebar');
      const overlay = document.querySelector('.sidebar-overlay');
      
      sidebar.classList.remove('open');
      if (overlay) {
        overlay.classList.remove('show');
        setTimeout(() => overlay.remove(), 300);
      }
    }

    // Close sidebar when clicking outside on mobile
    document.addEventListener('click', function(e) {
      const sidebar = document.getElementById('sidebar');
      const mobileBtn = document.querySelector('.mobile-menu-btn');
      
      if (window.innerWidth <= 768 && 
          !sidebar.contains(e.target) && 
          !mobileBtn.contains(e.target) && 
          sidebar.classList.contains('open')) {
        closeSidebar();
      }
    });

    // Close sidebar when clicking on any link inside it
    document.addEventListener('DOMContentLoaded', function() {
      const sidebar = document.getElementById('sidebar');
      if (sidebar) {
        sidebar.addEventListener('click', function(event) {
          // If clicked element is a link or chat item, close the sidebar on mobile
          if ((event.target.tagName === 'A' || event.target.closest('.chat-item')) && window.innerWidth <= 768) {
            closeSidebar();
          }
        });
      }
    });

    // Handle responsive design
    function handleResize() {
      const isMobile = window.innerWidth <= 768;
      const mobileBtn = document.querySelector('.mobile-menu-btn');
      
      if (mobileBtn) {
        mobileBtn.style.display = isMobile ? 'block' : 'none';
      }
    }

    window.addEventListener('resize', handleResize);
    document.addEventListener('DOMContentLoaded', handleResize);

    // ===== DATABASE INTEGRATION =====
    async function loadCharactersFromDatabase() {
      try {
        console.log('üì° Loading characters from database...');
        const response = await fetch('/.netlify/functions/characters');
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.success && data.characters) {
          const characters = data.characters.slice(0, 10).map(char => ({
            id: char.Character_ID || char.Name,
            name: char.Name || 'Unknown',
            title: char.Character_Title || '',
            description: char.Character_Description || '',
            avatar: char.Avatar_URL ? char.Avatar_URL.replace('narrin.ai', 'selira.ai') : null,
            category: char.Category || 'Other',
            slug: char.Slug || (char.Name ? char.Name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '') : 'unknown'),
            creator: char.Nickname || 'Selira',
            tags: Array.isArray(char.Tags) ? char.Tags.slice(0, 11) : (char.Tags || '').toString().split(',').filter(Boolean).slice(0, 11), // Get real tags
            character_url: char.Character_URL ? char.Character_URL.replace('narrin.ai', 'selira.ai') : null,
            // Add appearance data
            companion_type: char.companion_type,
            sex: char.sex,
            ethnicity: char.ethnicity,
            hair_length: char.hair_length,
            hair_color: char.hair_color
          }));
          
          // Store characters globally
          loadedCharacters = characters;
          
          // Update character search modal with real characters
          updateCharacterSearchModal(characters);

          // Store all characters globally for later use
          window.allCharacters = characters;

          // Update sidebar with active chat companions
          updateActiveChatsSidebar();

          console.log('‚úÖ Loaded characters from database:', characters.length);
          
          // Now load character from URL parameter
          loadCharacterFromURL();
          
          // Also try to load a specific character directly from URL if available
          loadCharacterDirectly();
        }
      } catch (error) {
        console.error('‚ùå Error loading characters:', error);
        // Keep demo data as fallback
      }
    }

    function updateCharacterSearchModal(characters) {
      const characterGrid = document.getElementById('characterGrid');
      if (!characterGrid) return;
      
      characterGrid.innerHTML = characters.map(character => `
        <div class="character-option" onclick="selectCharacter('${character.slug}', '${character.name}', '${fixAvatarUrl(character.avatar)}', '${character.title}')">
          <div class="character-option-avatar">
            <img src="${fixAvatarUrl(character.avatar)}" alt="${character.name}" onerror="this.style.display='none'">
          </div>
          <div class="character-option-name">${character.name}</div>
          <div class="character-option-role">${character.title}</div>
        </div>
      `).join('');
    }

    // Get all active chat companions from localStorage
    function getActiveChatCompanions() {
      const companions = [];
      const keys = Object.keys(localStorage);

      // Find all chat_ keys in localStorage
      keys.forEach(key => {
        if (key.startsWith('chat_')) {
          const characterSlug = key.replace('chat_', '');
          const chatHistory = JSON.parse(localStorage.getItem(key) || '[]');

          // Only include if there are messages
          if (chatHistory.length > 0) {
            // Get last message for preview
            const lastMessage = chatHistory[chatHistory.length - 1];
            const lastUserMessage = chatHistory.filter(m => m.type === 'user').pop();

            companions.push({
              slug: characterSlug,
              lastMessage: lastMessage?.content || '',
              lastUserMessage: lastUserMessage?.content || '',
              timestamp: lastMessage?.timestamp || Date.now(),
              messageCount: chatHistory.length
            });
          }
        }
      });

      // Sort by most recent activity
      companions.sort((a, b) => b.timestamp - a.timestamp);

      return companions;
    }

    // Update sidebar with active chat companions
    async function updateActiveChatsSidebar() {
      const chatList = document.getElementById('chatList');
      if (!chatList) return;

      const activeCompanions = getActiveChatCompanions();

      if (activeCompanions.length === 0) {
        chatList.innerHTML = `
          <div class="no-chats" style="text-align: center; padding: 20px; color: var(--text-secondary); font-size: 14px;">
            <div style="margin-bottom: 8px;">üí¨</div>
            <div>No active chats yet</div>
            <div style="font-size: 12px; margin-top: 4px;">Start a conversation!</div>
          </div>
        `;
        return;
      }

      // Build HTML for active chats
      let html = '';

      for (const companion of activeCompanions) {
        // Try to find character in loaded characters
        let character = loadedCharacters.find(c => c.slug === companion.slug);

        // If not found, try to find from loaded characters by slug
        if (!character && window.allCharacters) {
          character = window.allCharacters.find(c => c.slug === companion.slug);
        }

        // Create chat item
        const isActive = currentCharacter && currentCharacter.slug === companion.slug;
        const preview = companion.lastUserMessage.length > 40
          ? companion.lastUserMessage.substring(0, 40) + '...'
          : companion.lastUserMessage;

        html += `
          <div class="chat-item ${isActive ? 'active' : ''}"
               onclick="switchToCompanion('${companion.slug}')"
               data-slug="${companion.slug}">
            <div class="chat-avatar">
              ${ character ?
                `<img src="${fixAvatarUrl(character.avatar)}" alt="${character.name}" onerror="this.style.display='none'">` :
                `<div style="width: 40px; height: 40px; background: var(--bg-tertiary); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: var(--text-secondary);">?</div>`
              }
            </div>
            <div class="chat-info">
              <div class="chat-name">${character ? character.name : companion.slug}</div>
              <div class="chat-preview">${preview || character?.description?.substring(0, 30) || 'Start chatting...'}</div>
            </div>
          </div>
        `;
      }

      chatList.innerHTML = html;
    }

    // Switch to a companion from the sidebar
    async function switchToCompanion(slug) {
      // Find character in loaded data
      let character = loadedCharacters.find(c => c.slug === slug);

      if (!character && window.allCharacters) {
        character = window.allCharacters.find(c => c.slug === slug);
      }

      if (!character) {
        // Try to load character data from API
        try {
          const response = await fetch(`/.netlify/functions/characters?slug=${slug}`);
          if (response.ok) {
            const data = await response.json();
            if (data.characters && data.characters.length > 0) {
              character = data.characters[0];
            }
          }
        } catch (error) {
          console.error('‚ùå Error loading character:', error);
        }
      }

      if (character) {
        // Update current character
        currentCharacter = {
          name: character.name,
          slug: character.slug,
          avatar: character.avatar,
          title: character.title || character.description,
          description: character.description,
          greeting: character.greeting || `Hello! I'm ${character.name}. ${character.description}`,
          creator: character.creator || '@Selira',
          chats: character.chats || '0',
          rating: character.rating || '4.5',
          tags: character.tags || [],
          voice: character.voice || ''
        };

        // Update UI
        updateCharacterDisplay();

        // Load chat history
        loadChatHistoryFromStorage(slug);

        // Update active state in sidebar
        document.querySelectorAll('.chat-item').forEach(item => {
          item.classList.toggle('active', item.dataset.slug === slug);
        });

        // Close sidebar on mobile
        if (window.innerWidth <= 768) {
          closeSidebar();
        }

        console.log('‚úÖ Switched to companion:', character.name);
      } else {
        console.error('‚ùå Character not found:', slug);
        // Still load the chat history even if character data not found
        loadChatHistoryFromStorage(slug);
      }
    }

    // Legacy function for compatibility
    function updateRecentChatsSidebar(characters) {
      // This function is now replaced by updateActiveChatsSidebar
      // Keep it for compatibility but call the new function
      updateActiveChatsSidebar();
    }

    function selectCharacterFromSidebar(slug, name, avatar, title) {
      // Find character in loaded data for real tags and creator
      const character = loadedCharacters.find(c => c.slug === slug) || {};
      
      // Update current character
      currentCharacter = {
        name: name,
        slug: slug,
        avatar: fixAvatarUrl(avatar),
        creator: '@' + (character.creator || 'Selira'),
        description: character.description || 'Start a conversation with ' + name,
        chats: Math.floor(Math.random() * 100) + 'K',
        rating: (Math.random() * 2 + 3).toFixed(1),
        tags: character.tags || ['Fantasy', 'Adventure', 'Hero']
      };
      
      updateCharacterDisplay();
      
      // Update active chat item
      document.querySelectorAll('.chat-item').forEach(item => {
        item.classList.remove('active');
      });
      event.currentTarget.classList.add('active');
      
      // Update URL to reflect new character
      updateUrlForCharacter(slug);
      
      // Load chat history for this character
      loadChatHistoryFromStorage(slug);
      
      // Only clear if no history was loaded
      setTimeout(() => {
        const hasMessages = document.querySelectorAll('.message:not(.welcome-message)').length > 0;
        if (!hasMessages) {
          clearChat();
        }
      }, 100);
    }

    function selectCharacter(slug, name, avatar, title) {
      // Update character and close modal
      currentCharacter = {
        name: name,
        slug: slug,
        avatar: fixAvatarUrl(avatar),
        creator: '@Selira',
        description: 'Start a conversation with ' + name,
        chats: Math.floor(Math.random() * 100) + 'K',
        rating: (Math.random() * 2 + 3).toFixed(1),
        tags: ['Fantasy', 'Adventure', 'Hero']
      };
      
      updateCharacterDisplay();
      
      // Update URL to reflect new character
      updateUrlForCharacter(slug);
      
      closeCharacterSearch();
      
      // Load chat history for this character
      loadChatHistoryFromStorage(slug);
      
      // Only clear if no history was loaded
      setTimeout(() => {
        const hasMessages = document.querySelectorAll('.message:not(.welcome-message)').length > 0;
        if (!hasMessages) {
          clearChat();
        }
      }, 100);
    }

    // Update URL when switching characters
    function updateUrlForCharacter(characterSlug) {
      if (!characterSlug) return;
      
      // Find the character data to get the proper URL
      const character = loadedCharacters.find(c => c.slug === characterSlug);
      let newUrl;
      
      if (character && character.character_url) {
        // Use the character's specific URL from Airtable
        newUrl = character.character_url;
      } else {
        // Fallback to standard format
        newUrl = `https://selira.ai/chat.html?char=${encodeURIComponent(characterSlug)}`;
      }
      
      // Update the URL without reloading the page
      const currentUrl = window.location.href;
      if (currentUrl !== newUrl) {
        console.log('üîÑ Updating URL for character:', characterSlug, '‚Üí', newUrl);
        window.history.pushState({character: characterSlug}, '', newUrl);
      }
    }

    // Handle browser back/forward buttons
    window.addEventListener('popstate', function(event) {
      if (event.state && event.state.character) {
        console.log('‚Ü©Ô∏è Browser navigation to character:', event.state.character);
        // Find the character and switch to it without updating URL again
        const character = loadedCharacters.find(c => c.slug === event.state.character);
        if (character) {
          // Switch character but skip URL update to avoid loop
          selectCharacterFromSidebarSilent(character.slug, character.name, fixAvatarUrl(character.avatar), character.title);
        }
      }
    });

    // Extract greeting from character description
    function extractGreetingFromDescription(description) {
      if (!description) return null;

      const greetingMatch = description.match(/Greeting:\s*(.+?)(?:\n|$)/);
      return greetingMatch ? greetingMatch[1].trim() : null;
    }

    // Check if character was recently created (within last 5 minutes)
    function checkIfNewCharacter(slug) {
      const newCharacterKey = `new_character_${slug}`;
      const creationTime = localStorage.getItem(newCharacterKey);

      if (!creationTime) return false;

      const now = Date.now();
      const created = parseInt(creationTime);
      const fiveMinutes = 5 * 60 * 1000; // 5 minutes in milliseconds

      if (now - created < fiveMinutes) {
        return true;
      } else {
        // Clean up old marker
        localStorage.removeItem(newCharacterKey);
        return false;
      }
    }

    // Clear all messages from chat display
    function clearChatDisplay() {
      const chatMessages = document.getElementById('chatMessages');
      if (chatMessages) {
        chatMessages.innerHTML = '';
        console.log('üßΩ Cleared chat display');
      }
    }

    // Switch character without updating URL (for browser navigation)
    function selectCharacterFromSidebarSilent(slug, name, avatar, title) {
      // Find character in loaded data for real tags and creator
      const character = loadedCharacters.find(c => c.slug === slug) || {};

      // Check if this is a newly created character (less than 5 minutes old in localStorage)
      const isNewCharacter = checkIfNewCharacter(slug);

      // Update current character
      currentCharacter = {
        name: name,
        slug: slug,
        avatar: fixAvatarUrl(avatar),
        creator: '@' + (character.creator || character.createdBy || 'Selira'),
        description: character.description || 'Start a conversation with ' + name,
        greeting: character.greeting || extractGreetingFromDescription(character.description) || `Hello! I'm ${name}. Nice to meet you!`,
        chats: character.chats || (isNewCharacter ? '0' : Math.floor(Math.random() * 100) + 'K'),
        rating: character.rating || (isNewCharacter ? '5.0' : (Math.random() * 2 + 3).toFixed(1)),
        tags: character.tags || ['Fantasy', 'Adventure', 'Hero']
      };

      // Clear chat display first
      clearChatDisplay();

      // If this is a new character, clear any existing chat history and start fresh
      if (isNewCharacter) {
        const storageKey = `chat_${slug}`;
        localStorage.removeItem(storageKey);
        console.log('üßπ Cleared chat history for new character:', slug);

        // Add the greeting message as the first message
        setTimeout(() => {
          if (currentCharacter.greeting) {
            addMessage('character', currentCharacter.greeting);
          }
        }, 500);
      } else {
        // Load existing chat history for this character
        loadChatHistoryFromStorage(slug);
      }

      updateCharacterDisplay();

      // Update active chat item
      document.querySelectorAll('.chat-item').forEach(item => {
        item.classList.remove('active');
      });
      // Find and highlight the correct chat item
      const chatItems = document.querySelectorAll('.chat-item');
      chatItems.forEach(item => {
        if (item.onclick && item.onclick.toString().includes(slug)) {
          item.classList.add('active');
        }
      });
      
      // Only show welcome message if no history exists
      setTimeout(() => {
        const hasMessages = document.querySelectorAll('.message:not(.welcome-message)').length > 0;
        if (!hasMessages) {
          showWelcomeMessage();
        }
      }, 100);
    }

    // Show welcome message without clearing localStorage
    function showWelcomeMessage() {
      const messagesContainer = document.getElementById('chatMessages');
      messagesContainer.innerHTML = `
        <div class="welcome-message" style="text-align: center; padding: 40px 20px; color: var(--text-secondary);">
          <div style="font-size: 48px; margin-bottom: 16px;">üí≠</div>
          <h3 style="color: var(--text-primary); margin-bottom: 8px;">Start Conversation</h3>
          <p>Begin chatting with ${currentCharacter.name}!</p>
        </div>
      `;
    }

    // Add typing indicator
    function addTypingIndicator() {
      const messagesContainer = document.getElementById('chatMessages');
      const typingDiv = document.createElement('div');
      typingDiv.className = 'message ai typing-indicator';
      typingDiv.innerHTML = `
        <div class="message-avatar">
          <img src="${fixAvatarUrl(currentCharacter.avatar)}" alt="${currentCharacter.name}" onerror="this.style.display='none'">
        </div>
        <div class="message-content">
          <div class="typing-dots">
            <span></span><span></span><span></span>
          </div>
        </div>
      `;
      
      messagesContainer.appendChild(typingDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      return typingDiv;
    }

    // Ensure user exists in Airtable (auto-sync from Auth0)
    async function ensureUserInAirtable(auth0_id, email, name, nickname) {
      try {
        console.log('üîÑ Syncing Auth0 user to Airtable...');
        
        const response = await fetch('/.netlify/functions/selira-user-sync', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            auth0_id: auth0_id,
            email: email,
            name: name,
            picture: user?.picture
          })
        });

        if (response.ok) {
          const result = await response.json();
          console.log('‚úÖ User sync result:', result.action, result.message);
        } else {
          console.log('‚ö†Ô∏è User sync failed:', response.status);
        }
      } catch (error) {
        console.log('‚ö†Ô∏è User sync error:', error.message);
        // Don't fail the chat if sync fails
      }
    }

    // Save chat message to Airtable
    async function saveChatMessage(auth0_id, user_email, character_slug, userMessage, aiResponse) {
      try {
        // Skip saving for anonymous users
        if (auth0_id === 'anonymous') {
          console.log('üë§ Anonymous user - skipping chat save');
          return;
        }
        
        console.log('üíæ Saving chat message:', {
          auth0_id: auth0_id,
          email: user_email,
          character: character_slug,
          hasUserMessage: !!userMessage,
          hasAiResponse: !!aiResponse
        });

        const response = await fetch('/.netlify/functions/selira-save-chat', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            email: user_email,
            auth0_id: auth0_id,
            character_slug: character_slug,
            user_message: userMessage,
            ai_response: aiResponse
          })
        });
        
        if (response.ok) {
          console.log('‚úÖ Chat message saved successfully');
        } else {
          const errorData = await response.text();
          console.log('‚ö†Ô∏è Failed to save chat message:', response.status);
          console.log('‚ùå Error details:', errorData);
          
          // Try to parse error for better debugging
          try {
            const errorJson = JSON.parse(errorData);
            console.log('üîç Parsed error:', errorJson);
          } catch (e) {
            console.log('üîç Raw error response:', errorData.substring(0, 200));
          }
        }
      } catch (error) {
        console.error('‚ùå Error saving chat message:', error);
      }
    }

    // Load character from URL parameter on page load
    function loadCharacterFromURL() {
      const urlParams = new URLSearchParams(window.location.search);
      const characterSlug = urlParams.get('char');
      
      console.log('üîç Checking URL for character:', characterSlug);
      console.log('üì¶ Available characters:', loadedCharacters.map(c => ({ name: c.name, slug: c.slug })));
      
      if (characterSlug && loadedCharacters.length > 0) {
        // Find the character in our loaded data with better matching
        const character = loadedCharacters.find(c => 
          c.slug === characterSlug || 
          c.slug === characterSlug.toLowerCase() ||
          c.name.toLowerCase().replace(/[^a-z0-9]/g, '-') === characterSlug.toLowerCase() ||
          c.name.toLowerCase() === characterSlug.replace(/-/g, ' ').toLowerCase()
        );
        
        if (character) {
          console.log('‚úÖ Found character from URL:', character.name);
          // Load this character without updating URL (we're already on the right URL)
          selectCharacterFromSidebarSilent(character.slug, character.name, fixAvatarUrl(character.avatar), character.title);
        } else {
          console.log('‚ùå Character not found in loaded data, searching API for:', characterSlug);
          console.log('üîç Available slugs:', loadedCharacters.map(c => c.slug));
          // Try to find by fetching specific character from API
          loadSpecificCharacterFromAPI(characterSlug);
        }
      } else if (characterSlug && loadedCharacters.length === 0) {
        console.log('‚è≥ Characters not loaded yet, retrying in 1 second...');
        setTimeout(loadCharacterFromURL, 1000);
      }
    }

    // Load specific character from API if not found in initial data
    async function loadSpecificCharacterFromAPI(characterSlug, retryCount = 0) {
      try {
        console.log('üîÑ Fetching specific character from API:', characterSlug, `(attempt ${retryCount + 1})`);

        // Check if this is a newly created character
        const newCharacterKey = `new_character_${characterSlug}`;
        const isNewCharacter = localStorage.getItem(newCharacterKey);

        if (isNewCharacter && retryCount < 3) {
          console.log('üÜï This is a newly created character, retrying in 2 seconds...');
          setTimeout(() => loadSpecificCharacterFromAPI(characterSlug, retryCount + 1), 2000);
          return;
        }

        const response = await fetch(`/.netlify/functions/characters?slug=${encodeURIComponent(characterSlug)}`);

        if (response.ok) {
          const data = await response.json();
          if (data.success && data.characters && data.characters.length > 0) {
            const character = data.characters[0];
            const processedChar = {
              id: character.Character_ID || character.Name,
              name: character.Name || 'Unknown',
              title: character.Character_Title || '',
              description: character.Character_Description || '',
              avatar: character.Avatar_URL ? character.Avatar_URL.replace('narrin.ai', 'selira.ai') : null,
              category: character.Category || 'Other',
              slug: character.Slug || characterSlug,
              creator: character.Created_by || 'Selira',
              tags: Array.isArray(character.Tags) ? character.Tags.slice(0, 11) : (character.Tags || '').toString().split(',').filter(Boolean).slice(0, 11),
              character_url: character.Character_URL ? character.Character_URL.replace('narrin.ai', 'selira.ai') : null
            };

            console.log('‚úÖ Loaded specific character:', processedChar.name);

            // Clear the new character flag
            if (isNewCharacter) {
              localStorage.removeItem(newCharacterKey);
              console.log('üßπ Cleared new character flag for:', characterSlug);
            }

            selectCharacterFromSidebarSilent(processedChar.slug, processedChar.name, fixAvatarUrl(processedChar.avatar), processedChar.title);
          } else {
            if (isNewCharacter && retryCount < 3) {
              console.log('üîÑ New character not found yet, retrying in 2 seconds...');
              setTimeout(() => loadSpecificCharacterFromAPI(characterSlug, retryCount + 1), 2000);
            } else {
              console.log('‚ùå Character not found in API, using fallback character');
              loadFallbackCharacter();
            }
          }
        } else {
          if (isNewCharacter && retryCount < 3) {
            console.log('üîÑ API error for new character, retrying in 2 seconds...');
            setTimeout(() => loadSpecificCharacterFromAPI(characterSlug, retryCount + 1), 2000);
          } else {
            loadFallbackCharacter();
          }
        }
      } catch (error) {
        console.error('‚ùå Error loading specific character:', error);
        if (isNewCharacter && retryCount < 3) {
          console.log('üîÑ Error loading new character, retrying in 2 seconds...');
          setTimeout(() => loadSpecificCharacterFromAPI(characterSlug, retryCount + 1), 2000);
        } else {
          loadFallbackCharacter();
        }
      }
    }

    // Load fallback character if specific one not found
    function loadFallbackCharacter() {
      if (loadedCharacters.length > 0) {
        const fallbackChar = loadedCharacters[0];
        console.log('üîÑ Loading fallback character:', fallbackChar.name);
        selectCharacterFromSidebarSilent(fallbackChar.slug, fallbackChar.name, fixAvatarUrl(fallbackChar.avatar), fallbackChar.title);
      }
    }

    // Direct character loading from URL - simpler approach
    function loadCharacterDirectly() {
      const urlParams = new URLSearchParams(window.location.search);
      const characterSlug = urlParams.get('char');
      
      if (!characterSlug || loadedCharacters.length === 0) return;
      
      console.log('üéØ Direct loading character:', characterSlug);
      
      // Try exact match first
      let character = loadedCharacters.find(c => c.slug === characterSlug);
      
      // If not found, try case insensitive
      if (!character) {
        character = loadedCharacters.find(c => c.slug && c.slug.toLowerCase() === characterSlug.toLowerCase());
      }
      
      // If still not found, try name-based matching
      if (!character) {
        character = loadedCharacters.find(c => 
          c.name && c.name.toLowerCase().replace(/[^a-z0-9]/g, '-') === characterSlug.toLowerCase()
        );
      }
      
      if (character) {
        console.log('‚úÖ Direct match found:', character.name);
        // Force update the character
        currentCharacter = {
          name: character.name,
          slug: character.slug,
          avatar: fixAvatarUrl(character.avatar),
          creator: '@' + (character.creator || 'Selira'),
          description: character.description || 'An amazing character ready for conversation.',
          chats: character.chats || Math.floor(Math.random() * 100) + 'K',
          rating: character.rating || (Math.random() * 2 + 3).toFixed(1),
          tags: character.tags || ['Character']
        };
        
        updateCharacterDisplay();
        highlightCorrectChatItem(character.slug);
        
        // Load chat history for this character
        loadChatHistoryFromStorage(character.slug);
        
        // Clear only if no history loaded
        setTimeout(() => {
          const hasMessages = document.querySelectorAll('.message:not(.welcome-message)').length > 0;
          if (!hasMessages) {
            clearChat();
          }
        }, 500);
      } else {
        console.log('‚ùå No direct match, using first character');
        loadFallbackCharacter();
      }
    }
    
    // Highlight correct chat item in sidebar
    function highlightCorrectChatItem(targetSlug) {
      document.querySelectorAll('.chat-item').forEach(item => {
        item.classList.remove('active');
        // Check if this item matches the target character
        const onclick = item.getAttribute('onclick') || '';
        if (onclick.includes(targetSlug) || onclick.includes(`'${targetSlug}'`)) {
          item.classList.add('active');
          console.log('‚úÖ Highlighted chat item for:', targetSlug);
        }
      });
    }

    // Request image function - fills input with "Send me a picture "
    function requestImage() {
      // Check if suggestions are already visible
      const suggestionsDiv = document.getElementById('imagePromptSuggestions');

      if (suggestionsDiv && suggestionsDiv.classList.contains('visible')) {
        // Hide suggestions if already showing
        hideImagePromptSuggestions();
      } else {
        // Show suggestions
        showImagePromptSuggestions();
      }
    }


    async function handleImageRequest(message) {
      // Extract the prompt part after "send me a picture"
      const promptPart = message.substring('send me a picture'.length).trim();
      const fullPrompt = promptPart || 'beautiful portrait';
      
      // Add user message
      addMessage(message, 'user');
      
      // Save user message to localStorage
      saveUserMessageToStorage(currentCharacter.slug, message);
      
      // Add loading message
      const loadingId = 'loading-' + Date.now();
      addMessage('üé® Generating your image...', 'ai', loadingId);
      
      try {
        // Detect character style from companion_type field, fallback to Category
        const characterStyle = currentCharacter.companion_type || 
                               (currentCharacter.category === 'anime-manga' ? 'anime' : 'realistic');
        
        console.log('üé® Generating image:', {
          prompt: fullPrompt,
          characterStyle: characterStyle,
          character: currentCharacter.name
        });
        
        // Use character appearance data if available, otherwise fallback
        const characterSex = currentCharacter.sex || 'female';
        const characterEthnicity = currentCharacter.ethnicity || 'white';  
        const characterHairLength = currentCharacter.hair_length || 'medium';
        const characterHairColor = currentCharacter.hair_color || 'brown';
        
        const response = await fetch('/.netlify/functions/generate-custom-image', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            customPrompt: fullPrompt,
            characterName: currentCharacter.name,
            category: currentCharacter.category,
            style: characterStyle,
            shotType: 'fullbody',
            sex: characterSex,
            ethnicity: characterEthnicity,
            hairLength: characterHairLength,
            hairColor: characterHairColor
          })
        });
        
        if (response.ok) {
          const result = await response.json();

          // Remove loading message
          const loadingMsg = document.getElementById(loadingId);
          if (loadingMsg) loadingMsg.remove();

          // Add generated image as AI response
          addImageMessage(result.imageUrl, fullPrompt, characterStyle);

        } else if (response.status === 429) {
          // Rate limited - show specific message
          const error = await response.json();
          const loadingMsg = document.getElementById(loadingId);
          if (loadingMsg) {
            const messageText = loadingMsg.querySelector('.message-text');
            if (messageText) {
              messageText.textContent = `‚è±Ô∏è Please wait a moment before generating another image. Try again in ${error.retryAfter || 2} seconds.`;
            }
          }
        } else {
          const error = await response.json();
          // Replace loading with error
          const loadingMsg = document.getElementById(loadingId);
          if (loadingMsg) {
            const messageText = loadingMsg.querySelector('.message-text');
            if (messageText) {
              messageText.textContent = `‚ùå Sorry, I couldn't generate that image: ${error.error}`;
            }
          }
        }
        
      } catch (error) {
        // Replace loading with error  
        const loadingMsg = document.getElementById(loadingId);
        if (loadingMsg) {
          const messageText = loadingMsg.querySelector('.message-text');
          if (messageText) {
            messageText.textContent = `‚ùå Sorry, there was an error generating your image.`;
          }
        }
      }
    }

    // Save single user message to localStorage
    function saveUserMessageToStorage(characterSlug, userMessage) {
      try {
        const storageKey = `chat_${characterSlug}`;
        let chatHistory = JSON.parse(localStorage.getItem(storageKey) || '[]');
        
        // Add user message
        chatHistory.push({
          type: 'user',
          content: userMessage,
          timestamp: Date.now()
        });
        
        // Keep only last 50 messages
        chatHistory = chatHistory.slice(-50);
        
        localStorage.setItem(storageKey, JSON.stringify(chatHistory));
        console.log('üíæ Saved user message to localStorage:', characterSlug);
        
      } catch (error) {
        console.error('‚ùå Error saving user message to localStorage:', error);
      }
    }

    // Save image message to localStorage
    function saveImageMessageToStorage(characterSlug, imageUrl, prompt, style) {
      try {
        const storageKey = `chat_${characterSlug}`;
        let chatHistory = JSON.parse(localStorage.getItem(storageKey) || '[]');
        
        // Add image message
        chatHistory.push({
          type: 'image',
          content: {
            imageUrl: imageUrl,
            prompt: prompt,
            style: style,
            text: `Here's your ${style} image:`
          },
          timestamp: Date.now()
        });
        
        // Keep only last 50 messages
        chatHistory = chatHistory.slice(-50);
        
        localStorage.setItem(storageKey, JSON.stringify(chatHistory));
        console.log('üíæ Saved image message to localStorage:', characterSlug);
        
      } catch (error) {
        console.error('‚ùå Error saving image message to localStorage:', error);
      }
    }

    function addImageMessage(imageUrl, prompt, style, saveToStorage = true) {
      const messagesContainer = document.getElementById('chatMessages');

      const messageDiv = document.createElement('div');
      messageDiv.className = 'message ai';
      messageDiv.innerHTML = `
        <div class="message-content">
          <div class="message-text" style="margin-left: 0;">
            <div style="margin-bottom: 8px;">Here's your ${style} image:</div>
            <img src="${imageUrl}" alt="Generated image" style="
              max-width: 300px; border-radius: 12px; cursor: pointer;
              box-shadow: 0 4px 16px rgba(0,0,0,0.3);
            " onclick="openImageFullscreen('${imageUrl}', '${prompt}')">
            <div style="margin-top: 4px; font-size: 11px; color: var(--text-muted);">"${prompt}"</div>
          </div>
          <div class="message-time">${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</div>
        </div>
      `;

      messagesContainer.appendChild(messageDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      
      // Save to localStorage if requested
      if (saveToStorage && currentCharacter.slug) {
        saveImageMessageToStorage(currentCharacter.slug, imageUrl, prompt, style);

        // Update sidebar to reflect new activity
        updateActiveChatsSidebar();
      }
    }

    function openImageFullscreen(imageUrl, prompt) {
      const fullscreenModal = document.createElement('div');
      fullscreenModal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.9); z-index: 3000;
        display: flex; align-items: center; justify-content: center;
        backdrop-filter: blur(8px);
      `;
      
      fullscreenModal.innerHTML = `
        <div style="position: relative; max-width: 90vw; max-height: 90vh;">
          <img src="${imageUrl}" alt="Generated image" style="
            max-width: 100%; max-height: 100%; border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
          ">
          <div style="
            position: absolute; bottom: -40px; left: 0; right: 0; text-align: center;
            color: white; font-size: 14px; background: rgba(0,0,0,0.7); 
            padding: 8px; border-radius: 8px;
          ">"${prompt}"</div>
          <button onclick="this.parentElement.parentElement.remove()" style="
            position: absolute; top: -40px; right: 0; background: rgba(255,255,255,0.9); 
            border: none; border-radius: 50%; width: 32px; height: 32px; cursor: pointer;
            display: flex; align-items: center; justify-content: center; font-size: 18px;
          ">&times;</button>
        </div>
      `;
      
      document.body.appendChild(fullscreenModal);
      fullscreenModal.addEventListener('click', (e) => {
        if (e.target === fullscreenModal) fullscreenModal.remove();
      });
    }

    // Action menu functions
    function toggleActionMenu() {
      const menu = document.getElementById('actionMenu');
      const isVisible = menu.style.display !== 'none';
      
      if (isVisible) {
        menu.style.display = 'none';
      } else {
        menu.style.display = 'block';
      }
    }

    function closeActionMenu() {
      const menu = document.getElementById('actionMenu');
      menu.style.display = 'none';
    }

    // Close action menu when clicking outside
    document.addEventListener('click', function(e) {
      const menuContainer = document.querySelector('.action-menu-container');
      const menu = document.getElementById('actionMenu');
      
      if (menuContainer && !menuContainer.contains(e.target) && menu) {
        menu.style.display = 'none';
      }
    });

    // Character info modal function
    function toggleCharacterInfo() {
      // Create or toggle character info modal
      const existingModal = document.getElementById('characterInfoModal');
      if (existingModal) {
        existingModal.remove();
        return;
      }
      
      const modal = document.createElement('div');
      modal.id = 'characterInfoModal';
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.8); z-index: 2000;
        display: flex; align-items: center; justify-content: center;
        backdrop-filter: blur(8px);
      `;
      
      modal.innerHTML = `
        <div style="
          background: var(--bg-secondary); border: 1px solid var(--border);
          border-radius: 16px; padding: 32px; max-width: 500px; margin: 20px;
          position: relative;
        ">
          <button onclick="document.getElementById('characterInfoModal').remove()" style="
            position: absolute; top: 16px; right: 16px; background: none;
            border: none; color: var(--text-secondary); font-size: 24px;
            cursor: pointer; width: 32px; height: 32px; display: flex;
            align-items: center; justify-content: center; border-radius: 50%;
          ">&times;</button>
          
          <div style="display: flex; gap: 20px; margin-bottom: 20px;">
            <img src="${fixAvatarUrl(currentCharacter.avatar)}" style="
              width: 80px; height: 80px; border-radius: 12px; object-fit: cover;
              border: 2px solid var(--accent);
            " onerror="this.style.display='none';">
            <div>
              <h2 style="color: var(--text-primary); margin: 0 0 8px 0; font-family: 'Playfair Display', serif;">${currentCharacter.name}</h2>
              <p style="color: var(--accent); margin: 0 0 8px 0; font-weight: 600;">${currentCharacter.title || 'AI Companion'}</p>
              <p style="color: var(--text-secondary); margin: 0; font-size: 14px;">Created by ${currentCharacter.creator}</p>
            </div>
          </div>
          
          <p style="color: var(--text-secondary); line-height: 1.6; margin: 0;">
            ${currentCharacter.description || 'An amazing AI companion ready for conversation.'}
          </p>
        </div>
      `;
      
      document.body.appendChild(modal);
      modal.addEventListener('click', (e) => {
        if (e.target === modal) modal.remove();
      });
    }

    // ===== MEMORY FUNCTIONS =====
    async function loadMemoriesForContext(characterSlug, auth0Id) {
      try {
        console.log('üß† Loading memories for context:', { characterSlug, auth0Id });

        const user = window.getCurrentUser();
        if (!user?.email) {
          console.log('‚ö†Ô∏è No user email for memory loading');
          return;
        }

        const response = await fetch('/.netlify/functions/memory', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            action: 'get_memories',
            user_email: user.email,
            character_slug: characterSlug,
            user_uid: auth0Id
          })
        });

        if (response.ok) {
          const data = await response.json();
          console.log('‚úÖ Loaded memories:', data.memories?.length || 0);
          // Store memories for AI context
          window.currentMemories = data.memories || [];
        } else {
          console.log('‚ö†Ô∏è Memory loading failed:', response.status);
        }
      } catch (error) {
        console.error('‚ùå Memory loading error:', error);
      }
    }

    async function saveMemoryIfImportant(characterSlug, userMessage, aiResponse, auth0Id) {
      try {
        console.log('üß† Analyzing memory importance...');

        const user = window.getCurrentUser();
        if (!user?.email) {
          console.log('‚ö†Ô∏è No user email for memory saving');
          return;
        }

        const response = await fetch('/.netlify/functions/analyze-memory', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            user_email: user.email,
            character_slug: characterSlug,
            user_message: userMessage,
            ai_response: aiResponse,
            user_uid: auth0Id
          })
        });

        if (response.ok) {
          const data = await response.json();
          console.log('‚úÖ Memory analysis complete:', {
            importance: data.importance,
            saved: data.memory_saved
          });
        } else {
          console.log('‚ö†Ô∏è Memory analysis failed:', response.status);
        }
      } catch (error) {
        console.error('‚ùå Memory saving error:', error);
      }
    }

    console.log('‚úÖ Selira AI Chat interface initialized with modern design');
  </script>
</body>
</html>