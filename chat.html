<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chat with AI Companions | Selira AI</title>
  <meta name="description" content="Engage in meaningful conversations with AI companions. Experience intelligent, empathetic, and personalized interactions.">
  
  <!-- Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-XZXX201WKD"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-XZXX201WKD');
  </script>
  
  <!-- Auth0 Authentication System -->
  <script src="/js/auth0-login.js"></script>
  
  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
  
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500;600;700&family=Nunito:wght@300;400;500;600;700&display=swap');
    
    :root {
      /* Selira dark theme - matching index.html */
      --bg-primary: #0a0a0a;
      --bg-secondary: #1a1a1a;
      --bg-tertiary: #2a2a2a;
      --text-primary: #ffffff;
      --text-secondary: #b3b3b3;
      --text-muted: #888888;
      --accent: #d4a574;
      --accent-hover: #c19456;
      --accent-secondary: #ec4899;
      --border: #333333;
      --success: #10b981;
      --error: #ef4444;
      --radius-sm: 8px;
      --radius-md: 12px;
      --radius-lg: 16px;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Nunito', -apple-system, BlinkMacSystemFont, sans-serif;
      background-color: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.6;
      overflow: hidden;
    }

    /* App Layout */
    .app-container {
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    /* Left Sidebar with Character List */
    .sidebar {
      width: 220px;
      background: var(--bg-secondary);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .sidebar-header {
      padding: 16px;
      border-bottom: 1px solid var(--border);
    }

    .sidebar-logo {
      display: flex;
      align-items: center;
      gap: 8px;
      text-decoration: none;
      margin-bottom: 16px;
    }

    .logo-icon {
      width: 28px;
      height: 28px;
      background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
      border-radius: var(--radius-sm);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 700;
      color: white;
    }

    .logo-text {
      font-family: 'Playfair Display', serif;
      font-size: 18px;
      font-weight: 700;
      color: var(--text-primary);
    }

    .back-btn {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 12px;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      font-weight: 600;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .back-btn:hover {
      background: var(--bg-secondary);
      border-color: var(--accent);
      color: var(--accent);
      text-decoration: none;
    }

    .sidebar-section {
      flex: 1;
      overflow-y: auto;
    }

    .section-header {
      padding: 16px 16px 8px;
      font-size: 10px;
      font-weight: 700;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .chat-list {
      padding: 0 8px;
    }

    .chat-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 8px;
      margin-bottom: 2px;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .chat-item:hover, .chat-item.active {
      background: var(--bg-tertiary);
    }

    .chat-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      overflow: hidden;
      flex-shrink: 0;
    }

    .chat-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .chat-info {
      flex: 1;
      min-width: 0;
    }

    .chat-name {
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 2px;
      font-size: 12px;
    }

    .chat-preview {
      color: var(--text-secondary);
      font-size: 10px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* Main Chat Area */
    .chat-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* Chat Header */
    .chat-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 20px;
      border-bottom: 1px solid var(--border);
      background: var(--bg-secondary);
    }

    .character-info-header {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .character-avatar-header {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      overflow: hidden;
      border: 2px solid var(--accent);
    }

    .character-avatar-header img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .character-name-header {
      font-family: 'Playfair Display', serif;
      font-size: 20px;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 4px;
    }

    .character-status {
      color: var(--text-secondary);
      font-size: 14px;
    }

    .chat-actions {
      display: flex;
      gap: 8px;
    }

    .action-btn {
      width: 40px;
      height: 40px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
    }

    .action-btn:hover {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    /* Right Sidebar Character Details */
    .character-sidebar {
      width: 320px;
      background: var(--bg-secondary);
      border-left: 1px solid var(--border);
      padding: 20px;
      overflow-y: auto;
    }

    .character-profile {
      text-align: center;
      margin-bottom: 30px;
    }

    .character-avatar-large {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      overflow: hidden;
      margin: 0 auto 16px;
      border: 3px solid var(--accent);
    }

    .character-avatar-large img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .character-name-large {
      font-family: 'Playfair Display', serif;
      font-size: 24px;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 8px;
    }

    .character-creator {
      color: var(--accent);
      font-size: 14px;
      margin-bottom: 16px;
    }

    .character-description {
      color: var(--text-secondary);
      font-size: 14px;
      line-height: 1.5;
      margin-bottom: 20px;
    }

    .character-stats {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
    }

    .stat-item {
      text-align: center;
    }

    .stat-number {
      font-size: 18px;
      font-weight: 700;
      color: var(--text-primary);
    }

    .stat-label {
      font-size: 12px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .character-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 20px;
    }

    .character-tag {
      background: rgba(212, 165, 116, 0.2);
      color: var(--accent);
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
    }

    /* Chat Messages */
    .chat-messages {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
      background: var(--bg-primary);
    }

    .welcome-message {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      text-align: center;
      color: var(--text-secondary);
    }

    .welcome-icon {
      font-size: 48px;
      margin-bottom: 16px;
    }

    .welcome-message h3 {
      font-family: 'Playfair Display', serif;
      font-size: 24px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 8px;
    }

    .message-group {
      margin-bottom: 20px;
    }

    .message {
      display: flex;
      gap: 12px;
      margin-bottom: 16px;
      max-width: 80%;
    }

    .message.user {
      flex-direction: row-reverse;
      margin-left: auto;
    }

    .message-avatar {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      overflow: hidden;
      flex-shrink: 0;
    }

    .message-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    /* Typing indicator animation */
    .typing-dots {
      display: flex;
      gap: 4px;
      align-items: center;
      padding: 8px 0;
    }

    .typing-dots span {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-secondary);
      animation: typing 1.4s infinite;
    }

    .typing-dots span:nth-child(2) {
      animation-delay: 0.2s;
    }

    .typing-dots span:nth-child(3) {
      animation-delay: 0.4s;
    }

    @keyframes typing {
      0%, 60%, 100% {
        opacity: 0.3;
        transform: scale(0.8);
      }
      30% {
        opacity: 1;
        transform: scale(1);
      }
    }

    .message-content {
      background: var(--bg-secondary);
      padding: 12px 16px;
      border-radius: 18px;
      color: var(--text-primary);
      line-height: 1.4;
    }

    .message.user .message-content {
      background: var(--accent);
      color: white;
    }

    /* Chat Input */
    .chat-input-container {
      padding: 20px;
      border-top: 1px solid var(--border);
      background: var(--bg-secondary);
    }

    .chat-input-wrapper {
      display: flex;
      gap: 12px;
      align-items: flex-end;
    }

    #messageInput {
      flex: 1;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 12px 16px;
      color: var(--text-primary);
      font-family: inherit;
      font-size: 14px;
      resize: none;
      max-height: 120px;
      overflow-y: auto;
    }

    #messageInput:focus {
      outline: none;
      border-color: var(--accent);
    }

    .send-btn {
      width: 40px;
      height: 40px;
      background: var(--accent);
      border: none;
      border-radius: 50%;
      color: white;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
    }

    .send-btn:hover {
      background: var(--accent-hover);
      transform: scale(1.05);
    }

    .send-btn:disabled {
      background: var(--border);
      cursor: not-allowed;
      transform: none;
    }

    .input-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 8px;
      font-size: 12px;
      color: var(--text-muted);
    }

    /* Character Search Modal */
    .search-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .search-modal.open {
      display: flex;
    }

    .modal-content {
      background: var(--bg-secondary);
      border-radius: var(--radius-lg);
      width: 90vw;
      max-width: 800px;
      max-height: 80vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 20px;
      border-bottom: 1px solid var(--border);
    }

    .modal-header h3 {
      font-family: 'Playfair Display', serif;
      font-size: 20px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .close-btn {
      width: 32px;
      height: 32px;
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 24px;
      cursor: pointer;
      border-radius: var(--radius-sm);
      transition: all 0.2s ease;
    }

    .close-btn:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .search-input-wrapper {
      padding: 20px;
      border-bottom: 1px solid var(--border);
    }

    #characterSearch {
      width: 100%;
      padding: 12px 16px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      color: var(--text-primary);
      font-size: 14px;
    }

    #characterSearch:focus {
      outline: none;
      border-color: var(--accent);
    }

    .character-grid {
      padding: 20px;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 16px;
      max-height: 400px;
      overflow-y: auto;
    }

    .character-option {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 16px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: center;
    }

    .character-option:hover {
      background: var(--bg-secondary);
      border-color: var(--accent);
      transform: translateY(-2px);
    }

    .character-option-avatar {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      overflow: hidden;
      border: 2px solid var(--accent);
    }

    .character-option-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .character-option-name {
      font-weight: 600;
      color: var(--text-primary);
      font-size: 14px;
    }

    .character-option-role {
      color: var(--text-secondary);
      font-size: 12px;
    }

    /* Mobile Responsive */
    @media (max-width: 768px) {
      .sidebar {
        position: fixed;
        left: -220px;
        z-index: 100;
        transition: left 0.3s ease;
      }

      .sidebar.open {
        left: 0;
      }

      .chat-main {
        margin-left: 0;
      }

      .character-sidebar {
        display: none;
      }

      .chat-header {
        padding-left: 60px;
      }

      .mobile-menu-btn {
        position: absolute;
        left: 20px;
        top: 50%;
        transform: translateY(-50%);
        background: none;
        border: none;
        color: var(--text-primary);
        font-size: 20px;
        cursor: pointer;
      }
    }

    /* Hide character sidebar on medium screens */
    @media (max-width: 1200px) {
      .character-sidebar {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div class="app-container">
    <!-- Left Sidebar with Character List -->
    <aside class="sidebar" id="sidebar">
      <!-- Sidebar Header -->
      <div class="sidebar-header">
        <a href="/" class="sidebar-logo">
          <span class="logo-text">Selira</span>
        </a>
        <a href="/category" class="back-btn" title="Back to Characters">
          <span class="btn-icon">←</span>
          <span>Back</span>
        </a>
      </div>

      <!-- Recent Chats -->
      <div class="sidebar-section">
        <div class="section-header">
          <span>Today</span>
        </div>
        <div class="chat-list" id="chatList">
          <!-- Chat items will be populated dynamically from Airtable -->
          <div class="loading-chats" style="text-align: center; padding: 20px; color: var(--text-secondary); font-size: 14px;">
            <div style="margin-bottom: 8px;">🔄</div>
            Loading characters...
          </div>
        </div>
      </div>
    </aside>

    <!-- Main Chat Area -->
    <main class="chat-main">
      <!-- Mobile Menu Button -->
      <button class="mobile-menu-btn" onclick="toggleSidebar()" style="display: none;">☰</button>

      <!-- Chat Header -->
      <header class="chat-header" id="chatHeader">
        <div class="character-info-header">
          <div class="character-avatar-header" id="currentCharacterAvatar">
            <img src="/avatars/placeholder.webp" alt="Character" id="characterImage" onerror="this.style.display='none';">
          </div>
          <div class="character-details">
            <h2 class="character-name-header" id="currentCharacterName">Loading...</h2>
            <p class="character-status" id="currentCharacterStatus">@Selira</p>
          </div>
        </div>
        <div class="chat-actions">
          <button class="action-btn" onclick="showCharacterSearch()" title="Switch Character">
            <span>👥</span>
          </button>
          <button class="action-btn" onclick="clearChat()" title="Clear Chat">
            <span>🗑️</span>
          </button>
        </div>
      </header>

      <!-- Chat Messages Area -->
      <div class="chat-messages" id="chatMessages">
        <div class="welcome-message" style="text-align: center; padding: 40px 20px; color: var(--text-secondary);">
          <div style="font-size: 48px; margin-bottom: 16px;">💭</div>
          <h3 style="color: var(--text-primary); margin-bottom: 8px;">Chat Cleared</h3>
          <p>Start a new conversation!</p>
        </div>
      </div>

      <!-- Chat Input -->
      <div class="chat-input-container" id="chatInputContainer">
        <div class="chat-input-wrapper">
          <textarea 
            id="messageInput" 
            placeholder="Enter a message. Ex) Hello?" 
            rows="1"
            maxlength="2000"
          ></textarea>
          <button class="send-btn" id="sendBtn" onclick="sendMessage()">
            <span>➤</span>
          </button>
        </div>
        <div class="input-footer">
          <span class="character-count" id="characterCount">0/2000</span>
          <span class="input-hint">Everything AI says is made up! Please follow your local laws and don't talk about underage content.</span>
        </div>
      </div>
    </main>

    <!-- Right Sidebar Character Details -->
    <aside class="character-sidebar" id="characterSidebar">
      <div class="character-profile">
        <div class="character-avatar-large">
          <img src="/avatars/placeholder.webp" alt="Character" id="sidebarCharacterImage" onerror="this.style.display='none';">
        </div>
        <h3 class="character-name-large" id="sidebarCharacterName">Loading...</h3>
        <p class="character-creator" id="sidebarCharacterCreator">@Selira</p>
        <p class="character-description" id="sidebarCharacterDescription">
          Loading character information...
        </p>
        
        <div class="character-stats">
          <div class="stat-item">
            <div class="stat-number" id="sidebarCharacterChats">51.4K</div>
            <div class="stat-label">Chats</div>
          </div>
          <div class="stat-item">
            <div class="stat-number" id="sidebarCharacterRating">4.7</div>
            <div class="stat-label">Rating</div>
          </div>
        </div>
        
        <div class="character-tags" id="sidebarCharacterTags">
          <span class="character-tag">Unfiltered</span>
          <span class="character-tag">Anime</span>
          <span class="character-tag">Wholesome</span>
          <span class="character-tag">Animal</span>
          <span class="character-tag">Femboy</span>
          <span class="character-tag">MILF</span>
          <span class="character-tag">Action</span>
          <span class="character-tag">Sci-Fi</span>
          <span class="character-tag">VTuber</span>
          <span class="character-tag">Fantasy</span>
          <span class="character-tag">Female</span>
        </div>
      </div>
    </aside>

    <!-- Character Search Modal -->
    <div class="search-modal" id="searchModal">
      <div class="modal-content">
        <div class="modal-header">
          <h3>Choose a Character</h3>
          <button class="close-btn" onclick="closeCharacterSearch()">×</button>
        </div>
        <div class="search-input-wrapper">
          <input type="text" id="characterSearch" placeholder="Search characters...">
        </div>
        <div class="character-grid" id="characterGrid">
          <!-- Sample characters -->
          <div class="character-option" onclick="selectCharacter('aragorn')">
            <div class="character-option-avatar">
              <img src="https://selira.ai/avatars/aragorn-1750067445.webp" alt="Aragorn">
            </div>
            <div class="character-option-name">Aragorn</div>
            <div class="character-option-role">Ranger King</div>
          </div>
          <div class="character-option" onclick="selectCharacter('harry-potter')">
            <div class="character-option-avatar">
              <img src="https://selira.ai/avatars/harry-potter-1750067058.webp" alt="Harry Potter">
            </div>
            <div class="character-option-name">Harry Potter</div>
            <div class="character-option-role">The Boy Who Lived</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Global variables - current character will be loaded from URL
    let currentCharacter = {
      name: 'Loading...',
      slug: 'loading',
      avatar: '/avatars/placeholder.webp',
      creator: '@Selira',
      description: 'Loading character information...',
      chats: '0',
      rating: '0.0',
      tags: ['Loading']
    };

    let chatHistory = [];
    let loadedCharacters = [];

    // Avatar URL correction function
    function fixAvatarUrl(avatarUrl) {
      if (!avatarUrl || avatarUrl === '/avatars/placeholder.webp') {
        return '/avatars/placeholder.webp';
      }
      
      // Fix common naming mismatches
      const avatarMappings = {
        '/avatars/emily.webp': '/avatars/emily-1754251534076.webp',
        '/avatars/aiko.webp': '/avatars/aiko-1754252402847.webp'
      };
      
      if (avatarMappings[avatarUrl]) {
        console.log(`🔧 Fixed avatar URL: ${avatarUrl} -> ${avatarMappings[avatarUrl]}`);
        return avatarMappings[avatarUrl];
      }
      
      return avatarUrl;
    }

    // Initialize chat interface
    document.addEventListener('DOMContentLoaded', function() {
      console.log('🚀 Selira AI Chat interface loading...');
      loadCharactersFromDatabase();
      initializeChatInterface();
      setupEventListeners();
      // Character from URL will be loaded after characters are fetched in loadCharactersFromDatabase
    });

    function initializeChatInterface() {
      // Set up character info
      updateCharacterDisplay();
      
      // Auto-resize textarea
      const messageInput = document.getElementById('messageInput');
      if (messageInput) {
        messageInput.addEventListener('input', autoResizeTextarea);
        messageInput.addEventListener('keydown', handleKeyDown);
      }
    }

    function setupEventListeners() {
      // Character count update
      const messageInput = document.getElementById('messageInput');
      const characterCount = document.getElementById('characterCount');
      
      if (messageInput && characterCount) {
        messageInput.addEventListener('input', function() {
          characterCount.textContent = `${this.value.length}/2000`;
        });
      }
    }

    function autoResizeTextarea() {
      const textarea = document.getElementById('messageInput');
      textarea.style.height = 'auto';
      textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
    }

    function handleKeyDown(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    }

    function updateCharacterDisplay() {
      // Update header
      document.getElementById('currentCharacterName').textContent = currentCharacter.name;
      document.getElementById('currentCharacterStatus').textContent = currentCharacter.creator;
      const headerImage = document.getElementById('characterImage');
      if (currentCharacter.avatar && currentCharacter.avatar !== '/avatars/placeholder.webp') {
        headerImage.src = fixAvatarUrl(currentCharacter.avatar);
        headerImage.style.display = 'block';
        headerImage.onerror = function() { this.style.display = 'none'; };
      } else {
        headerImage.style.display = 'none';
      }
      
      // Update sidebar
      document.getElementById('sidebarCharacterName').textContent = currentCharacter.name;
      document.getElementById('sidebarCharacterCreator').textContent = currentCharacter.creator;
      document.getElementById('sidebarCharacterDescription').textContent = currentCharacter.description;
      const sidebarImage = document.getElementById('sidebarCharacterImage');
      if (currentCharacter.avatar && currentCharacter.avatar !== '/avatars/placeholder.webp') {
        sidebarImage.src = fixAvatarUrl(currentCharacter.avatar);
        sidebarImage.style.display = 'block';
        sidebarImage.onerror = function() { this.style.display = 'none'; };
      } else {
        sidebarImage.style.display = 'none';
      }
      document.getElementById('sidebarCharacterChats').textContent = currentCharacter.chats;
      document.getElementById('sidebarCharacterRating').textContent = currentCharacter.rating;
      
      // Update tags
      const tagsContainer = document.getElementById('sidebarCharacterTags');
      if (tagsContainer && currentCharacter.tags) {
        tagsContainer.innerHTML = currentCharacter.tags.map(tag => 
          `<span class="character-tag">${tag}</span>`
        ).join('');
      }
    }

    function showCharacterSearch() {
      document.getElementById('searchModal').classList.add('open');
      document.getElementById('characterSearch').focus();
    }

    function closeCharacterSearch() {
      document.getElementById('searchModal').classList.remove('open');
    }

    function selectCharacter(slug) {
      // Update character based on selection
      // This would normally fetch from API
      console.log('Selected character:', slug);
      closeCharacterSearch();
    }

    async function sendMessage() {
      const messageInput = document.getElementById('messageInput');
      const message = messageInput.value.trim();
      
      if (!message) return;
      
      // Add user message
      addMessage(message, 'user');
      messageInput.value = '';
      autoResizeTextarea();
      
      // User message will be saved together with AI response
      
      // Show typing indicator
      const typingIndicator = addTypingIndicator();
      
      try {
        // Get user data for API call - handle both authenticated and anonymous users
        let auth0_id = 'anonymous';
        try {
          const user = JSON.parse(localStorage.getItem('user') || '{}');
          auth0_id = user.sub || user.auth0_id || user.email || 'anonymous';
        } catch (e) {
          // If no user data, use anonymous
          auth0_id = 'anonymous';
        }
        
        // Get chat history for context
        const chatHistory = getChatHistoryForContext(currentCharacter.slug);
        
        // Call OpenRouter chat API
        console.log('🤖 Sending message to AI:', { 
          character: currentCharacter.slug, 
          auth0_id: auth0_id,
          message: message.substring(0, 50) + '...',
          history_length: chatHistory.length
        });
        
        const response = await fetch('/.netlify/functions/openrouter-chat', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            message: message,
            character_slug: currentCharacter.slug,
            auth0_id: auth0_id,
            model: 'mistralai/mistral-nemo',
            local_history: chatHistory // Send localStorage history for context
          })
        });
        
        if (!response.ok) {
          throw new Error(`API Error: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('✅ Received AI response:', data.response?.substring(0, 100) + '...');
        console.log('🤖 Model used:', data.model_used);
        console.log('💾 Saved to DB:', data.saved_to_db);
        
        // Remove typing indicator
        typingIndicator.remove();
        
        // Add AI response (clean, without debug info)
        const responseText = data.response || "I'm having trouble responding right now. Please try again!";
        addMessage(responseText, 'ai');
        
        // Save both user and AI message to localStorage
        saveBothMessagesToStorage(currentCharacter.slug, message, data.response);
        
        // Save conversation to Airtable (async)
        saveChatMessage(auth0_id, currentCharacter.slug, message, data.response);
        
      } catch (error) {
        console.error('❌ Error sending message:', error);
        
        // Remove typing indicator
        if (typingIndicator && typingIndicator.parentNode) {
          typingIndicator.remove();
        }
        
        // Add error message with more detail
        addMessage(`I'm having trouble connecting right now (${error.message}). Please try again in a moment!`, 'ai');
      }
    }

    // Debug function to test OpenRouter API
    async function testOpenRouterAPI() {
      try {
        const response = await fetch('/.netlify/functions/openrouter-chat', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            message: 'Hello, how are you?',
            character_slug: 'test',
            auth0_id: 'test-user',
            model: 'mistralai/mistral-nemo'
          })
        });
        
        console.log('🧪 Test API Response Status:', response.status);
        const data = await response.text();
        console.log('🧪 Test API Response:', data);
        
      } catch (error) {
        console.error('🧪 Test API Error:', error);
      }
    }

    // Auto-test API on load (remove later)
    setTimeout(testOpenRouterAPI, 2000);

    // Load chat history for current character
    async function loadChatHistory(characterSlug) {
      try {
        const user = JSON.parse(localStorage.getItem('user') || '{}');
        const auth0_id = user.sub || user.auth0_id || user.email || 'anonymous';
        
        // Skip for anonymous users
        if (auth0_id === 'anonymous') {
          console.log('👤 Anonymous user - no chat history to load');
          return;
        }
        
        console.log('📚 Loading chat history for:', characterSlug);
        
        const response = await fetch('/.netlify/functions/get-chat-history-selira', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            auth0_id: auth0_id,
            character_slug: characterSlug,
            limit: 20
          })
        });
        
        if (response.ok) {
          const data = await response.json();
          if (data.success && data.messages && data.messages.length > 0) {
            console.log('✅ Loaded', data.messages.length, 'previous messages');
            displayChatHistory(data.messages);
          } else {
            console.log('💭 No previous chat history found');
          }
        } else {
          console.log('⚠️ Failed to load chat history:', response.status);
        }
        
      } catch (error) {
        console.error('❌ Error loading chat history:', error);
      }
    }

    // Display loaded chat history
    function displayChatHistory(messages) {
      const messagesContainer = document.getElementById('chatMessages');
      
      // Clear existing messages
      messagesContainer.innerHTML = '';
      
      messages.forEach(msg => {
        const sender = msg.MessageType === 'user' ? 'user' : 'ai';
        addMessage(msg.Content, sender, false); // false = don't scroll to bottom yet
      });
      
      // Scroll to bottom after all messages loaded
      setTimeout(() => {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }, 100);
    }

    // Save both messages to localStorage (prevents duplicates)
    function saveBothMessagesToStorage(characterSlug, userMessage, aiResponse) {
      try {
        const storageKey = `chat_${characterSlug}`;
        let chatHistory = JSON.parse(localStorage.getItem(storageKey) || '[]');
        
        // Add user message
        chatHistory.push({
          type: 'user',
          content: userMessage,
          timestamp: Date.now()
        });
        
        // Add AI response 
        chatHistory.push({
          type: 'ai', 
          content: aiResponse,
          timestamp: Date.now() + 1 // Slightly after user message
        });
        
        // Keep only last 50 messages
        chatHistory = chatHistory.slice(-50);
        
        localStorage.setItem(storageKey, JSON.stringify(chatHistory));
        console.log('💾 Saved conversation to localStorage:', characterSlug, chatHistory.length, 'messages');
        
      } catch (error) {
        console.error('❌ Error saving to localStorage:', error);
      }
    }

    // Save chat to localStorage for persistence (legacy function - use saveBothMessagesToStorage)
    function saveChatToStorage(characterSlug, userMessage, aiResponse) {
      // This function is kept for compatibility but shouldn't create duplicates
      console.log('⚠️ Legacy save function called - use saveBothMessagesToStorage instead');
    }

    // Load chat history from localStorage
    function loadChatHistoryFromStorage(characterSlug) {
      try {
        // Clean up duplicates first
        const chatHistory = cleanupChatHistory(characterSlug);
        
        if (chatHistory.length > 0) {
          console.log('📚 Loading', chatHistory.length, 'clean messages from localStorage for:', characterSlug);
          console.log('📦 First message preview:', chatHistory[0]);
          
          const messagesContainer = document.getElementById('chatMessages');
          messagesContainer.innerHTML = '';
          
          chatHistory.forEach(msg => {
            addMessage(msg.content, msg.type, false);
          });
          
          setTimeout(() => {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
          }, 100);
          
        } else {
          console.log('💭 No chat history in localStorage for:', characterSlug);
          console.log('🔍 Checking localStorage keys:', Object.keys(localStorage).filter(k => k.startsWith('chat_')));
        }
        
      } catch (error) {
        console.error('❌ Error loading from localStorage:', error);
      }
    }

    // Get chat history for AI context (last 10 messages)
    function getChatHistoryForContext(characterSlug) {
      try {
        // Get cleaned history
        const fullHistory = cleanupChatHistory(characterSlug);
        
        // Get last 10 messages for context (exclude current message being sent)
        const contextHistory = fullHistory.slice(-10).map(msg => ({
          role: msg.type === 'user' ? 'user' : 'assistant',
          content: msg.content
        }));
        
        console.log('🧠 Sending context history:', contextHistory.length, 'messages');
        return contextHistory;
        
      } catch (error) {
        console.error('❌ Error getting context history:', error);
        return [];
      }
    }

    function addMessage(content, sender, autoScroll = true) {
      const messagesContainer = document.getElementById('chatMessages');
      const welcomeMessage = messagesContainer.querySelector('.welcome-message');
      
      if (welcomeMessage) {
        welcomeMessage.remove();
      }
      
      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${sender}`;
      
      if (sender === 'ai') {
        messageDiv.innerHTML = `
          <div class="message-avatar">
            <img src="${fixAvatarUrl(currentCharacter.avatar)}" alt="${currentCharacter.name}" onerror="this.style.display='none'">
          </div>
          <div class="message-content">${content}</div>
        `;
      } else {
        messageDiv.innerHTML = `
          <div class="message-content">${content}</div>
        `;
      }
      
      messagesContainer.appendChild(messageDiv);
      
      if (autoScroll) {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }
    }

    function clearChat() {
      // Clear chat from UI
      const messagesContainer = document.getElementById('chatMessages');
      messagesContainer.innerHTML = `
        <div class="welcome-message" style="text-align: center; padding: 40px 20px; color: var(--text-secondary);">
          <div style="font-size: 48px; margin-bottom: 16px;">💭</div>
          <h3 style="color: var(--text-primary); margin-bottom: 8px;">Chat Cleared</h3>
          <p>Start a new conversation with ${currentCharacter.name}!</p>
        </div>
      `;
      
      // Clear chat history from localStorage
      if (currentCharacter.slug) {
        const storageKey = `chat_${currentCharacter.slug}`;
        localStorage.removeItem(storageKey);
        console.log('🗑️ Cleared chat history for:', currentCharacter.slug);
      }
    }

    // Clean up duplicate messages in localStorage
    function cleanupChatHistory(characterSlug) {
      try {
        const storageKey = `chat_${characterSlug}`;
        const rawHistory = JSON.parse(localStorage.getItem(storageKey) || '[]');
        
        // Remove consecutive duplicates
        const cleanHistory = [];
        let lastMessage = null;
        
        rawHistory.forEach(msg => {
          if (!lastMessage || 
              lastMessage.content !== msg.content || 
              lastMessage.type !== msg.type) {
            cleanHistory.push(msg);
            lastMessage = msg;
          }
        });
        
        if (cleanHistory.length !== rawHistory.length) {
          localStorage.setItem(storageKey, JSON.stringify(cleanHistory));
          console.log('🧹 Cleaned chat history:', rawHistory.length, '→', cleanHistory.length);
        }
        
        return cleanHistory;
        
      } catch (error) {
        console.error('❌ Error cleaning chat history:', error);
        return [];
      }
    }

    function toggleSidebar() {
      const sidebar = document.getElementById('sidebar');
      sidebar.classList.toggle('open');
    }

    // Close sidebar when clicking outside on mobile
    document.addEventListener('click', function(e) {
      const sidebar = document.getElementById('sidebar');
      const mobileBtn = document.querySelector('.mobile-menu-btn');
      
      if (window.innerWidth <= 768 && 
          !sidebar.contains(e.target) && 
          !mobileBtn.contains(e.target) && 
          sidebar.classList.contains('open')) {
        sidebar.classList.remove('open');
      }
    });

    // Handle responsive design
    function handleResize() {
      const isMobile = window.innerWidth <= 768;
      const mobileBtn = document.querySelector('.mobile-menu-btn');
      
      if (mobileBtn) {
        mobileBtn.style.display = isMobile ? 'block' : 'none';
      }
    }

    window.addEventListener('resize', handleResize);
    document.addEventListener('DOMContentLoaded', handleResize);

    // ===== DATABASE INTEGRATION =====
    async function loadCharactersFromDatabase() {
      try {
        console.log('📡 Loading characters from database...');
        const response = await fetch('/.netlify/functions/characters');
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.success && data.characters) {
          const characters = data.characters.slice(0, 10).map(char => ({
            id: char.Character_ID || char.Name,
            name: char.Name || 'Unknown',
            title: char.Character_Title || '',
            description: char.Character_Description || '',
            avatar: char.Avatar_URL ? char.Avatar_URL.replace('narrin.ai', 'selira.ai') : null,
            category: char.Category || 'Other',
            slug: char.Slug || (char.Name ? char.Name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '') : 'unknown'),
            creator: char.Nickname || 'Selira',
            tags: Array.isArray(char.Tags) ? char.Tags.slice(0, 11) : (char.Tags || '').toString().split(',').filter(Boolean).slice(0, 11), // Get real tags
            character_url: char.Character_URL ? char.Character_URL.replace('narrin.ai', 'selira.ai') : null
          }));
          
          // Store characters globally
          loadedCharacters = characters;
          
          // Update character search modal with real characters
          updateCharacterSearchModal(characters);
          
          // Update recent chats sidebar with some characters
          updateRecentChatsSidebar(characters.slice(0, 5));
          
          console.log('✅ Loaded characters from database:', characters.length);
          
          // Now load character from URL parameter
          loadCharacterFromURL();
          
          // Also try to load a specific character directly from URL if available
          loadCharacterDirectly();
        }
      } catch (error) {
        console.error('❌ Error loading characters:', error);
        // Keep demo data as fallback
      }
    }

    function updateCharacterSearchModal(characters) {
      const characterGrid = document.getElementById('characterGrid');
      if (!characterGrid) return;
      
      characterGrid.innerHTML = characters.map(character => `
        <div class="character-option" onclick="selectCharacter('${character.slug}', '${character.name}', '${fixAvatarUrl(character.avatar)}', '${character.title}')">
          <div class="character-option-avatar">
            <img src="${fixAvatarUrl(character.avatar)}" alt="${character.name}" onerror="this.style.display='none'">
          </div>
          <div class="character-option-name">${character.name}</div>
          <div class="character-option-role">${character.title}</div>
        </div>
      `).join('');
    }

    function updateRecentChatsSidebar(characters) {
      const chatList = document.getElementById('chatList');
      if (!chatList) return;
      
      chatList.innerHTML = characters.map((character, index) => `
        <div class="chat-item ${index === 0 ? 'active' : ''}" onclick="selectCharacterFromSidebar('${character.slug}', '${character.name}', '${fixAvatarUrl(character.avatar)}', '${character.title}')">
          <div class="chat-avatar">
            <img src="${fixAvatarUrl(character.avatar)}" alt="${character.name}" onerror="this.style.display='none'">
          </div>
          <div class="chat-info">
            <div class="chat-name">${character.name}</div>
            <div class="chat-preview">${character.description.substring(0, 30)}...</div>
          </div>
        </div>
      `).join('');
    }

    function selectCharacterFromSidebar(slug, name, avatar, title) {
      // Find character in loaded data for real tags and creator
      const character = loadedCharacters.find(c => c.slug === slug) || {};
      
      // Update current character
      currentCharacter = {
        name: name,
        slug: slug,
        avatar: fixAvatarUrl(avatar),
        creator: '@' + (character.creator || 'Selira'),
        description: character.description || 'Start a conversation with ' + name,
        chats: Math.floor(Math.random() * 100) + 'K',
        rating: (Math.random() * 2 + 3).toFixed(1),
        tags: character.tags || ['Fantasy', 'Adventure', 'Hero']
      };
      
      updateCharacterDisplay();
      
      // Update active chat item
      document.querySelectorAll('.chat-item').forEach(item => {
        item.classList.remove('active');
      });
      event.currentTarget.classList.add('active');
      
      // Update URL to reflect new character
      updateUrlForCharacter(slug);
      
      // Load chat history for this character
      loadChatHistoryFromStorage(slug);
      
      // Only clear if no history was loaded
      setTimeout(() => {
        const hasMessages = document.querySelectorAll('.message:not(.welcome-message)').length > 0;
        if (!hasMessages) {
          clearChat();
        }
      }, 100);
    }

    function selectCharacter(slug, name, avatar, title) {
      // Update character and close modal
      currentCharacter = {
        name: name,
        slug: slug,
        avatar: fixAvatarUrl(avatar),
        creator: '@Selira',
        description: 'Start a conversation with ' + name,
        chats: Math.floor(Math.random() * 100) + 'K',
        rating: (Math.random() * 2 + 3).toFixed(1),
        tags: ['Fantasy', 'Adventure', 'Hero']
      };
      
      updateCharacterDisplay();
      
      // Update URL to reflect new character
      updateUrlForCharacter(slug);
      
      closeCharacterSearch();
      
      // Load chat history for this character
      loadChatHistoryFromStorage(slug);
      
      // Only clear if no history was loaded
      setTimeout(() => {
        const hasMessages = document.querySelectorAll('.message:not(.welcome-message)').length > 0;
        if (!hasMessages) {
          clearChat();
        }
      }, 100);
    }

    // Update URL when switching characters
    function updateUrlForCharacter(characterSlug) {
      if (!characterSlug) return;
      
      // Find the character data to get the proper URL
      const character = loadedCharacters.find(c => c.slug === characterSlug);
      let newUrl;
      
      if (character && character.character_url) {
        // Use the character's specific URL from Airtable
        newUrl = character.character_url;
      } else {
        // Fallback to standard format
        newUrl = `https://selira.ai/chat.html?char=${encodeURIComponent(characterSlug)}`;
      }
      
      // Update the URL without reloading the page
      const currentUrl = window.location.href;
      if (currentUrl !== newUrl) {
        console.log('🔄 Updating URL for character:', characterSlug, '→', newUrl);
        window.history.pushState({character: characterSlug}, '', newUrl);
      }
    }

    // Handle browser back/forward buttons
    window.addEventListener('popstate', function(event) {
      if (event.state && event.state.character) {
        console.log('↩️ Browser navigation to character:', event.state.character);
        // Find the character and switch to it without updating URL again
        const character = loadedCharacters.find(c => c.slug === event.state.character);
        if (character) {
          // Switch character but skip URL update to avoid loop
          selectCharacterFromSidebarSilent(character.slug, character.name, fixAvatarUrl(character.avatar), character.title);
        }
      }
    });

    // Switch character without updating URL (for browser navigation)
    function selectCharacterFromSidebarSilent(slug, name, avatar, title) {
      // Find character in loaded data for real tags and creator
      const character = loadedCharacters.find(c => c.slug === slug) || {};
      
      // Update current character
      currentCharacter = {
        name: name,
        slug: slug,
        avatar: fixAvatarUrl(avatar),
        creator: '@' + (character.creator || 'Selira'),
        description: character.description || 'Start a conversation with ' + name,
        chats: Math.floor(Math.random() * 100) + 'K',
        rating: (Math.random() * 2 + 3).toFixed(1),
        tags: character.tags || ['Fantasy', 'Adventure', 'Hero']
      };
      
      updateCharacterDisplay();
      
      // Update active chat item
      document.querySelectorAll('.chat-item').forEach(item => {
        item.classList.remove('active');
      });
      // Find and highlight the correct chat item
      const chatItems = document.querySelectorAll('.chat-item');
      chatItems.forEach(item => {
        if (item.onclick && item.onclick.toString().includes(slug)) {
          item.classList.add('active');
        }
      });
      
      // Load chat history for this character instead of clearing
      loadChatHistoryFromStorage(slug);
      
      // Only show welcome message if no history exists
      setTimeout(() => {
        const hasMessages = document.querySelectorAll('.message:not(.welcome-message)').length > 0;
        if (!hasMessages) {
          showWelcomeMessage();
        }
      }, 100);
    }

    // Show welcome message without clearing localStorage
    function showWelcomeMessage() {
      const messagesContainer = document.getElementById('chatMessages');
      messagesContainer.innerHTML = `
        <div class="welcome-message" style="text-align: center; padding: 40px 20px; color: var(--text-secondary);">
          <div style="font-size: 48px; margin-bottom: 16px;">💭</div>
          <h3 style="color: var(--text-primary); margin-bottom: 8px;">Start Conversation</h3>
          <p>Begin chatting with ${currentCharacter.name}!</p>
        </div>
      `;
    }

    // Add typing indicator
    function addTypingIndicator() {
      const messagesContainer = document.getElementById('chatMessages');
      const typingDiv = document.createElement('div');
      typingDiv.className = 'message ai typing-indicator';
      typingDiv.innerHTML = `
        <div class="message-avatar">
          <img src="${fixAvatarUrl(currentCharacter.avatar)}" alt="${currentCharacter.name}" onerror="this.style.display='none'">
        </div>
        <div class="message-content">
          <div class="typing-dots">
            <span></span><span></span><span></span>
          </div>
        </div>
      `;
      
      messagesContainer.appendChild(typingDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      return typingDiv;
    }

    // Save chat message to Airtable
    async function saveChatMessage(auth0_id, character_slug, userMessage, aiResponse) {
      try {
        // Skip saving for anonymous users
        if (auth0_id === 'anonymous') {
          console.log('👤 Anonymous user - skipping chat save');
          return;
        }
        
        const response = await fetch('/.netlify/functions/save-chat-message', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            user_email: auth0_id, // Use auth0_id as email for now
            user_uid: auth0_id,
            char: character_slug,
            user_message: userMessage,
            ai_response: aiResponse
          })
        });
        
        if (response.ok) {
          console.log('✅ Chat message saved successfully');
        } else {
          console.log('⚠️ Failed to save chat message:', response.status);
        }
      } catch (error) {
        console.error('❌ Error saving chat message:', error);
      }
    }

    // Load character from URL parameter on page load
    function loadCharacterFromURL() {
      const urlParams = new URLSearchParams(window.location.search);
      const characterSlug = urlParams.get('char');
      
      console.log('🔍 Checking URL for character:', characterSlug);
      console.log('📦 Available characters:', loadedCharacters.map(c => ({ name: c.name, slug: c.slug })));
      
      if (characterSlug && loadedCharacters.length > 0) {
        // Find the character in our loaded data with better matching
        const character = loadedCharacters.find(c => 
          c.slug === characterSlug || 
          c.slug === characterSlug.toLowerCase() ||
          c.name.toLowerCase().replace(/[^a-z0-9]/g, '-') === characterSlug.toLowerCase() ||
          c.name.toLowerCase() === characterSlug.replace(/-/g, ' ').toLowerCase()
        );
        
        if (character) {
          console.log('✅ Found character from URL:', character.name);
          // Load this character without updating URL (we're already on the right URL)
          selectCharacterFromSidebarSilent(character.slug, character.name, fixAvatarUrl(character.avatar), character.title);
        } else {
          console.log('❌ Character not found in loaded data, searching API for:', characterSlug);
          console.log('🔍 Available slugs:', loadedCharacters.map(c => c.slug));
          // Try to find by fetching specific character from API
          loadSpecificCharacterFromAPI(characterSlug);
        }
      } else if (characterSlug && loadedCharacters.length === 0) {
        console.log('⏳ Characters not loaded yet, retrying in 1 second...');
        setTimeout(loadCharacterFromURL, 1000);
      }
    }

    // Load specific character from API if not found in initial data
    async function loadSpecificCharacterFromAPI(characterSlug) {
      try {
        console.log('🔄 Fetching specific character from API:', characterSlug);
        const response = await fetch(`/.netlify/functions/characters?slug=${encodeURIComponent(characterSlug)}`);
        
        if (response.ok) {
          const data = await response.json();
          if (data.success && data.characters && data.characters.length > 0) {
            const character = data.characters[0];
            const processedChar = {
              id: character.Character_ID || character.Name,
              name: character.Name || 'Unknown',
              title: character.Character_Title || '',
              description: character.Character_Description || '',
              avatar: character.Avatar_URL ? character.Avatar_URL.replace('narrin.ai', 'selira.ai') : null,
              category: character.Category || 'Other',
              slug: character.Slug || characterSlug,
              creator: character.Created_by || 'Selira',
              tags: Array.isArray(character.Tags) ? character.Tags.slice(0, 11) : (character.Tags || '').toString().split(',').filter(Boolean).slice(0, 11),
              character_url: character.Character_URL ? character.Character_URL.replace('narrin.ai', 'selira.ai') : null
            };
            
            console.log('✅ Loaded specific character:', processedChar.name);
            selectCharacterFromSidebarSilent(processedChar.slug, processedChar.name, fixAvatarUrl(processedChar.avatar), processedChar.title);
          } else {
            console.log('❌ Character not found in API, using fallback character');
            loadFallbackCharacter();
          }
        }
      } catch (error) {
        console.error('❌ Error loading specific character:', error);
        loadFallbackCharacter();
      }
    }

    // Load fallback character if specific one not found
    function loadFallbackCharacter() {
      if (loadedCharacters.length > 0) {
        const fallbackChar = loadedCharacters[0];
        console.log('🔄 Loading fallback character:', fallbackChar.name);
        selectCharacterFromSidebarSilent(fallbackChar.slug, fallbackChar.name, fixAvatarUrl(fallbackChar.avatar), fallbackChar.title);
      }
    }

    // Direct character loading from URL - simpler approach
    function loadCharacterDirectly() {
      const urlParams = new URLSearchParams(window.location.search);
      const characterSlug = urlParams.get('char');
      
      if (!characterSlug || loadedCharacters.length === 0) return;
      
      console.log('🎯 Direct loading character:', characterSlug);
      
      // Try exact match first
      let character = loadedCharacters.find(c => c.slug === characterSlug);
      
      // If not found, try case insensitive
      if (!character) {
        character = loadedCharacters.find(c => c.slug && c.slug.toLowerCase() === characterSlug.toLowerCase());
      }
      
      // If still not found, try name-based matching
      if (!character) {
        character = loadedCharacters.find(c => 
          c.name && c.name.toLowerCase().replace(/[^a-z0-9]/g, '-') === characterSlug.toLowerCase()
        );
      }
      
      if (character) {
        console.log('✅ Direct match found:', character.name);
        // Force update the character
        currentCharacter = {
          name: character.name,
          slug: character.slug,
          avatar: fixAvatarUrl(character.avatar),
          creator: '@' + (character.creator || 'Selira'),
          description: character.description || 'An amazing character ready for conversation.',
          chats: character.chats || Math.floor(Math.random() * 100) + 'K',
          rating: character.rating || (Math.random() * 2 + 3).toFixed(1),
          tags: character.tags || ['Character']
        };
        
        updateCharacterDisplay();
        highlightCorrectChatItem(character.slug);
        
        // Load chat history for this character
        loadChatHistoryFromStorage(character.slug);
        
        // Clear only if no history loaded
        setTimeout(() => {
          const hasMessages = document.querySelectorAll('.message:not(.welcome-message)').length > 0;
          if (!hasMessages) {
            clearChat();
          }
        }, 500);
      } else {
        console.log('❌ No direct match, using first character');
        loadFallbackCharacter();
      }
    }
    
    // Highlight correct chat item in sidebar
    function highlightCorrectChatItem(targetSlug) {
      document.querySelectorAll('.chat-item').forEach(item => {
        item.classList.remove('active');
        // Check if this item matches the target character
        const onclick = item.getAttribute('onclick') || '';
        if (onclick.includes(targetSlug) || onclick.includes(`'${targetSlug}'`)) {
          item.classList.add('active');
          console.log('✅ Highlighted chat item for:', targetSlug);
        }
      });
    }

    console.log('✅ Selira AI Chat interface initialized with modern design');
  </script>
</body>
</html>