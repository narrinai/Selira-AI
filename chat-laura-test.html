<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI NSFW Chat - Free Adult AI Companion | Selira AI</title>
  <meta name="description" content="Free AI NSFW chat & AI sex chat with adult companions. Unlimited adult conversations, AI NSFW image generation. Private, uncensored AI chat experience.">
  
  <!-- Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-XZXX201WKD"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-XZXX201WKD');
  </script>
  
  <!-- Auth0 Authentication System -->
  <!-- Supabase Authentication System -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="/js/supabase-auth.js"></script>
  
  <!-- Mobile Navigation System -->
  <script src="/js/mobile-nav.js"></script>
  
  <!-- Age Verification System -->
  <script src="/js/age-verification.js"></script>
  
  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
  
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500;600;700&family=Inter:wght@300;400;500;600;700&display=swap');
    
    :root {
      /* Selira dark theme - matching index.html */
      --bg-primary: #0a0a0a;
      --bg-secondary: #1a1a1a;
      --bg-tertiary: #2a2a2a;
      --text-primary: #ffffff;
      --text-secondary: #b3b3b3;
      --text-muted: #888888;
      --accent: #ce93d8;
      --accent-hover: #ba68c8;
      --accent-secondary: #ec4899;
      --border: #333333;
      --success: #10b981;
      --error: #ef4444;
      --radius-sm: 8px;
      --radius-md: 12px;
      --radius-lg: 16px;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      margin: 0 !important;
      padding: 0 !important;
      border: none !important;
      outline: none !important;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background-color: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.6;
      overflow: hidden;
    }

    /* App Layout */
    .app-container {
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    /* Left Sidebar with Character List */
    .sidebar {
      width: 220px;
      background: var(--bg-secondary);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .sidebar-header {
      padding: 16px;
      border-bottom: 1px solid var(--border);
    }

    .sidebar-logo {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      text-decoration: none;
      color: inherit;
      transition: opacity 0.2s ease;
    }

    .sidebar-logo:hover {
      opacity: 0.8;
      text-decoration: none;
      color: inherit;
    }

    .sidebar-logo-text {
      font-family: 'Playfair Display', serif;
      font-size: 18px;
      font-weight: 700;
      color: var(--accent);
    }

    .back-btn {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 8px 16px;
      background: var(--accent);
      color: white;
      border: 1px solid transparent;
      border-radius: 8px;
      font-weight: 600;
      font-size: 13px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .back-btn:hover {
      background: var(--accent-hover, #c49563);
      color: white;
      text-decoration: none;
    }

    .sidebar-section {
      flex: 1;
      overflow-y: auto;
    }

    .section-header {
      padding: 16px 16px 8px;
      font-size: 10px;
      font-weight: 700;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .chat-list {
      padding: 0 8px;
    }

    .chat-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      margin-bottom: 2px;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .chat-item:hover, .chat-item.active {
      background: var(--bg-tertiary);
    }

    .chat-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      overflow: hidden;
      flex-shrink: 0;
      background: var(--bg-tertiary);
      flex-shrink: 0;
    }

    .chat-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .chat-info {
      flex: 1;
      min-width: 0;
    }

    .chat-name {
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 4px;
      font-size: 14px;
    }

    .chat-preview {
      color: var(--text-secondary);
      font-size: 12px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 100%;
      white-space: nowrap;
    }

    /* Main Chat Area */
    .chat-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* Chat Header */
    .chat-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 20px;
      border-bottom: 1px solid var(--border);
      background: var(--bg-secondary);
    }

    .character-info-header {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .character-avatar-header {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      overflow: hidden;
      border: 2px solid var(--accent);
    }

    .character-avatar-header img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .character-name-header {
      font-family: 'Playfair Display', serif;
      font-size: 20px;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 4px;
    }

    .character-status {
      color: var(--text-secondary);
      font-size: 14px;
    }

    .chat-actions {
      display: flex;
      gap: 8px;
    }

    .action-btn {
      width: 40px;
      height: 40px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
    }

    .action-btn:hover {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    /* Action Menu Dropdown */
    .action-menu-container {
      position: relative;
    }

    .action-menu {
      position: absolute;
      top: 50px;
      right: 0;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      min-width: 200px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      overflow: hidden;
    }

    .action-menu-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      color: var(--text-primary);
      cursor: pointer;
      transition: background 0.2s ease;
      font-size: 14px;
    }

    .action-menu-item:hover {
      background: var(--bg-tertiary);
    }

    .menu-icon {
      font-size: 16px;
      width: 20px;
      text-align: center;
    }

    /* Right Sidebar Character Details */
    .character-sidebar {
      width: 320px;
      background: var(--bg-secondary);
      border-left: 1px solid var(--border);
      padding: 20px;
      overflow-y: auto;
    }

    .character-profile {
      text-align: center;
      margin-bottom: 30px;
    }

    /* Image Carousel Styles */
    .character-image-carousel {
      position: relative;
      width: 100%;
      max-width: 400px;
      margin: 0 auto 20px;
      border-radius: 16px;
      overflow: hidden;
      background: var(--bg-tertiary);
    }

    .carousel-images {
      position: relative;
      width: 100%;
      aspect-ratio: 3/4;
    }

    .carousel-image {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: 0;
      transition: opacity 0.5s ease;
      cursor: pointer;
    }

    .carousel-image.active {
      opacity: 1;
    }

    .carousel-nav {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(0, 0, 0, 0.5);
      border: none;
      color: white;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      transition: all 0.2s ease;
    }

    .carousel-nav:hover {
      background: rgba(0, 0, 0, 0.8);
      transform: translateY(-50%) scale(1.1);
    }

    .carousel-nav-prev {
      left: 10px;
    }

    .carousel-nav-next {
      right: 10px;
    }

    .carousel-indicators {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      z-index: 10;
    }

    .carousel-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.5);
      border: none;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .carousel-indicator.active {
      background: var(--accent);
      width: 24px;
      border-radius: 4px;
    }

    .character-avatar-large {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      overflow: hidden;
      margin: 0 auto 16px;
      border: 3px solid var(--accent);
      display: none; /* Hide old avatar, use carousel instead */
    }

    .character-avatar-large img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .character-name-large {
      font-family: 'Playfair Display', serif;
      font-size: 24px;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 8px;
    }

    .character-creator {
      color: var(--accent);
      font-size: 14px;
      margin-bottom: 16px;
    }

    .character-description {
      color: var(--text-secondary);
      font-size: 14px;
      line-height: 1.5;
      margin-bottom: 20px;
    }

    .character-stats {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
    }

    .stat-item {
      text-align: center;
    }

    .stat-number {
      font-size: 18px;
      font-weight: 700;
      color: var(--text-primary);
    }

    .stat-label {
      font-size: 12px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .character-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 20px;
      justify-content: center;
    }

    .character-tag {
      background: rgba(212, 165, 116, 0.2);
      color: var(--accent);
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
    }

    /* Chat Messages */
    .chat-messages {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
      background: var(--bg-primary);
    }

    .welcome-message {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      text-align: center;
      color: var(--text-secondary);
    }

    .welcome-icon {
      font-size: 48px;
      margin-bottom: 16px;
    }

    .welcome-message h3 {
      font-family: 'Playfair Display', serif;
      font-size: 24px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 8px;
    }

    .message-group {
      margin-bottom: 20px;
    }

    .message {
      display: flex;
      gap: 12px;
      margin-bottom: 16px;
      max-width: 80%;
    }

    .message.user {
      flex-direction: row-reverse;
      margin-left: auto;
    }

    .message-avatar {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      overflow: hidden;
      flex-shrink: 0;
    }

    .message-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    /* Typing indicator animation */
    .typing-dots {
      display: flex;
      gap: 4px;
      align-items: center;
      padding: 8px 0;
    }

    .typing-dots span {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-secondary);
      animation: typing 1.4s infinite;
    }

    .typing-dots span:nth-child(2) {
      animation-delay: 0.2s;
    }

    .typing-dots span:nth-child(3) {
      animation-delay: 0.4s;
    }

    @keyframes typing {
      0%, 60%, 100% {
        opacity: 0.3;
        transform: scale(0.8);
      }
      30% {
        opacity: 1;
        transform: scale(1);
      }
    }

    .message-content {
      background: var(--bg-secondary);
      padding: 12px 16px;
      border-radius: 18px;
      color: var(--text-primary);
      line-height: 1.4;
    }

    .message.user .message-content {
      background: var(--accent);
      color: white;
    }

    /* Chat Input */
    .chat-input-container {
      padding: 20px;
      border-top: 1px solid var(--border);
      background: var(--bg-secondary);
      display: flex;
      flex-direction: column;
    }

    .image-prompt-suggestions {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease-in-out;
      order: -1; /* Ensure it appears before the input wrapper */
      margin-bottom: 0;
    }

    .image-prompt-suggestions.visible {
      max-height: 60vh;
      overflow-y: auto;
      margin-bottom: 16px;
      padding-bottom: 8px;
    }

    .suggestions-header {
      font-size: 12px;
      color: var(--text-secondary);
      margin-bottom: 8px;
      font-weight: 600;
    }

    .suggestion-buttons {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .suggestion-button {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 13px;
      color: var(--text-primary);
      cursor: pointer;
      text-align: left;
      transition: all 0.2s ease;
      line-height: 1.3;
    }

    .suggestion-button:hover {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    /* Pose & Outfit Selector Styles for Uncensored Mode */
    .pose-outfit-selector {
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-height: 45vh;
      overflow-y: auto;
    }

    .selector-section {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .selector-label {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .selector-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .selector-btn {
      background: var(--bg-tertiary);
      border: 1.5px solid var(--border);
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 12px;
      color: var(--text-primary);
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
      font-weight: 500;
    }

    .selector-btn:hover {
      background: var(--bg-secondary);
      border-color: var(--accent);
    }

    .selector-btn.selected {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
      font-weight: 600;
    }

    .generate-image-btn {
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 10px 16px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-top: 12px;
      margin-bottom: 12px;
      width: 100%;
    }

    .generate-image-btn:hover {
      opacity: 0.9;
      transform: translateY(-1px);
    }

    .generate-image-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .chat-input-wrapper {
      display: flex;
      gap: 12px;
      align-items: flex-end;
    }

    #messageInput {
      flex: 1;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 12px 16px;
      color: var(--text-primary);
      font-family: inherit;
      font-size: 14px;
      resize: none;
      max-height: 120px;
      overflow-y: auto;
    }

    #messageInput:focus {
      outline: none;
      border-color: var(--accent);
    }

    .send-btn {
      width: 40px;
      height: 40px;
      background: var(--accent);
      border: none;
      border-radius: 50%;
      color: white;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
    }

    .send-btn:hover {
      background: var(--accent-hover);
      transform: scale(1.05);
    }

    .send-btn:disabled {
      background: var(--border);
      cursor: not-allowed;
      transform: none;
    }

    .input-footer {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      margin-top: 8px;
      font-size: 12px;
      color: var(--text-muted);
      gap: 12px;
    }

    .request-image-btn {
      background: var(--accent);
      border: 1px solid var(--accent);
      color: white;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .request-image-btn:hover {
      background: var(--bg-tertiary);
      border-color: var(--border);
      color: var(--text-secondary);
    }

    .image-credits-display {
      display: none !important; /* Hidden on desktop */
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: rgba(212, 165, 116, 0.1);
      border: 1px solid rgba(212, 165, 116, 0.2);
      border-radius: 6px;
      font-size: 11px;
      color: var(--accent);
      font-weight: 600;
    }

    .image-credits-display .credits-icon {
      font-size: 12px;
    }

    /* Unfiltered Mode Toggle */
    .unfiltered-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 10px;
      user-select: none;
    }

    .toggle-switch {
      position: relative;
      width: 32px;
      height: 18px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 9px;
      cursor: pointer;
      transition: background 0.3s ease;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .toggle-switch::before {
      content: '';
      position: absolute;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #fff;
      top: 1px;
      left: 1px;
      transition: transform 0.3s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .unfiltered-toggle.active .toggle-switch {
      background: linear-gradient(135deg, #ce93d8 0%, #ec4899 100%);
      border-color: #ce93d8;
    }

    .unfiltered-toggle.active .toggle-switch::before {
      transform: translateX(14px);
    }

    .toggle-label {
      font-size: 10px;
      color: rgba(255, 255, 255, 0.6);
      font-weight: 500;
      transition: color 0.3s ease;
    }

    .unfiltered-toggle.active .toggle-label {
      color: var(--accent);
      font-weight: 600;
    }

    /* Character Search Modal */
    .search-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .search-modal.open {
      display: flex;
    }

    .modal-content {
      background: var(--bg-secondary);
      border-radius: var(--radius-lg);
      width: 90vw;
      max-width: 800px;
      max-height: 80vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 20px;
      border-bottom: 1px solid var(--border);
    }

    .modal-header h3 {
      font-family: 'Playfair Display', serif;
      font-size: 20px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .close-btn {
      width: 32px;
      height: 32px;
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 24px;
      cursor: pointer;
      border-radius: var(--radius-sm);
      transition: all 0.2s ease;
    }

    .close-btn:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .search-input-wrapper {
      padding: 20px;
      border-bottom: 1px solid var(--border);
    }

    #characterSearch {
      width: 100%;
      padding: 12px 16px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      color: var(--text-primary);
      font-size: 14px;
    }

    #characterSearch:focus {
      outline: none;
      border-color: var(--accent);
    }

    .character-grid {
      padding: 20px;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 16px;
      max-height: 400px;
      overflow-y: auto;
    }

    .character-option {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 16px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: center;
    }

    .character-option:hover {
      background: var(--bg-secondary);
      border-color: var(--accent);
      transform: translateY(-2px);
    }

    .character-option-avatar {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      overflow: hidden;
      border: 2px solid var(--accent);
    }

    .character-option-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .character-option-name {
      font-weight: 600;
      color: var(--text-primary);
      font-size: 14px;
    }

    .character-option-role {
      color: var(--text-secondary);
      font-size: 12px;
    }

    /* Hide mobile-nav on desktop for chat page */
    #selira-mobile-nav {
      display: none !important;
    }

    /* Mobile Responsive */
    @media (max-width: 768px) {
      /* Show mobile-nav on mobile */
      #selira-mobile-nav {
        display: block !important;
      }

      body {
        overflow: hidden;
      }

      .app-container {
        height: 100vh;
        height: 100dvh; /* Use dynamic viewport height */
      }

      .sidebar {
        position: fixed !important;
        left: -220px !important;
        top: 60px !important; /* Below mobile-nav bar */
        bottom: 0 !important;
        z-index: 10000 !important; /* Higher than mobile-nav (1000) */
        transition: left 0.3s ease !important;
        height: calc(100vh - 60px) !important;
        height: calc(100dvh - 60px) !important;
        width: 220px !important;
        max-width: 220px !important;
        transform: translateZ(0) !important; /* Force GPU acceleration */
        display: flex !important;
        visibility: visible !important;
        opacity: 1 !important;
        background: var(--bg-secondary) !important;
      }

      .sidebar.open {
        left: 0 !important;
        transform: translateX(0) !important;
      }

      .chat-main {
        margin-left: 0;
        height: 100vh;
        height: 100dvh;
        display: flex;
        flex-direction: column;
        padding-top: 0 !important;
      }

      .character-sidebar {
        display: none;
      }

      .chat-header {
        padding: 12px 16px;
        flex-shrink: 0;
        position: fixed;
        top: 60px;
        left: 0;
        right: 0;
        z-index: 100;
        background: var(--bg-secondary);
      }

      .character-info-header {
        gap: 12px;
      }

      .character-avatar-header {
        width: 40px;
        height: 40px;
      }

      .character-name-header {
        font-size: 18px;
      }

      .character-status {
        font-size: 12px;
      }

      .chat-actions {
        gap: 4px;
      }

      .action-btn {
        width: 36px;
        height: 36px;
        font-size: 16px;
      }

      .chat-messages {
        flex: 1;
        padding: 16px;
        padding-top: 76px;
        overflow-y: auto;
        /* Ensure messages area takes available space */
        min-height: 0;
      }

      .chat-input-container {
        padding: 12px 16px;
        /* Ensure input stays at bottom */
        flex-shrink: 0;
        /* Add safe area padding for iOS */
        padding-bottom: calc(12px + env(safe-area-inset-bottom));
      }

      .chat-input-wrapper {
        gap: 8px;
      }

      #messageInput {
        font-size: 16px; /* Prevent zoom on iOS */
        padding: 10px 14px;
        border-radius: 16px;
      }

      .send-btn {
        width: 36px;
        height: 36px;
        font-size: 16px;
        flex-shrink: 0;
      }

      .input-footer {
        margin-top: 6px;
        font-size: 11px;
        flex-wrap: nowrap;
        gap: 8px;
        justify-content: space-between;
      }

      .input-hint {
        white-space: nowrap;
        font-size: 10px;
        margin-left: auto;
      }

      .request-image-btn {
        padding: 4px 8px;
        font-size: 10px;
      }


      .message {
        max-width: 90%;
        margin-bottom: 12px;
      }

      .message-content {
        padding: 10px 12px;
        border-radius: 16px;
        font-size: 14px;
        line-height: 1.4;
      }

      .message-avatar {
        width: 32px;
        height: 32px;
      }

      /* Fix for keyboard pushing content up */
      .chat-input-container {
        position: sticky;
        bottom: 0;
        background: var(--bg-secondary);
        border-top: 1px solid var(--border);
        /* Ensure the input stays visible above virtual keyboard */
        z-index: 10;
      }
      
      /* Additional mobile keyboard fixes for all browsers */
      @media (max-width: 768px) {
        /* Prevent viewport zoom when focusing inputs */
        input, textarea, select {
          font-size: 16px !important;
          -webkit-text-size-adjust: 100%;
          -webkit-appearance: none;
        }
        
        /* Alternative fixed positioning for input container */
        body.keyboard-open .chat-input-container {
          position: fixed;
          bottom: 0;
          left: 0;
          right: 0;
          z-index: 1000;
          background: var(--bg-secondary);
          border-top: 1px solid var(--border);
          padding-bottom: env(safe-area-inset-bottom, 0px);
        }
        
        /* Adjust messages area when keyboard is open */
        body.keyboard-open .chat-messages {
          padding-bottom: 100px;
        }
      }

      /* Additional mobile fixes */
      .app-container {
        /* Prevent content from jumping when virtual keyboard appears */
        position: relative;
      }

      /* Make sure messages scroll properly on mobile */
      .chat-messages::-webkit-scrollbar {
        display: none;
      }

      .chat-messages {
        -ms-overflow-style: none;
        scrollbar-width: none;
        /* Smooth scrolling */
        scroll-behavior: smooth;
      }

      /* iOS specific fixes */
      @supports (-webkit-appearance: none) {
        .chat-main {
          /* Fix for iOS Safari viewport height issues */
          height: -webkit-fill-available;
        }

        #messageInput {
          /* Prevent iOS Safari from zooming when focusing input */
          transform: scale(1);
          transition: transform 0.1s ease;
          /* Additional zoom prevention */
          -webkit-text-size-adjust: 100%;
        }

        #messageInput:focus {
          transform: scale(1);
          /* Ensure no zoom on focus */
          -webkit-text-size-adjust: 100%;
        }
        
        /* Fix for keyboard covering send button */
        .chat-input-container {
          /* Keep input container in view when keyboard appears */
          position: fixed;
          bottom: 0;
          left: 0;
          right: 0;
          background: var(--bg-secondary);
          border-top: 1px solid var(--border);
          padding-bottom: calc(12px + env(safe-area-inset-bottom, 0px));
          z-index: 1000;
        }
        
        /* Adjust chat messages to account for fixed input */
        .chat-messages {
          /* Add bottom padding to prevent content being hidden behind fixed input */
          padding-bottom: 120px;
        }
      }

      /* Sidebar overlay */
      .sidebar-overlay {
        position: fixed;
        top: 60px; /* Below mobile-nav on mobile */
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 9999; /* Higher than mobile-nav, below sidebar */
        display: none;
      }

      .sidebar-overlay.open {
        display: block;
      }

      /* On desktop, overlay should cover full screen (no mobile-nav) */
      @media (min-width: 769px) {
        .sidebar-overlay {
          top: 0;
        }
      }
    }

    /* Hide character sidebar on medium screens */
    @media (max-width: 1200px) {
      .character-sidebar {
        display: none;
      }
    }

    /* Avatar Modal Styles */
    .avatar-modal {
      display: none;
      position: fixed;
      z-index: 10000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(5px);
      animation: fadeIn 0.3s ease;
    }

    .avatar-modal.show {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .avatar-modal-content {
      max-width: 90vw;
      max-height: 90vh;
      position: relative;
      animation: zoomIn 0.3s ease;
    }

    .avatar-modal img {
      width: auto;
      height: auto;
      max-width: 100%;
      max-height: 90vh;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }

    .avatar-modal-close {
      position: absolute;
      top: -40px;
      right: 0;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      font-size: 24px;
      cursor: pointer;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .avatar-modal-close:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .clickable-avatar {
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .clickable-avatar:hover {
      transform: scale(1.05);
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes zoomIn {
      from { transform: scale(0.5); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }

    /* Image Upgrade Modal Styles */
    .image-upgrade-modal {
      display: none;
      position: fixed;
      z-index: 10001;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(5px);
      animation: fadeIn 0.3s ease;
    }

    .image-upgrade-modal.show {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .image-upgrade-content {
      background: var(--bg-primary);
      border-radius: 16px;
      padding: 24px;
      max-width: 480px;
      width: 90vw;
      max-height: 85vh;
      overflow-y: auto;
      box-shadow: 0 16px 64px rgba(0, 0, 0, 0.4);
      animation: zoomIn 0.3s ease;
      border: 1px solid var(--border);
      position: relative;
    }

    .image-upgrade-header {
      text-align: center;
      margin-bottom: 16px;
    }

    .image-upgrade-header img {
      max-width: 240px;
      max-height: 140px;
      object-fit: cover;
      margin-bottom: 12px !important;
    }

    @media (max-width: 768px) {
      .image-upgrade-content {
        max-height: 80vh;
        padding: 20px;
      }

      .image-upgrade-header {
        margin-bottom: 12px;
      }

      .image-upgrade-header img {
        max-width: 180px !important;
        max-height: 100px;
      }
    }

    .image-upgrade-icon {
      font-size: 48px;
      margin-bottom: 16px;
    }

    .image-upgrade-title {
      font-family: 'Playfair Display', serif;
      font-size: 28px;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 8px;
    }

    .image-upgrade-subtitle {
      color: var(--text-secondary);
      font-size: 16px;
    }

    .image-upgrade-features {
      margin: 12px 0;
    }

    .image-upgrade-feature {
      display: flex;
      align-items: center;
      margin-bottom: 6px;
      color: var(--text-primary);
      font-size: 13px;
    }

    .image-upgrade-feature-icon {
      margin-right: 8px;
      font-size: 16px;
      color: var(--accent);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .image-upgrade-feature-icon svg {
      stroke: var(--accent);
    }

    .image-upgrade-buttons {
      display: flex;
      flex-wrap: nowrap;
      gap: 12px;
      margin-top: 16px;
    }

    .image-upgrade-btn {
      flex: 1;
      padding: 10px 16px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 14px;
      text-decoration: none;
      text-align: center;
      transition: all 0.2s ease;
      border: none;
      cursor: pointer;
      white-space: nowrap;
    }

    .image-upgrade-btn.primary {
      background: var(--accent);
      color: white;
    }

    .image-upgrade-btn.primary:hover {
      background: var(--accent-hover);
      transform: translateY(-2px);
    }

    .image-upgrade-btn.secondary {
      background: transparent;
      color: var(--text-secondary);
      border: 1px solid var(--border);
    }

    .image-upgrade-btn.secondary:hover {
      background: var(--bg-secondary);
      color: var(--text-primary);
    }

    .image-upgrade-close {
      position: absolute;
      top: 12px;
      right: 12px;
      background: rgba(0, 0, 0, 0.5);
      border: none;
      color: #ffffff;
      font-size: 28px;
      cursor: pointer;
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.2s ease;
      z-index: 10;
      font-weight: 300;
      line-height: 1;
    }

    .image-upgrade-close:hover {
      background: rgba(0, 0, 0, 0.7);
      transform: scale(1.1);
    }

    .image-upgrade-close:active {
      transform: scale(0.95);
    }

    /* Image Suggestions Enhancement Styles */
    .image-upgrade-notice {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 12px;
    }

    .upgrade-notice-content {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .upgrade-notice-icon {
      font-size: 24px;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .upgrade-notice-icon svg {
      stroke: var(--accent);
    }

    .upgrade-notice-text {
      flex: 1;
    }

    .upgrade-notice-title {
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 4px;
    }

    .upgrade-notice-subtitle {
      color: var(--text-secondary);
      font-size: 14px;
    }

    .upgrade-notice-btn {
      background: var(--accent);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }

    .upgrade-notice-btn:hover {
      background: var(--accent-hover);
      transform: translateY(-1px);
    }

    .image-plan-info {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 12px;
      margin-bottom: 12px;
      font-size: 14px;
    }

    .plan-badge {
      background: var(--accent);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-weight: 600;
      font-size: 12px;
      text-transform: uppercase;
    }

    .plan-remaining {
      color: var(--text-secondary);
    }

    /* Payment Icons (Desktop only) */
    .payment-icons {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 12px;
      padding: 0 10px;
      opacity: 0.7;
    }

    .payment-icon {
      height: 24px;
      width: auto;
      transition: opacity 0.2s ease;
    }

    .payment-icon:hover {
      opacity: 1;
    }

    @media (max-width: 768px) {
      .payment-icons {
        display: none;
      }
    }
  </style>

  <!-- Meta Pixel Code -->
  <script>
  !function(f,b,e,v,n,t,s)
  {if(f.fbq)return;n=f.fbq=function(){n.callMethod?
  n.callMethod.apply(n,arguments):n.queue.push(arguments)};
  if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
  n.queue=[];t=b.createElement(e);t.async=!0;
  t.src=v;s=b.getElementsByTagName(e)[0];
  s.parentNode.insertBefore(t,s)}(window, document,'script',
  'https://connect.facebook.net/en_US/fbevents.js');
  fbq('init', '1155600863117016');
  fbq('track', 'PageView');
  </script>
  <noscript><img height="1" width="1" style="display:none"
  src="https://www.facebook.com/tr?id=1155600863117016&ev=PageView&noscript=1"
  /></noscript>
  <!-- End Meta Pixel Code -->

  <!-- Facebook Pixel Event Tracking -->
  <script src="/js/facebook-pixel-events.js"></script>

  <!-- FirstPromoter Tracking Script -->
  <script>(function(w){w.fpr=w.fpr||function(){w.fpr.q = w.fpr.q||[];w.fpr.q[arguments[0]=='set'?'unshift':'push'](arguments);};})(window);
  fpr("init", {cid:"20yp5m1k"}); fpr("click");
  </script>
  <script src="https://cdn.firstpromoter.com/fpr.js" async></script>
  <!-- End FirstPromoter Tracking Script -->
</head>
<body class="chat-page">
  <!-- Avatar Modal -->
  <div class="avatar-modal" id="avatarModal">
    <div class="avatar-modal-content">
      <button class="avatar-modal-close" onclick="closeAvatarModal()">&times;</button>
      <img id="avatarModalImage" src="" alt="Character Avatar">
    </div>
  </div>

  <!-- Image Upgrade Modal -->
  <div class="image-upgrade-modal" id="imageUpgradeModal">
    <div class="image-upgrade-content">
      <button class="image-upgrade-close" onclick="closeImageUpgradeModal()">&times;</button>

      <div class="image-upgrade-header">
        <img src="https://storage.googleapis.com/promptchan-fe814.appspot.com/generated_images_v2/personal/2025-10-12/mw4epOLyrtVYQx1TbNLd0n7eq7i2/aYZOzDeaykEr8vIF0dV3?Expires=4913873470&GoogleAccessId=firebase-adminsdk-jjn1g%40promptchan-fe814.iam.gserviceaccount.com&Signature=tDtc%2Fpck%2Bmq3w1B2HnepsFraIzMdUnF4b2s68LAlenME318vPb9UZ9wEMiNEuLLAYKHv60SGzF9u04vp38%2FqpbhQnJMifZabzrgElGqge0likvm6ga4y1ZugNwIrB68NPtiR0UZk0InoOCOSot1l6GGrV8KsGWZpmfmqeMeliOjFWb0aLlbo76sRCdPgvkp4xyQR5Q%2FeqP%2F8PttyReWY6fmpwIRoxjrFBT2eFyfLBG7r1ElEDuTcEABQyhRHUDLA8KRKCiqLO1jNdOqC6sD8zBBe%2BGT0Z7ZqxoyZ%2F9n%2BIfOQe0Q1UH%2FSTiqTDnQsPh51vguoQ1%2FBjP0PUqFdA8ydtw%3D%3D" alt="AI Generated Image Example" style="width: 100%; border-radius: 16px; box-shadow: 0 8px 32px rgba(0,0,0,0.1);">
        <div class="image-upgrade-title" id="upgradeModalTitle">Unlock Image Generation</div>
        <p style="color: var(--text-secondary); font-size: 13px; margin-top: 8px;">Get unlimited AI images with a subscription</p>
      </div>

      <div class="image-upgrade-features">
        <div class="image-upgrade-feature">
          <div class="image-upgrade-feature-icon">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M12 2v20M2 12h20"></path>
            </svg>
          </div>
          <div><strong>Unlimited image generation</strong> - No limits</div>
        </div>
        <div class="image-upgrade-feature">
          <div class="image-upgrade-feature-icon">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="12" r="10"></circle>
              <circle cx="12" cy="12" r="6"></circle>
              <circle cx="12" cy="12" r="2"></circle>
            </svg>
          </div>
          <div>Custom poses, scenarios & styles</div>
        </div>
      </div>

      <div class="image-upgrade-buttons">
        <button class="image-upgrade-btn secondary" onclick="closeImageUpgradeModal()">Maybe Later</button>
        <a href="/pricing" class="image-upgrade-btn primary" id="upgradeButton">View Plans</a>
      </div>

      <div style="text-align: center; margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border);">
        <p style="color: var(--text-muted); font-size: 11px; margin-bottom: 6px;">Or buy one-time credits instead</p>
        <a href="/pricing?tab=credits" style="color: var(--text-secondary); font-size: 12px; text-decoration: none;">View Credits →</a>
      </div>
    </div>
  </div>

  <div class="app-container">
    <!-- Left Sidebar with Character List -->
    <aside class="sidebar" id="sidebar">
      <!-- Sidebar Header -->
      <div class="sidebar-header">
        <a href="/" class="sidebar-logo">
          <div class="sidebar-logo-text">Selira AI</div>
        </a>
        <a href="/" class="back-btn" title="Back to Characters">
          <span class="btn-icon">←</span>
          <span>Back</span>
        </a>
      </div>

      <!-- Recent Chats -->
      <div class="sidebar-section">
        <div class="section-header">
          <span>Today</span>
        </div>
        <div class="chat-list" id="chatList">
          <!-- Chat items will be populated dynamically from Airtable -->
          <div class="loading-chats" style="text-align: center; padding: 20px; color: var(--text-secondary); font-size: 14px;">
            <div style="margin-bottom: 8px;">🔄</div>
            Loading characters...
          </div>
        </div>
      </div>
    </aside>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Main Chat Area -->
    <main class="chat-main">
      <!-- Chat Header -->
      <header class="chat-header" id="chatHeader">
        <div class="character-info-header">
          <div class="character-avatar-header" id="currentCharacterAvatar">
            <img src="/avatars/placeholder.webp" alt="Character" id="characterImage" onerror="this.style.display='none';">
          </div>
          <div class="character-details">
            <h2 class="character-name-header" id="currentCharacterName">Loading...</h2>
            <p class="character-status" id="currentCharacterStatus">@Selira</p>
          </div>
        </div>
        <div class="chat-actions">
          <div class="action-menu-container">
            <button class="action-btn" onclick="toggleActionMenu()" title="More options" id="actionMenuBtn">
              <span>⋮</span>
            </button>
            <div class="action-menu" id="actionMenu" style="display: none;">
              <div class="action-menu-item" onclick="toggleCharacterInfo(); closeActionMenu();">
                <span>Companion Information</span>
              </div>
              <div class="action-menu-item" onclick="openSupportWidget(); closeActionMenu();">
                <span>Support</span>
              </div>
            </div>
          </div>
          <button class="action-btn" onclick="clearChat()" title="Clear Chat">
            <span>🗑️</span>
          </button>
        </div>
      </header>

      <!-- Chat Messages Area -->
      <div class="chat-messages" id="chatMessages">
        <div class="welcome-message" style="text-align: center; padding: 40px 20px; color: var(--text-secondary);">
          <div style="font-size: 48px; margin-bottom: 16px;">💭</div>
          <h3 style="color: var(--text-primary); margin-bottom: 8px;">Chat Cleared</h3>
          <p>Start a new conversation!</p>
        </div>
      </div>

      <!-- Chat Input -->
      <div class="chat-input-container" id="chatInputContainer">
        <!-- Image Prompt Suggestions (appears above input) -->
        <div class="image-prompt-suggestions" id="imagePromptSuggestions">
          <div class="suggestion-buttons" id="suggestionButtons">
            <!-- Suggestions will be populated by JavaScript -->
          </div>
        </div>

        <div class="chat-input-wrapper">
          <textarea
            id="messageInput"
            placeholder="Enter a message. Ex) Hello?"
            rows="1"
            maxlength="2000"
          ></textarea>
          <button class="send-btn" id="sendBtn" onclick="sendMessage()">
            <span>➤</span>
          </button>
        </div>
        <div class="input-footer">
          <button class="request-image-btn" onclick="requestImage()" title="Get Image Suggestions">
            + Image Gen
          </button>
          <div class="unfiltered-toggle active" id="unfilteredToggle" onclick="toggleUnfilteredMode()" title="Toggle Censorship Mode for Chat and Images">
            <div class="toggle-switch"></div>
            <span class="toggle-label" id="toggleText">Uncensored Chat/Images</span>
          </div>
          <div class="image-credits-display" id="imageCreditsDisplay" style="display: none;">
            <span class="credits-icon">💳</span>
            <span id="imageCreditsText">Loading...</span>
          </div>
          <span class="input-hint">AI is <a href="/terms.html" style="color: inherit; text-decoration: underline;">fictional</a>.</span>
        </div>
      </div>
    </main>

    <!-- Right Sidebar Character Details -->
    <aside class="character-sidebar" id="characterSidebar">
      <div class="character-profile">
        <!-- Image Carousel -->
        <div class="character-image-carousel" id="imageCarousel">
          <div class="carousel-images">
            <img src="/avatars/placeholder.webp" alt="Character" class="carousel-image active" id="carouselImage1">
            <img src="/avatars/placeholder.webp" alt="Character" class="carousel-image" id="carouselImage2" style="display: none;">
          </div>
          <button class="carousel-nav carousel-nav-prev" id="carouselPrev">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polyline points="15 18 9 12 15 6"></polyline>
            </svg>
          </button>
          <button class="carousel-nav carousel-nav-next" id="carouselNext">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polyline points="9 18 15 12 9 6"></polyline>
            </svg>
          </button>
          <div class="carousel-indicators" id="carouselIndicators">
            <button class="carousel-indicator active" data-index="0"></button>
            <button class="carousel-indicator" data-index="1"></button>
          </div>
        </div>

        <!-- Old avatar (hidden, kept for fallback) -->
        <div class="character-avatar-large">
          <img src="/avatars/placeholder.webp" alt="Character" id="sidebarCharacterImage" onerror="this.style.display='none';">
        </div>
        <h3 class="character-name-large" id="sidebarCharacterName">Loading...</h3>
        <p class="character-creator" id="sidebarCharacterCreator">@Selira</p>
        <p class="character-description" id="sidebarCharacterDescription">
          Loading character information...
        </p>
        
        <div class="character-stats">
          <div class="stat-item">
            <div class="stat-number" id="sidebarCharacterChats">0</div>
            <div class="stat-label">Chats</div>
          </div>
        </div>
        
        <div class="character-tags" id="sidebarCharacterTags">
          <span class="character-tag">Unfiltered</span>
          <span class="character-tag">Anime</span>
          <span class="character-tag">Wholesome</span>
          <span class="character-tag">Animal</span>
          <span class="character-tag">Femboy</span>
          <span class="character-tag">MILF</span>
          <span class="character-tag">Action</span>
          <span class="character-tag">Sci-Fi</span>
          <span class="character-tag">VTuber</span>
          <span class="character-tag">Fantasy</span>
          <span class="character-tag">Female</span>
        </div>
      </div>
    </aside>

    <!-- Character Search Modal -->
    <div class="search-modal" id="searchModal">
      <div class="modal-content">
        <div class="modal-header">
          <h3>Choose a Character</h3>
          <button class="close-btn" onclick="closeCharacterSearch()">×</button>
        </div>
        <div class="search-input-wrapper">
          <input type="text" id="characterSearch" placeholder="Search characters...">
        </div>
        <div class="character-grid" id="characterGrid">
          <!-- Sample characters -->
          <div class="character-option" onclick="selectCharacter('aragorn')">
            <div class="character-option-avatar">
              <img src="https://selira.ai/avatars/aragorn-1750067445.webp" alt="Aragorn">
            </div>
            <div class="character-option-name">Aragorn</div>
            <div class="character-option-role">Ranger King</div>
          </div>
          <div class="character-option" onclick="selectCharacter('harry-potter')">
            <div class="character-option-avatar">
              <img src="https://selira.ai/avatars/harry-potter-1750067058.webp" alt="Harry Potter">
            </div>
            <div class="character-option-name">Harry Potter</div>
            <div class="character-option-role">The Boy Who Lived</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Delete Companion Modal -->
    <div class="delete-modal" id="deleteModal" style="display: none;">
      <div class="delete-modal-content">
        <div class="delete-modal-header">
          <h3>Delete Companion</h3>
          <button class="delete-modal-close" onclick="closeDeleteModal()">×</button>
        </div>
        <div class="delete-modal-body">
          <div class="delete-option" onclick="deleteCompanion()">
            <div class="delete-option-icon">👋</div>
            <div class="delete-option-content">
              <h4>Delete Companion</h4>
              <p>Remove this companion and clear all chat history</p>
              <small style="color: var(--text-secondary);">This action will clear your chat but the companion remains available</small>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // NSFW Pose & Outfit options for uncensored image generation - FEMALE
    const NSFW_POSES_FEMALE = [
      { id: 'pov-oral', label: 'POV Blowjob', prompt: 'POV blowjob angle, kneeling, large penis in mouth visible, dick clearly shown, oral sex close-up, fellatio, cock sucking, male POV perspective, penis shaft visible in frame, explicit oral, NSFW' },
      { id: 'doggy', label: 'Doggy Style', prompt: 'doggy style position, ass up face down, from behind, rear view, legs spread, explicit penetration, pussy visible, sexual position, NSFW' },
      { id: 'cowgirl', label: 'Cowgirl', prompt: 'cowgirl position, riding, straddling, on top, explicit sex position, breasts visible, intimate angle, NSFW' },
      { id: 'missionary', label: 'Missionary', prompt: 'missionary position, legs spread, laying on back, intimate angle, explicit sex position, pussy visible, NSFW' },
      { id: 'fingering', label: 'Masturbating', prompt: 'masturbating explicitly, hand between legs, fingers penetrating pussy, fingering herself, self-pleasure, legs spread wide open, touching genitals, rubbing clit, explicit masturbation, pleasuring herself, finger in vagina, NSFW porn' },
      { id: 'reverse-cowgirl', label: 'Reverse Cowgirl', prompt: 'reverse cowgirl position, riding facing away, ass view, straddling backwards, explicit sex position, penetration visible, rear angle, NSFW' },
      { id: 'bent-over', label: 'Bent Over', prompt: 'bent over pose, ass up, leaning forward over furniture, rear view, bent at waist, showing ass and pussy, explicit bent over position, NSFW' },
      { id: 'anal', label: 'Anal', prompt: 'anal sex position, penetration from behind, ass penetration, anal intercourse, explicit anal, spreading ass cheeks, asshole visible, NSFW' }
    ];

    const NSFW_OUTFITS_FEMALE = [
      { id: 'nude', label: 'Fully Nude', prompt: 'completely naked, fully nude, no clothes, bare skin, nude body, naked breasts, exposed pussy, totally naked, unclothed, full nudity, NSFW' },
      { id: 'lingerie', label: 'Sexy Lingerie', prompt: 'sexy lingerie, lace bra and panties, see-through lingerie, revealing intimate wear, skimpy underwear, NSFW' },
      { id: 'stockings', label: 'Stockings Only', prompt: 'wearing only stockings, thigh-high stockings, naked with stockings, stockings and nothing else, nude with stockings, NSFW' },
      { id: 'fishnet', label: 'Fishnet', prompt: 'fishnet bodysuit, fishnet lingerie, see-through fishnet outfit, fishnet stockings and top, mesh clothing, sexy fishnet, NSFW' },
      { id: 'latex', label: 'Latex/Leather', prompt: 'tight latex outfit, shiny leather clothing, latex bodysuit, leather lingerie, kinky outfit, fetish wear, NSFW' },
      { id: 'schoolgirl', label: 'Schoolgirl', prompt: 'sexy schoolgirl outfit, short skirt, unbuttoned shirt, revealing school uniform, naughty student look, anime schoolgirl, NSFW' },
      { id: 'maid', label: 'Maid Outfit', prompt: 'sexy maid costume, french maid outfit, short skirt maid uniform, revealing maid dress, frilly maid outfit, NSFW' },
      { id: 'nurse', label: 'Nurse', prompt: 'sexy nurse costume, revealing nurse outfit, short nurse dress, naughty nurse uniform, medical fetish outfit, NSFW' }
    ];

    // NSFW Pose & Outfit options for uncensored image generation - MALE
    const NSFW_POSES_MALE = [
      { id: 'getting-oral', label: 'Getting BJ', prompt: 'receiving blowjob, big erect cock in mouth, getting oral sex, woman sucking dick, fellatio on big penis, explicit oral, NSFW' },
      { id: 'doggy', label: 'Doggy Style', prompt: 'fucking doggy style from behind, big dick penetrating pussy, thrusting from rear, muscular body, explicit penetration visible, NSFW' },
      { id: 'being-ridden', label: 'Being Ridden', prompt: 'being ridden cowgirl, woman on top bouncing on big cock, muscular torso, hands on her hips, explicit sex, NSFW' },
      { id: 'missionary', label: 'Missionary', prompt: 'missionary position thrusting, big penis penetrating, muscular body on top, intimate angle, explicit penetration, NSFW' },
      { id: 'masturbating', label: 'Masturbating', prompt: 'masturbating with hand stroking, big erect cock in hand, muscular abs visible, stroking big dick, explicit masturbation, self-pleasure, NSFW' },
      { id: 'reverse-cowgirl', label: 'Reverse Cowgirl', prompt: 'being ridden reverse cowgirl, woman riding facing away, big cock inside, muscular thighs, rear view, explicit penetration, NSFW' },
      { id: 'from-behind', label: 'From Behind', prompt: 'penetrating from behind, big cock in pussy, muscular body, gripping her hips, explicit rear penetration, NSFW' },
      { id: 'anal', label: 'Anal', prompt: 'anal sex from behind, big dick penetrating ass, muscular body, spreading ass cheeks, explicit anal penetration, NSFW' }
    ];

    const NSFW_OUTFITS_MALE = [
      { id: 'nude', label: 'Fully Nude', prompt: 'completely naked, fully nude, no clothes, muscular bare body, big erect cock visible, exposed penis, totally naked, full nudity, NSFW' },
      { id: 'shirtless', label: 'Shirtless', prompt: 'shirtless showing muscular torso, defined abs and chest, bare upper body, muscular physique, topless, NSFW' },
      { id: 'underwear', label: 'Underwear Only', prompt: 'wearing only fitted underwear, bulge visible, muscular body in briefs, boxer briefs showing physique, minimal clothing, NSFW' },
      { id: 'towel', label: 'Towel Only', prompt: 'wearing only a towel, low-hanging towel, muscular body, towel barely covering, revealing towel, NSFW' },
      { id: 'athletic', label: 'Athletic Wear', prompt: 'tight athletic shorts, gym wear showing bulge, muscular body in sportswear, fitted workout clothes, revealing athletic gear, NSFW' },
      { id: 'suit-open', label: 'Open Suit', prompt: 'suit unbuttoned showing muscular chest, open blazer revealing torso, professional attire partially undressed, dress pants and open shirt, NSFW' },
      { id: 'jeans', label: 'Jeans Only', prompt: 'wearing only jeans, shirtless with jeans, muscular upper body bare, low-riding jeans, topless in pants, NSFW' },
      { id: 'swim', label: 'Swim Trunks', prompt: 'swim trunks or speedo, muscular body in swimwear, wet trunks clinging, revealing swim shorts, beach/pool attire, NSFW' }
    ];

    // Dynamic selection based on character gender
    let NSFW_POSES = NSFW_POSES_FEMALE;
    let NSFW_OUTFITS = NSFW_OUTFITS_FEMALE;

    // Selected pose and outfit for image generation
    let selectedPose = null;
    let selectedOutfit = null;

    // Global variables - current character will be loaded from URL
    let currentCharacter = {
      name: 'Loading...',
      slug: 'loading',
      avatar: '/avatars/placeholder.webp',
      creator: '@Selira',
      description: 'Loading character information...',
      chats: 0,
      rating: '0.0',
      tags: ['Loading']
    };

    let chatHistory = [];
    let loadedCharacters = [];

    // Avatar URL correction function
    function fixAvatarUrl(avatarUrl) {
      if (!avatarUrl || avatarUrl === '/avatars/placeholder.webp') {
        return '/avatars/placeholder.webp';
      }
      
      // Fix common naming mismatches
      const avatarMappings = {
        '/avatars/emily.webp': '/avatars/emily-1754251534076.webp',
        '/avatars/aiko.webp': '/avatars/aiko-1754252402847.webp'
      };
      
      if (avatarMappings[avatarUrl]) {
        console.log(`🔧 Fixed avatar URL: ${avatarUrl} -> ${avatarMappings[avatarUrl]}`);
        return avatarMappings[avatarUrl];
      }
      
      return avatarUrl;
    }

    // Mobile keyboard detection to keep send button visible
    function setupMobileKeyboardDetection() {
      if (window.innerWidth <= 768) {
        const messageInput = document.getElementById('messageInput');
        let initialViewportHeight = window.innerHeight;
        
        // Modern browsers: Use Visual Viewport API if available
        if (window.visualViewport) {
          function handleViewportChange() {
            const heightDiff = window.innerHeight - window.visualViewport.height;
            if (heightDiff > 150) {
              document.body.classList.add('keyboard-open');
              console.log('🎹 Keyboard open (Visual Viewport)');
            } else {
              document.body.classList.remove('keyboard-open');
              console.log('🎹 Keyboard closed (Visual Viewport)');
            }
          }
          
          window.visualViewport.addEventListener('resize', handleViewportChange);
        } else {
          // Fallback: Detect when keyboard opens/closes by monitoring viewport height changes
          window.addEventListener('resize', function() {
            const currentHeight = window.innerHeight;
            const heightDifference = initialViewportHeight - currentHeight;
            
            // If viewport height decreased significantly, keyboard is likely open
            if (heightDifference > 150) {
              document.body.classList.add('keyboard-open');
              console.log('🎹 Keyboard detected as open');
            } else {
              document.body.classList.remove('keyboard-open');
              console.log('🎹 Keyboard detected as closed');
            }
          });
        }
        
        // Also listen for focus/blur events on input as additional detection
        if (messageInput) {
          messageInput.addEventListener('focus', function() {
            setTimeout(() => {
              document.body.classList.add('keyboard-open');
            }, 300); // Delay to allow keyboard to appear
          });
          
          messageInput.addEventListener('blur', function() {
            setTimeout(() => {
              document.body.classList.remove('keyboard-open');
            }, 300); // Delay to allow keyboard to disappear
          });
        }
      }
    }

    // ===== UNFILTERED MODE TOGGLE =====
    function toggleUnfilteredMode() {
      const toggle = document.getElementById('unfilteredToggle');
      const text = document.getElementById('toggleText');

      // Get current state
      const isUnfiltered = localStorage.getItem('unfilteredMode') === 'true';

      // Toggle state
      const newState = !isUnfiltered;
      localStorage.setItem('unfilteredMode', newState.toString());

      // Update UI
      if (newState) {
        toggle.classList.add('active');
        text.textContent = 'Uncensored Chat/Images';
        console.log('🔓 Unfiltered mode ENABLED - using uncensored models for chat and images');
      } else {
        toggle.classList.remove('active');
        text.textContent = 'Censored Chat/Images';
        console.log('🔒 Unfiltered mode DISABLED - using censored models for chat and images');
      }
    }

    function loadUnfilteredToggleState() {
      // Migration: Set to uncensored default if user hasn't explicitly set it since 2025-10-10
      const settingsVersion = localStorage.getItem('unfilteredMode_version');
      if (!settingsVersion || settingsVersion !== '2025-10-10') {
        // Set new default (uncensored)
        localStorage.setItem('unfilteredMode', 'true');
        localStorage.setItem('unfilteredMode_version', '2025-10-10');
        console.log('🔄 Migrated unfiltered mode setting to new default (uncensored)');
      }

      // Default to uncensored if not set
      const storedValue = localStorage.getItem('unfilteredMode');
      const isUnfiltered = storedValue === null ? true : storedValue === 'true';

      // Set default value if not exists
      if (storedValue === null) {
        localStorage.setItem('unfilteredMode', 'true');
      }

      const toggle = document.getElementById('unfilteredToggle');
      const text = document.getElementById('toggleText');

      if (isUnfiltered) {
        toggle.classList.add('active');
        text.textContent = 'Uncensored Chat/Images';
        console.log('🔓 Unfiltered mode loaded as ENABLED');
      } else {
        toggle.classList.remove('active');
        text.textContent = 'Censored Chat/Images';
        console.log('🔒 Unfiltered mode loaded as DISABLED (censored)');
      }
    }

    // Initialize chat interface
    document.addEventListener('DOMContentLoaded', function() {
      console.log('🚀 Selira AI Chat interface loading...');
      loadCharactersFromDatabase();
      initializeChatInterface();
      setupEventListeners();
      setupMobileKeyboardDetection();

      // Load active chats in sidebar immediately
      updateActiveChatsSidebar();

      // Load image credits display
      loadImageCredits();

      // Load unfiltered toggle state
      loadUnfilteredToggleState();

      // Refresh sidebar periodically (every 30 seconds)
      setInterval(updateActiveChatsSidebar, 30000);

      // Character from URL will be loaded after characters are fetched in loadCharactersFromDatabase
    });

    function initializeChatInterface() {
      // Set up character info
      updateCharacterDisplay();
      
      // Auto-resize textarea
      const messageInput = document.getElementById('messageInput');
      if (messageInput) {
        messageInput.addEventListener('input', function() {
          autoResizeTextarea();
          // Hide suggestions when user starts typing (unless they just used a suggestion)
          if (messageInput.value && !messageInput.value.startsWith('Send me a picture')) {
            hideImagePromptSuggestions();
          }
        });
        messageInput.addEventListener('keydown', handleKeyDown);
      }
    }

    function setupEventListeners() {
    }

    // Generate image prompt suggestions based on character
    function generateImagePromptSuggestions(character) {
      const name = character.name || 'companion';
      const tags = character.tags || [];
      const description = character.description || '';
      const artStyle = character.companion_type || character.Companion_Type || 'realistic';
      const isMale = (character.sex || character.Sex || character.Gender || '').toLowerCase() === 'male';

      // Check if uncensored mode is enabled
      const isUncensored = localStorage.getItem('unfilteredMode') === 'true';

      console.log(`🎨 Generating image suggestions - Uncensored mode: ${isUncensored ? 'ON 🔓' : 'OFF 🔒'}`);

      // Note: Traits are NOT added to user-visible prompts
      // They will be added internally when sending to the backend

      // UNCENSORED NSFW scenario prompts - EXPANDED with much more variety
      // Different poses, angles, settings, actions for maximum variation
      const uncensoredScenarios = isMale ? [
        `Send me a picture of getting blowjob, big erect cock in mouth, muscular body, abs defined`,
        `Send me a picture of fucking pussy hard from behind, big dick thrusting in doggy style, muscular abs visible, intense face`,
        `Send me a picture of receiving handjob with both hands, huge erect penis being stroked, muscular chest, precum dripping`,
        `Send me a picture of getting ridden cowgirl style, woman on top bouncing on big cock, muscular torso visible, hands on her hips`,
        `Send me a picture of standing fucking against wall, big erect dick in pussy, muscular body, her legs wrapped around`,
        `Send me a picture of lying back getting deepthroat, big hard cock down her throat, muscular abs, her gagging`,
        `Send me a picture of penetrating missionary close-up, huge erect penis sliding in wet pussy, muscular body over her, faces close`,
        `Send me a picture of getting rimmed, tongue on asshole, huge erect cock visible, muscular body relaxed`,
        `Send me a picture of sitting on couch while being ridden reverse cowgirl, big dick inside pussy, muscular thighs, view from behind`,
        `Send me a picture of cumming on face, big cock ejaculating on her face, muscular body, intense orgasm, cum dripping`,
        `Send me a picture of fucking her tits, big cock between breasts, muscular abs, cumming on chest`,
        `Send me a picture of standing getting sucked, big hard cock in her mouth, muscular body, hands in her hair`,
        `Send me a picture of pounding pussy from behind in shower, big dick thrusting, muscular wet body, water dripping`,
        `Send me a picture of lying sideways spooning, big penis penetrating from behind, muscular body pressed against her`,
        `Send me a picture of on chair being ridden, big dick inside pussy, muscular thighs spread, her bouncing wildly`,
        `Send me a picture of getting double blowjob, two mouths on big cock, muscular body, both girls licking shaft`,
        `Send me a picture of fucking ass doggystyle, big cock in tight asshole, muscular body, hands gripping her ass cheeks`,
        `Send me a picture of lying back with legs on shoulders, huge cock deep in pussy, muscular calves, pounding hard`,
        `Send me a picture of standing receiving handjob and blowjob, big erect penis, muscular body, two girls servicing`,
        `Send me a picture of masturbating for her, big hard cock in hand stroking, muscular abs, intense eye contact`
      ] : [
        `Send me a picture of giving sloppy blowjob, big cock in mouth drooling, lips stretched around shaft, huge natural breasts visible, looking up submissively`,
        `Send me a picture of getting pounded missionary, big penis thrusting deep in pussy, huge tits bouncing wildly, legs spread wide, screaming in pleasure`,
        `Send me a picture of riding cock reverse cowgirl bouncing, big dick inside pussy, huge ass prominent jiggling, back arched, view from behind`,
        `Send me a picture of bent over bed getting fucked, big cock in pussy from behind, huge ass exposed, looking back at camera, hair pulled`,
        `Send me a picture of on knees sucking balls, huge breasts hanging, mouth on balls, tongue out, cock resting on face, submissive eyes`,
        `Send me a picture of missionary legs over shoulders, big penis deep in wet pussy, huge tits visible, legs up high, toes curled`,
        `Send me a picture of deepthroat gagging, cock down throat past lips, huge natural breasts, drool dripping, eyes watering, choking`,
        `Send me a picture of doggy style ass up, big dick pounding pussy hard, huge ass jiggling, hands gripping sheets, face in pillow`,
        `Send me a picture of lying back getting pussy eaten, tongue deep in pussy, huge breasts heaving, hands in his hair, legs spread wide`,
        `Send me a picture of threesome spitroast, sucking one cock while another fucks pussy from behind, huge tits swinging, both holes filled`,
        `Send me a picture of anal penetration close-up, big cock stretching tight ass, huge breasts hanging, mouth open moaning, painful pleasure`,
        `Send me a picture of double penetration sandwich, two huge cocks in pussy and ass, massive tits squeezed, face shows ecstasy, completely filled`,
        `Send me a picture of titfuck between huge breasts, big cock sliding between tits, cum shooting on face and chest, mouth open catching`,
        `Send me a picture of straddling face grinding pussy, pussy lips on mouth getting licked, huge breasts bouncing, hands on headboard riding face`,
        `Send me a picture of squatting on cock anal, huge dick inside ass, big ass prominent, feet on ground, full squat position`,
        `Send me a picture of standing against wall fucked, big cock thrusting in pussy, huge tits pressed against wall, leg up on hip, public bathroom`,
        `Send me a picture of on back getting throatfucked upside down, cock in throat, huge breasts visible, head hanging off bed, rough facefuck`,
        `Send me a picture of prone bone position, big dick pounding pussy from above, huge ass, lying flat on stomach, hands pinned down`,
        `Send me a picture of cowgirl grinding on cock, big penis inside pussy, huge tits in his face, riding slowly, intimate eye contact`,
        `Send me a picture of fingering pussy while sucking cock, fingers deep inside, huge breasts, cock in mouth, multitasking slut`,
        `Send me a picture of getting eaten out 69 position, tongue on pussy, huge breasts on his stomach, sucking cock, mutual oral`,
        `Send me a picture of spread eagle tied up, legs and arms spread, pussy exposed wet, huge tits, bondage ropes, helpless`,
        `Send me a picture of cumshot facial, big cock cumming on face, huge tits, mouth open tongue out, cum covering face, satisfied smile`,
        `Send me a picture of getting fucked in lingerie, big cock in pussy, stockings and garter, huge breasts in bra, partially dressed sex`,
        `Send me a picture of oil massage turns sexual, hands on huge oiled breasts, cock between tits, slippery body, sensual touch`
      ];

      // Seductive and suggestive scenario prompts (CENSORED version - current content)
      const baseScenarios = isMale ? [
        `Send me a picture of yourself shirtless, showing off your muscular physique with a confident look`,
        `Send me a picture of yourself in fitted underwear, posing seductively with an intense gaze`,
        `Send me a picture of yourself in the shower with water running down your body, looking back`,
        `Send me a picture of yourself in low-hanging towel, showing off your abs with desire in your eyes`,
        `Send me a picture of yourself in silk robe that's open, revealing your chest with a hungry look`,
        `Send me a picture of yourself lying on satin sheets shirtless, with an inviting pose`,
        `Send me a picture of yourself by a window in moonlight wearing minimal clothing, with a sultry glance`,
        `Send me a picture of yourself with wet hair in just a towel, with tempting eyes`,
        `Send me a picture of yourself flexing your muscles in fitted briefs, with an intense gaze`,
        `Send me a picture of yourself in athletic wear showing your physique, with a seductive expression`,
        `Send me a picture of yourself silhouetted against soft lighting shirtless, with desire`,
        `Send me a picture of yourself in form-fitting underwear kneeling, with a provocative stare`,
        `Send me a picture of yourself touching your chest with lustful eyes`,
        `Send me a picture of yourself with your back to the camera showing muscles, looking over your shoulder`,
        `Send me a picture of yourself in dark underwear sprawled on black silk, with a hungry expression`,
        `Send me a picture of yourself in designer briefs posing confidently with bedroom eyes`,
        `Send me a picture of yourself in unbuttoned shirt revealing your chest with a teasing smile`,
        `Send me a picture of yourself in swim trunks fresh from the pool with water droplets`,
        `Send me a picture of yourself sitting seductively in minimal clothing on a chair`,
        `Send me a picture of yourself partially undressed with a confident look of anticipation`
      ] : [
        `Send me a picture of yourself in revealing lingerie, posing seductively on a bed with bedroom eyes`,
        `Send me a picture of yourself in a tight dress, leaning forward with a provocative smile`,
        `Send me a picture of yourself in the shower with water cascading down your body, looking back`,
        `Send me a picture of yourself in barely-there underwear, stretching sensually with desire in your eyes`,
        `Send me a picture of yourself in a silk robe that's slipping off, with a hungry look`,
        `Send me a picture of yourself lying on satin sheets, wearing something revealing with an inviting pose`,
        `Send me a picture of yourself in lace lingerie standing by a window in moonlight, with a sultry glance`,
        `Send me a picture of yourself wearing a towel that's barely covering you, with wet hair and tempting eyes`,
        `Send me a picture of yourself in a sexy bodysuit, arching your back with an intense gaze`,
        `Send me a picture of yourself in revealing sleepwear, lying on your side with a seductive expression`,
        `Send me a picture of yourself in a sheer nightgown, silhouetted against soft lighting with desire`,
        `Send me a picture of yourself in fishnets and lingerie, kneeling with a provocative stare`,
        `Send me a picture of yourself in a corset and panties, touching your lips with lustful eyes`,
        `Send me a picture of yourself topless with your back to the camera, looking over your shoulder`,
        `Send me a picture of yourself in red lingerie sprawled on black silk, with a hungry expression`,
        `Send me a picture of yourself in a strappy bra and thong, posing confidently with bedroom eyes`,
        `Send me a picture of yourself in satin pajamas unbuttoned, revealing curves with a teasing smile`,
        `Send me a picture of yourself in a revealing swimsuit, fresh from the pool with water droplets`,
        `Send me a picture of yourself in lace stockings and garter belt, sitting seductively on a chair`,
        `Send me a picture of yourself partially undressed, biting your finger with anticipation`,
        `Send me a picture of`
      ];

      // Seductive tag-specific scenarios
      const tagScenarios = isMale ? {
        'Boyfriend': [
          `Send me a picture of yourself shirtless on our bed with a passionate look, reaching out`,
          `Send me a picture of yourself wearing just your underwear, with a playful smile`,
          `Send me a picture of yourself fresh out of the shower in low towel, with a loving gaze`,
          `Send me a picture of yourself in fitted briefs stretching in our bedroom with desire`,
          `Send me a picture of yourself shirtless under the covers, inviting me to join you`
        ],
        'Romance': [
          `Send me a picture of yourself in unbuttoned shirt showing your chest, with intense desire`,
          `Send me a picture of yourself lying provocatively on rose petals with a sultry expression`,
          `Send me a picture of yourself in a candlelit room shirtless, with passionate eyes`,
          `Send me a picture of yourself in silk pants standing by a fireplace with yearning`,
          `Send me a picture of yourself in minimal clothing on a romantic four-poster bed, beckoning`
        ],
        'Handsome': [
          `Send me a picture of yourself in fitted underwear flexing, with a confident expression`,
          `Send me a picture of yourself in athletic shorts showing your abs, with a naughty look`,
          `Send me a picture of yourself sitting in just briefs with a tempting gaze`,
          `Send me a picture of yourself shirtless with tousled hair, with an adorable but sexy pose`,
          `Send me a picture of yourself in open robe showing your physique, with a seductive smile`
        ],
        'Seductive': [
          `Send me a picture of yourself in fitted black underwear, posing dominantly on a bed with a hungry gaze`,
          `Send me a picture of yourself shirtless touching your body, with an erotic stare`,
          `Send me a picture of yourself in minimal leather attire, commanding attention with intense eyes`,
          `Send me a picture of yourself in form-fitting briefs, with desire in your eyes`,
          `Send me a picture of yourself exuding raw masculine power with minimal clothing`
        ],
        'Fantasy': [
          `Send me a picture of yourself as a sexy warrior in minimal fantasy armor, posing powerfully`,
          `Send me a picture of yourself as a sultry sorcerer in revealing robes with magic swirling`,
          `Send me a picture of yourself as a mystical being shirtless with ethereal elements`,
          `Send me a picture of yourself as a warrior prince showing your physique, victorious and seductive`,
          `Send me a picture of yourself as a dark warlock in revealing attire, commanding power`
        ],
        'Boss': [
          `Send me a picture of yourself in a suit unbuttoned showing your chest, sitting on your desk in dominance`,
          `Send me a picture of yourself in revealing professional attire, commanding with lustful eyes`,
          `Send me a picture of yourself with shirt open leaning over your desk with authority`,
          `Send me a picture of yourself in just dress pants and open blazer, in your office chair with power`,
          `Send me a picture of yourself in business attire partially undressed, demanding attention`
        ]
      } : {
        'Girlfriend': [
          `Send me a picture of yourself in sexy lingerie on our bed with a passionate look, reaching out`,
          `Send me a picture of yourself wearing just my shirt and nothing else, with a playful smile`,
          `Send me a picture of yourself in your underwear, fresh out of the shower with a loving gaze`,
          `Send me a picture of yourself in a satin nightgown, stretching in our bedroom with desire`,
          `Send me a picture of yourself topless under the covers, inviting me to join you`
        ],
        'Romance': [
          `Send me a picture of yourself in a low-cut dress showing off your curves, with intense desire`,
          `Send me a picture of yourself lying provocatively on rose petals with a sultry expression`,
          `Send me a picture of yourself in a candlelit room wearing red lingerie, with passionate eyes`,
          `Send me a picture of yourself in a silk slip dress, standing by a fireplace with yearning`,
          `Send me a picture of yourself in lace underwear on a romantic four-poster bed, beckoning`
        ],
        'Cute': [
          `Send me a picture of yourself in innocent-looking but revealing underwear, biting your lip playfully`,
          `Send me a picture of yourself in a crop top and tiny shorts, stretching with a naughty expression`,
          `Send me a picture of yourself in knee-high socks and a bra, sitting cutely with temptation`,
          `Send me a picture of yourself in pigtails wearing just a thong, with an adorable but sexy pose`,
          `Send me a picture of yourself in oversized sweater that's slipping off, with a shy seductive smile`
        ],
        'Seductive': [
          `Send me a picture of yourself in black lace lingerie, posing dominantly on a bed with a hungry gaze`,
          `Send me a picture of yourself in a see-through negligee, touching yourself with an erotic stare`,
          `Send me a picture of yourself in leather lingerie, commanding attention with intense eyes`,
          `Send me a picture of yourself in a strappy bodysuit, crawling toward the camera with desire`,
          `Send me a picture of yourself in bondage-inspired lingerie, exuding raw sexual power`
        ],
        'Maid': [
          `Send me a picture of yourself in a skimpy maid outfit, bending over while cleaning with a naughty smile`,
          `Send me a picture of yourself in a revealing French maid costume in a submissive pose`,
          `Send me a picture of yourself in a wet maid uniform, on your knees scrubbing with a teasing look`,
          `Send me a picture of yourself in a tiny maid dress lifting your skirt, showing off with a blush`,
          `Send me a picture of yourself in maid lingerie with feather duster, posing provocatively`
        ],
        'Fantasy': [
          `Send me a picture of yourself as a sexy elf in barely-there fantasy armor, posing erotically`,
          `Send me a picture of yourself as a sultry sorceress in revealing robes with magic swirling`,
          `Send me a picture of yourself as a mystical fairy in sheer wings and minimal clothing, enchanting`,
          `Send me a picture of yourself as a warrior princess in chain mail bikini, victorious and seductive`,
          `Send me a picture of yourself as a dark enchantress in revealing gothic attire, casting spells`
        ],
        'Angel': [
          `Send me a picture of yourself as a fallen angel in torn lingerie, wings spread seductively`,
          `Send me a picture of yourself with angel wings in white underwear, in a passionate divine pose`,
          `Send me a picture of yourself as a heavenly being in sheer robes, bathed in holy light with desire`,
          `Send me a picture of yourself with golden wings wearing minimal white lace, radiating beauty`,
          `Send me a picture of yourself as a tempting angel in revealing celestial garments, inviting sin`
        ],
        'Monster': [
          `Send me a picture of yourself with your monster features in revealing leather, posing dominantly`,
          `Send me a picture of yourself showing your supernatural side in minimal clothing, irresistibly seductive`,
          `Send me a picture of yourself as a demon in skimpy dark attire, with horns and a wicked smile`,
          `Send me a picture of yourself as a succubus in bondage-style lingerie, exuding dangerous allure`,
          `Send me a picture of yourself with vampire fangs in gothic lingerie, hungry and predatory`
        ],
        'Boss': [
          `Send me a picture of yourself in a tight suit unbuttoned, sitting on your desk in sexual dominance`,
          `Send me a picture of yourself in revealing professional attire, commanding with lustful eyes`,
          `Send me a picture of yourself in a pencil skirt hiked up, leaning over your desk with authority`,
          `Send me a picture of yourself in just a blazer and lingerie, in your office chair with power`,
          `Send me a picture of yourself in stockings and heels with glasses, demanding obedience sexually`
        ],
        'Student': [
          `Send me a picture of yourself in a sexy schoolgirl outfit on a desk with a flirtatious look`,
          `Send me a picture of yourself in a revealing school uniform, posing suggestively after class`,
          `Send me a picture of yourself in a short plaid skirt and unbuttoned shirt, biting a pencil`,
          `Send me a picture of yourself in knee-high socks and minimal uniform, studying seductively`,
          `Send me a picture of yourself in detention attire that's revealing, with a rebellious smirk`
        ],
        'Teacher': [
          `Send me a picture of yourself in a tight teacher outfit leaning over a desk showing your assets`,
          `Send me a picture of yourself in professional attire, pointing with a stern but sexually charged look`,
          `Send me a picture of yourself in glasses and revealing teacher clothes, at the blackboard`,
          `Send me a picture of yourself in a button-up shirt undone, sitting on your desk with authority`,
          `Send me a picture of yourself in stockings and garter with ruler, disciplining with desire`
        ]
      };

      // No art style additions - backend handles this
      const artStyleAdditions = {
        'anime': '',
        'realistic': ''
      };

      // Build suggestions array - use uncensored scenarios if mode is enabled
      let suggestions = isUncensored ? [...uncensoredScenarios] : [...baseScenarios];

      // Add tag-specific suggestions (only for censored mode, uncensored uses base only)
      if (!isUncensored) {
        tags.forEach(tag => {
          if (tagScenarios[tag]) {
            suggestions.push(...tagScenarios[tag]);
          }
        });
      }

      // Define open-ended prompt BEFORE adding style modifiers
      const openEndedPromptBase = 'Send me a picture of';

      // Add art style modifier to all suggestions
      const styleModifier = artStyleAdditions[artStyle] || '';
      suggestions = suggestions.map(suggestion => suggestion + styleModifier);

      // The open-ended prompt after style modifier is applied (which is empty string, so same)
      const openEndedPrompt = openEndedPromptBase + styleModifier;

      // Store all suggestions if first time
      if (allAvailableSuggestions.length === 0) {
        allAvailableSuggestions = [...suggestions];
      }

      // Get suggestions that haven't been used yet
      const availableSuggestions = suggestions.filter(s => !usedSuggestions.has(s));

      // If we've used all suggestions, reset the used set but keep the last few to avoid immediate repeats
      if (availableSuggestions.filter(s => s !== openEndedPrompt).length < 2) {
        console.log('🔄 Resetting used suggestions, keeping last 2 to avoid immediate repeats');
        const recentSuggestions = Array.from(usedSuggestions).slice(-2);
        usedSuggestions.clear();
        recentSuggestions.forEach(s => usedSuggestions.add(s));

        // Re-filter
        const freshSuggestions = suggestions.filter(s => !usedSuggestions.has(s) && s !== openEndedPrompt);
        const shuffled = shuffleArray(freshSuggestions);
        const selected = shuffled.slice(0, 2);

        // Always add the open-ended prompt as 3rd option
        selected.push(openEndedPrompt);

        // Mark as used (except open-ended)
        selected.filter(s => s !== openEndedPrompt).forEach(s => usedSuggestions.add(s));
        return selected;
      }

      // Shuffle and select 2 unused suggestions + always include the open-ended one
      const otherSuggestions = availableSuggestions.filter(s => s !== openEndedPrompt);
      const shuffled = shuffleArray(otherSuggestions);
      const selected = shuffled.slice(0, 2);

      // Always add the open-ended prompt as 3rd option
      selected.push(openEndedPrompt);

      // Mark selected suggestions as used (except the open-ended one, keep it available)
      selected.filter(s => s !== openEndedPrompt).forEach(s => usedSuggestions.add(s));

      console.log(`🎲 Selected ${selected.length} new suggestions:`, selected);
      console.log(`📝 Open-ended prompt: "${openEndedPrompt}"`);
      console.log(`<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg> All suggestions (${suggestions.length}):`, suggestions);
      console.log(`✅ ${usedSuggestions.size} total used`);
      return selected;
    }

    // Show image prompt suggestions
    async function showImagePromptSuggestions() {
      if (!currentCharacter || !currentCharacter.name) return;

      const isUncensored = localStorage.getItem('unfilteredMode') === 'true';
      const suggestionContainer = document.getElementById('suggestionButtons');
      const suggestionsDiv = document.getElementById('imagePromptSuggestions');

      if (!suggestionContainer || !suggestionsDiv) return;

      // Check user permissions
      const permissions = await checkUserImagePermissions();

      // Clear existing suggestions
      suggestionContainer.innerHTML = '';

      if (!permissions.canGenerate) {
        // Show upgrade notice instead of suggestions
        const upgradeNotice = document.createElement('div');
        upgradeNotice.className = 'image-upgrade-notice';
        upgradeNotice.innerHTML = `
          <div class="upgrade-notice-content">
            <span class="upgrade-notice-icon">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
              </svg>
            </span>
            <div class="upgrade-notice-text">
              <div class="upgrade-notice-title">${permissions.plan === 'Guest' ? 'Login Required' : 'Upgrade Required'}</div>
              <div class="upgrade-notice-subtitle">${permissions.plan === 'Guest' ? 'Sign up to generate images' : 'Image generation requires Basic plan or higher'}</div>
            </div>
            <button class="upgrade-notice-btn" onclick="showImageUpgradeModal(${JSON.stringify(permissions).replace(/"/g, '&quot;')})">
              ${permissions.plan === 'Guest' ? 'Sign Up' : 'Upgrade'}
            </button>
          </div>
        `;
        suggestionContainer.appendChild(upgradeNotice);
      } else {
        // Show plan info
        const planInfo = document.createElement('div');
        planInfo.className = 'image-plan-info';
        const usingCredits = permissions.usingCredits || permissions.imageCreditsRemaining > 0;
        const creditsText = usingCredits ? ' credits' : '';
        const imageText = (permissions.remaining === 1 && !usingCredits) ? 'image' : 'images';
        planInfo.innerHTML = `
          <span class="plan-badge">${permissions.plan} Plan</span>
          <span class="plan-remaining">${permissions.remaining || 0}${creditsText} ${imageText} left</span>
        `;
        suggestionContainer.appendChild(planInfo);

        // UNCENSORED MODE: Show pose & outfit selectors
        if (isUncensored) {
          // Set gender-specific pose/outfit arrays
          const isMale = (currentCharacter.sex || currentCharacter.Sex || currentCharacter.Gender || '').toLowerCase() === 'male';
          NSFW_POSES = isMale ? NSFW_POSES_MALE : NSFW_POSES_FEMALE;
          NSFW_OUTFITS = isMale ? NSFW_OUTFITS_MALE : NSFW_OUTFITS_FEMALE;

          const selectorContainer = document.createElement('div');
          selectorContainer.className = 'pose-outfit-selector';

          // Pose selector
          const poseSection = document.createElement('div');
          poseSection.className = 'selector-section';
          poseSection.innerHTML = `
            <div class="selector-label">Select Pose:</div>
            <div class="selector-buttons" id="poseButtons"></div>
          `;
          selectorContainer.appendChild(poseSection);

          // Outfit selector
          const outfitSection = document.createElement('div');
          outfitSection.className = 'selector-section';
          outfitSection.innerHTML = `
            <div class="selector-label">Select Outfit:</div>
            <div class="selector-buttons" id="outfitButtons"></div>
          `;
          selectorContainer.appendChild(outfitSection);

          // Generate button (BOTTOM, sticky for visibility)
          const generateBtn = document.createElement('button');
          generateBtn.className = 'generate-image-btn';
          generateBtn.textContent = 'Generate Image';
          generateBtn.disabled = true;
          generateBtn.onclick = () => generateImageFromSelectors();
          selectorContainer.appendChild(generateBtn);

          suggestionContainer.appendChild(selectorContainer);

          // Populate pose buttons
          const poseButtonsContainer = document.getElementById('poseButtons');
          NSFW_POSES.forEach(pose => {
            const btn = document.createElement('button');
            btn.className = 'selector-btn';
            btn.textContent = pose.label;
            btn.onclick = () => selectPose(pose.id);
            poseButtonsContainer.appendChild(btn);
          });

          // Populate outfit buttons
          const outfitButtonsContainer = document.getElementById('outfitButtons');
          NSFW_OUTFITS.forEach(outfit => {
            const btn = document.createElement('button');
            btn.className = 'selector-btn';
            btn.textContent = outfit.label;
            btn.onclick = () => selectOutfit(outfit.id);
            outfitButtonsContainer.appendChild(btn);
          });

        } else {
          // CENSORED MODE: Show original suggestion buttons
          const suggestions = generateImagePromptSuggestions(currentCharacter);
          suggestions.forEach(suggestion => {
            const button = document.createElement('button');
            button.className = 'suggestion-button';
            button.textContent = suggestion;
            button.onclick = () => useSuggestion(suggestion);
            suggestionContainer.appendChild(button);
          });
        }
      }

      // Show suggestions
      suggestionsDiv.classList.add('visible');
    }

    // Select pose for NSFW image generation
    function selectPose(poseId) {
      selectedPose = poseId;

      // Update button styles
      document.querySelectorAll('#poseButtons .selector-btn').forEach(btn => {
        btn.classList.remove('selected');
      });
      event.target.classList.add('selected');

      // Enable generate button if both selected
      updateGenerateButton();
    }

    // Select outfit for NSFW image generation
    function selectOutfit(outfitId) {
      selectedOutfit = outfitId;

      // Update button styles
      document.querySelectorAll('#outfitButtons .selector-btn').forEach(btn => {
        btn.classList.remove('selected');
      });
      event.target.classList.add('selected');

      // Enable generate button if both selected
      updateGenerateButton();
    }

    // Update generate button state
    function updateGenerateButton() {
      const generateBtn = document.querySelector('.generate-image-btn');
      if (generateBtn) {
        generateBtn.disabled = !(selectedPose && selectedOutfit);
      }
    }

    // Generate image from selected pose & outfit
    async function generateImageFromSelectors() {
      if (!selectedPose || !selectedOutfit) {
        alert('Please select both a pose and outfit');
        return;
      }

      // Find selected pose and outfit
      const pose = NSFW_POSES.find(p => p.id === selectedPose);
      const outfit = NSFW_OUTFITS.find(o => o.id === selectedOutfit);

      if (!pose || !outfit) {
        console.error('❌ Invalid pose or outfit selection');
        return;
      }

      // Build prompt from pose + outfit (match the "Send me a picture" format)
      const combinedPrompt = `Send me a picture ${pose.prompt}, ${outfit.prompt}`;
      console.log('🎨 Generated prompt from selectors:', combinedPrompt);

      // Put prompt in message input and trigger send
      const messageInput = document.getElementById('messageInput');
      if (messageInput) {
        messageInput.value = combinedPrompt;
        autoResizeTextarea();

        // Hide suggestions
        hideImagePromptSuggestions();

        // Trigger send button click to generate image
        const sendButton = document.getElementById('sendButton') || document.querySelector('[onclick*="sendMessage"]');
        if (sendButton) {
          sendButton.click();
        }
      }

      // Reset selections
      selectedPose = null;
      selectedOutfit = null;
    }

    // Hide image prompt suggestions
    function hideImagePromptSuggestions() {
      const suggestionsDiv = document.getElementById('imagePromptSuggestions');
      if (suggestionsDiv) {
        suggestionsDiv.classList.remove('visible');
      }
    }

    // Update only the plan info in image suggestions (used after image generation)
    async function updateImageSuggestionsPlan() {
      const planRemainingElement = document.querySelector('.plan-remaining');
      if (!planRemainingElement) {
        console.log('🔄 No plan-remaining element found, suggestions not visible');
        return;
      }

      try {
        console.log('🔄 Updating image plan counter...');
        // Force fresh fetch AND invalidate cache to get updated count
        imagePermissionsCache = null;
        imagePermissionsCacheTime = 0;
        console.log('♻️ Cache invalidated for fresh counter update');
        const permissions = await checkUserImagePermissions(false);
        const usingCredits = permissions.usingCredits || permissions.imageCreditsRemaining > 0;
        const creditsText = usingCredits ? ' credits' : '';
        const imageText = (permissions.remaining === 1 && !usingCredits) ? 'image' : 'images';
        planRemainingElement.textContent = `${permissions.remaining || 0}${creditsText} ${imageText} left`;
        console.log('✅ Updated image counter:', permissions.remaining, creditsText);
      } catch (error) {
        console.warn('⚠️ Failed to update image plan counter:', error);
      }
    }

    // Use a suggestion (put it in the input field)
    function useSuggestion(suggestion) {
      const messageInput = document.getElementById('messageInput');
      if (messageInput) {
        messageInput.value = suggestion;
        messageInput.focus();
        autoResizeTextarea();
      }
      hideImagePromptSuggestions();
    }

    function autoResizeTextarea() {
      const textarea = document.getElementById('messageInput');
      textarea.style.height = 'auto';
      textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
    }

    function handleKeyDown(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    }

    function updateCharacterDisplay() {
      // Update header
      document.getElementById('currentCharacterName').textContent = currentCharacter.name;
      document.getElementById('currentCharacterStatus').textContent = currentCharacter.creator;
      const headerImage = document.getElementById('characterImage');
      if (headerImage) {
        if (currentCharacter.avatar && currentCharacter.avatar !== '/avatars/placeholder.webp') {
          console.log('🖼️ Setting header avatar:', currentCharacter.avatar);
          headerImage.src = fixAvatarUrl(currentCharacter.avatar);
          headerImage.style.display = 'block';
          headerImage.onerror = function() {
            console.warn('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Header avatar failed to load:', currentCharacter.avatar);
            this.src = '/avatars/default-avatar.webp';
            this.style.display = 'block';
            // Update currentCharacter.avatar to the fallback for modal functionality
            if (currentCharacter) {
              currentCharacter.avatar = '/avatars/default-avatar.webp';
            }
          };
        } else {
          console.warn('⚠️ No header avatar URL, using default');
          headerImage.src = '/avatars/default-avatar.webp';
          headerImage.style.display = 'block';
        }
      }
      
      // Update sidebar
      document.getElementById('sidebarCharacterName').textContent = currentCharacter.name;
      document.getElementById('sidebarCharacterCreator').textContent = currentCharacter.creator;
      const cleanDesc = cleanDescription(currentCharacter.description) || currentCharacter.description || '';
      document.getElementById('sidebarCharacterDescription').innerHTML = cleanDesc.replace(/\\n\\n/g, '<br><br>').replace(/\\n/g, '<br>');
      // Initialize image carousel
      initializeCarousel();

      const sidebarImage = document.getElementById('sidebarCharacterImage');
      if (sidebarImage) {
        if (currentCharacter.avatar && currentCharacter.avatar !== '/avatars/placeholder.webp') {
          console.log('🖼️ Setting sidebar avatar:', currentCharacter.avatar);
          sidebarImage.src = fixAvatarUrl(currentCharacter.avatar);
          sidebarImage.style.display = 'block';
          sidebarImage.onerror = function() {
            console.warn('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Sidebar avatar failed to load:', currentCharacter.avatar);
            this.src = '/avatars/default-avatar.webp';
            this.style.display = 'block';
          };
        } else {
          console.warn('⚠️ No sidebar avatar URL, using default');
          sidebarImage.src = '/avatars/default-avatar.webp';
          sidebarImage.style.display = 'block';
        }
      }
      // Update chat count with actual message count
      const messageCount = getMessageCount(currentCharacter.slug);
      document.getElementById('sidebarCharacterChats').textContent = messageCount > 0 ? messageCount : '0';
      
      // Update tags
      const tagsContainer = document.getElementById('sidebarCharacterTags');
      if (tagsContainer && currentCharacter.tags) {
        tagsContainer.innerHTML = currentCharacter.tags.map(tag =>
          `<span class="character-tag">${tag}</span>`
        ).join('');
      }

      // Hide any existing suggestions when character changes
      hideImagePromptSuggestions();

      // Make avatars clickable
      makeAvatarsClickable();
    }

    function showCharacterSearch() {
      document.getElementById('searchModal').classList.add('open');
      document.getElementById('characterSearch').focus();
    }

    function closeCharacterSearch() {
      document.getElementById('searchModal').classList.remove('open');
    }

    function selectCharacter(slug) {
      // Update character based on selection
      // This would normally fetch from API
      console.log('Selected character:', slug);
      closeCharacterSearch();
    }

    async function sendMessage() {
      const messageInput = document.getElementById('messageInput');
      const message = messageInput.value.trim();

      if (!message) return;

      // Check authentication first
      const isAuthenticated = window.isUserAuthenticated ? window.isUserAuthenticated() : false;
      const user = window.getCurrentUser ? window.getCurrentUser() : null;

      if (!isAuthenticated || !user) {
        // Show signup modal directly (which has login link at bottom)
        console.log('🔒 User not authenticated, showing signup modal');

        // Open the signup modal directly
        if (window.openLoginModal) {
          window.openLoginModal('signup');
        } else {
          // Fallback if auth system not loaded yet
          console.error('Auth system not ready, showing fallback message');
          alert('Please sign up or login to chat with AI companions on Selira AI.');
        }

        // Clear the input
        messageInput.value = '';
        autoResizeTextarea();
        return;
      }

      // Check if this is an image request (multiple patterns)
      const lowerMessage = message.toLowerCase();
      const imageRequestPatterns = [
        'send me a picture',
        'send me a pic',
        'show me a picture',
        'show me a pic',
        'can you send',
        'make a picture',
        'create a picture',
        'generate a picture',
        'take a picture',
        'send a picture',
        'send a pic',
        'picture of you',
        'pic of you',
        'photo of you',
        'selfie'
      ];

      const isImageRequest = imageRequestPatterns.some(pattern => lowerMessage.includes(pattern));

      if (isImageRequest) {
        // Check if it starts with "send me a picture" - if so, use the existing flow
        if (lowerMessage.startsWith('send me a picture')) {
          messageInput.value = '';
          autoResizeTextarea();
          await handleImageRequest(message);
          return;
        }

        // Otherwise, show a helpful message directing to Image Gen button
        messageInput.value = '';
        autoResizeTextarea();
        addMessage(message, 'user');

        // Add helpful AI response with Image Gen button
        const helpMessage = document.createElement('div');
        helpMessage.className = 'message ai';
        helpMessage.innerHTML = `
          <div class="message-content">
            <div class="message-text">
              <div style="margin-bottom: 12px;">I'd love to send you a picture! <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg></div>
              <div style="margin-bottom: 12px;">Click the <strong>+ Image Gen</strong> button below to generate an image of me. You can choose from suggestions or type exactly what you want to see!</div>
              <div style="margin-top: 16px;">
                <button onclick="document.getElementById('imageGenBtn').click()" style="
                  background: var(--accent);
                  color: white;
                  border: none;
                  padding: 10px 20px;
                  border-radius: 20px;
                  font-size: 14px;
                  font-weight: 600;
                  cursor: pointer;
                  box-shadow: 0 2px 8px rgba(139, 92, 246, 0.3);
                ">
                  Open Image Gen ✨
                </button>
              </div>
            </div>
            <div class="message-time">${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</div>
          </div>
        `;
        document.getElementById('chatMessages').appendChild(helpMessage);
        document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;

        // Save both messages to localStorage
        saveUserMessageToStorage(currentCharacter.slug, message);
        const aiMessageContent = "I'd love to send you a picture! Click the + Image Gen button below to generate an image of me.";
        saveAIMessageToStorage(currentCharacter.slug, aiMessageContent);

        return;
      }

      // Add user message
      addMessage(message, 'user');
      messageInput.value = '';
      autoResizeTextarea();

      // User message will be saved together with AI response

      // Show typing indicator
      const typingIndicator = addTypingIndicator();

      try {
        // Use authenticated user data (support both Supabase and Auth0)
        const user_id = user.id || user.sub || user.uid || user.auth0_id; // Supabase uses .id, Auth0 uses .sub
        const user_email = user.email;

        console.log('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg> Authenticated user:', {
          user_id: user_id,
          email: user_email
        });

        // Memory sync for authenticated users
        console.log('🧠 Memory sync enabled - loading memories...');
        await loadMemoriesForContext(currentCharacter.slug, user_id);

        // Get chat history for context
        const chatHistory = getChatHistoryForContext(currentCharacter.slug);

        // Call OpenRouter chat API
        const unfilteredMode = localStorage.getItem('unfilteredMode') === 'true';
        console.log('🤖 Sending message to AI:', {
          character: currentCharacter.slug,
          user_id: user_id,
          message: message.substring(0, 50) + '...',
          history_length: chatHistory.length,
          mode: unfilteredMode ? 'UNCENSORED 🔓' : 'CENSORED 🔒'
        });

        const response = await fetch('/.netlify/functions/selira-openrouter-chat', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            message: message,
            character_slug: currentCharacter.slug,
            user_id: user_id, // Changed from auth0_id to support both Supabase and Auth0
            user_email: user_email,
            model: 'mistralai/mistral-nemo',
            local_history: chatHistory, // Send localStorage history for context
            memories: window.currentMemories || [], // Send loaded memories for AI context
            unfiltered: localStorage.getItem('unfilteredMode') === 'true' // Send unfiltered mode state
          })
        });
        
        if (!response.ok) {
          throw new Error(`API Error: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('✅ Received AI response:', data.response?.substring(0, 100) + '...');
        console.log('🤖 Model used:', data.model_used);
        console.log('💾 Saved to DB:', data.saved_to_db);
        
        // Remove typing indicator
        typingIndicator.remove();
        
        // Add AI response (clean, without debug info)
        const responseText = data.response || "I'm having trouble responding right now. Please try again!";
        addMessage(responseText, 'ai');
        
        // Save both user and AI message to localStorage
        saveBothMessagesToStorage(currentCharacter.slug, message, data.response);

        // Update chat count in sidebar
        const updatedMessageCount = getMessageCount(currentCharacter.slug);
        document.getElementById('sidebarCharacterChats').textContent = updatedMessageCount;

        // Update sidebar to reflect new activity
        updateActiveChatsSidebar();
        
        // Memory saving re-enabled now that functions are working
        console.log('🧠 Memory saving enabled - saving important memories...');
        await saveMemoryIfImportant(currentCharacter.slug, message, data.response, user_id);
        
      } catch (error) {
        console.error('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Error sending message:', error);
        
        // Remove typing indicator
        if (typingIndicator && typingIndicator.parentNode) {
          typingIndicator.remove();
        }
        
        // Add error message with more detail
        addMessage(`I'm having trouble connecting right now (${error.message}). Please try again in a moment!`, 'ai');
      }
    }

    // Debug function to test OpenRouter API
    async function testOpenRouterAPI() {
      try {
        // Get current user data for test
        const user = window.getCurrentUser();
        const testAuth0Id = user?.sub || 'anonymous';
        const testEmail = user?.email || 'anonymous';
        const testCharSlug = currentCharacter?.slug || 'orion-nightfall';

        console.log('🧪 Testing with:', { testCharSlug, testEmail });

        const response = await fetch('/.netlify/functions/selira-openrouter-chat', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            message: 'Hello, how are you?',
            character_slug: testCharSlug,
            auth0_id: testAuth0Id,
            user_email: testEmail,
            model: 'mistralai/mistral-nemo'
          })
        });
        
        console.log('🧪 Test API Response Status:', response.status);
        const data = await response.text();
        console.log('🧪 Test API Response:', data);
        
      } catch (error) {
        console.error('🧪 Test API Error:', error);
      }
    }

    // Auto-test API disabled - uncomment to debug
    // setTimeout(testOpenRouterAPI, 2000);

    // Load chat history for current character
    async function loadChatHistory(characterSlug) {
      try {
        const user = JSON.parse(localStorage.getItem('user') || '{}');
        const auth0_id = user.sub || user.auth0_id || user.email || 'anonymous';
        
        // Skip for anonymous users
        if (auth0_id === 'anonymous') {
          console.log('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg> Anonymous user - no chat history to load');
          return;
        }
        
        console.log('📚 Loading chat history for:', characterSlug);
        
        const response = await fetch('/.netlify/functions/get-chat-history-selira', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            auth0_id: auth0_id,
            character_slug: characterSlug,
            limit: 20
          })
        });
        
        if (response.ok) {
          const data = await response.json();
          if (data.success && data.messages && data.messages.length > 0) {
            console.log('✅ Loaded', data.messages.length, 'previous messages');
            displayChatHistory(data.messages);
          } else {
            console.log('💭 No previous chat history found');
          }
        } else {
          console.log('⚠️ Failed to load chat history:', response.status);
        }
        
      } catch (error) {
        console.error('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Error loading chat history:', error);
      }
    }

    // Display loaded chat history
    function displayChatHistory(messages) {
      const messagesContainer = document.getElementById('chatMessages');
      
      // Clear existing messages
      messagesContainer.innerHTML = '';
      
      messages.forEach(msg => {
        const sender = msg.MessageType === 'user' ? 'user' : 'ai';
        addMessage(msg.Content, sender, false); // false = don't scroll to bottom yet
      });
      
      // Scroll to bottom after all messages loaded
      setTimeout(() => {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }, 100);
    }

    // Save both messages to localStorage (prevents duplicates)
    function saveBothMessagesToStorage(characterSlug, userMessage, aiResponse) {
      try {
        const storageKey = `chat_${characterSlug}`;
        let chatHistory = JSON.parse(localStorage.getItem(storageKey) || '[]');
        
        // Add user message
        chatHistory.push({
          type: 'user',
          content: userMessage,
          timestamp: Date.now()
        });
        
        // Add AI response 
        chatHistory.push({
          type: 'ai', 
          content: aiResponse,
          timestamp: Date.now() + 1 // Slightly after user message
        });
        
        // Keep only last 50 messages
        chatHistory = chatHistory.slice(-50);
        
        localStorage.setItem(storageKey, JSON.stringify(chatHistory));
        console.log('💾 Saved conversation to localStorage:', characterSlug, chatHistory.length, 'messages');
        
      } catch (error) {
        console.error('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Error saving to localStorage:', error);
      }
    }

    // Save chat to localStorage for persistence (legacy function - use saveBothMessagesToStorage)
    function saveChatToStorage(characterSlug, userMessage, aiResponse) {
      // This function is kept for compatibility but shouldn't create duplicates
      console.log('⚠️ Legacy save function called - use saveBothMessagesToStorage instead');
    }

    // Track which characters have had their greeting added in this session
    let greetingAddedFor = new Set();

    // Track if character was already loaded from URL to prevent double loading
    let characterLoadedFromURL = false;

    // Load chat history from localStorage
    function loadChatHistoryFromStorage(characterSlug) {
      try {
        // Clean up duplicates first
        const chatHistory = cleanupChatHistory(characterSlug);
        
        if (chatHistory.length > 0) {
          console.log('📚 Loading', chatHistory.length, 'clean messages from localStorage for:', characterSlug);
          console.log('📦 First message preview:', chatHistory[0]);
          
          const messagesContainer = document.getElementById('chatMessages');
          messagesContainer.innerHTML = '';
          
          chatHistory.forEach(msg => {
            if (msg.type === 'image') {
              // Handle image messages
              const imageData = msg.content;
              addImageMessage(imageData.imageUrl, imageData.prompt, imageData.style, false);
            } else {
              // Handle regular text messages
              addMessage(msg.content, msg.type, false);
            }
          });
          
          setTimeout(() => {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
          }, 100);
          
        } else {
          console.log('💭 No chat history in localStorage for:', characterSlug);
          console.log('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg> Checking localStorage keys:', Object.keys(localStorage).filter(k => k.startsWith('chat_')));

          // Add automatic greeting message for new chats (only once per session)
          let character = allCharacters.find(c => c.slug === characterSlug);

          // If not in allCharacters, use currentCharacter if it matches the slug
          if (!character && currentCharacter?.slug === characterSlug) {
            character = currentCharacter;
          }

          if (character && !greetingAddedFor.has(characterSlug)) {
            // Try to extract greeting from description first, otherwise generate random greeting
            let greeting = null;

            if (character.description) {
              greeting = extractGreetingFromDescription(character.description);
            }

            // If no greeting found in description, generate random greeting
            if (!greeting) {
              greeting = generateGreetingForNewCharacter(character);
            }

            if (greeting) {
              console.log('👋 Adding automatic greeting for new chat with:', character.name);
              greetingAddedFor.add(characterSlug);
              // Clear any existing messages first
              const messagesContainer = document.getElementById('chatMessages');
              messagesContainer.innerHTML = '';
              // First add avatar image message
              if (character.avatar && character.avatar !== '/avatars/placeholder.webp') {
                addAvatarMessage(character.avatar);
              }

              // Then add the greeting message after a short delay
              setTimeout(() => {
                addMessage(greeting, 'ai', false);
              }, 200);

              // Save greeting to localStorage so it doesn't reappear
              const storageKey = `chat_${characterSlug}`;
              let chatHistory = JSON.parse(localStorage.getItem(storageKey) || '[]');
              chatHistory.push({
                type: 'ai',
                content: greeting,
                timestamp: Date.now()
              });
              localStorage.setItem(storageKey, JSON.stringify(chatHistory));
            }
          }
        }
        
      } catch (error) {
        console.error('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Error loading from localStorage:', error);
      }
    }


    // Get chat history for AI context (last 10 messages)
    function getChatHistoryForContext(characterSlug) {
      try {
        // Get cleaned history
        const fullHistory = cleanupChatHistory(characterSlug);
        
        // Get last 10 messages for context (exclude current message being sent)
        const contextHistory = fullHistory.slice(-10).map(msg => {
          if (msg.type === 'image') {
            // Convert image messages to text for AI context
            return {
              role: 'assistant',
              content: `I generated an image for you: "${msg.content.prompt}" in ${msg.content.style} style.`
            };
          } else {
            return {
              role: msg.type === 'user' ? 'user' : 'assistant',
              content: msg.content
            };
          }
        });
        
        console.log('🧠 Sending context history:', contextHistory.length, 'messages');
        return contextHistory;
        
      } catch (error) {
        console.error('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Error getting context history:', error);
        return [];
      }
    }

    function addMessage(content, sender, autoScroll = true) {
      const messagesContainer = document.getElementById('chatMessages');
      const welcomeMessage = messagesContainer.querySelector('.welcome-message');
      
      if (welcomeMessage) {
        welcomeMessage.remove();
      }
      
      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${sender}`;
      
      if (sender === 'ai') {
        messageDiv.innerHTML = `
          <div class="message-avatar">
            <img src="${fixAvatarUrl(currentCharacter.avatar)}" alt="${currentCharacter.name}" onerror="this.style.display='none'">
          </div>
          <div class="message-content">${content}</div>
        `;
      } else {
        messageDiv.innerHTML = `
          <div class="message-content">${content}</div>
        `;
      }
      
      messagesContainer.appendChild(messageDiv);
      
      if (autoScroll) {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }
    }

    function clearChat() {
      // Clear chat from UI
      const messagesContainer = document.getElementById('chatMessages');
      messagesContainer.innerHTML = `
        <div class="welcome-message" style="text-align: center; padding: 40px 20px; color: var(--text-secondary);">
          <div style="font-size: 48px; margin-bottom: 16px;">💭</div>
          <h3 style="color: var(--text-primary); margin-bottom: 8px;">Chat Cleared</h3>
          <p>Start a new conversation with ${currentCharacter.name}!</p>
        </div>
      `;
      
      // Clear chat history from localStorage
      if (currentCharacter.slug) {
        const storageKey = `chat_${currentCharacter.slug}`;
        localStorage.removeItem(storageKey);
        console.log('🗑️ Cleared chat history for:', currentCharacter.slug);

        // Update sidebar after clearing
        updateActiveChatsSidebar();
      }
    }

    // Delete modal functions
    function showDeleteOptions() {
      const modal = document.getElementById('deleteModal');
      if (modal) {
        modal.style.display = 'flex';
        document.body.style.overflow = 'hidden'; // Prevent background scrolling
      }
    }

    function closeDeleteModal() {
      const modal = document.getElementById('deleteModal');
      if (modal) {
        modal.style.display = 'none';
        document.body.style.overflow = ''; // Restore scrolling
      }
    }

    function deleteCompanion() {
      // Use the existing clearChat function
      clearChat();
      closeDeleteModal();
    }

    // Close modal when clicking outside of it
    document.addEventListener('DOMContentLoaded', function() {
      const modal = document.getElementById('deleteModal');
      if (modal) {
        modal.addEventListener('click', function(e) {
          if (e.target === modal) {
            closeDeleteModal();
          }
        });
      }
    });

    // Clean up duplicate messages in localStorage
    function cleanupChatHistory(characterSlug) {
      try {
        const storageKey = `chat_${characterSlug}`;
        const rawHistory = JSON.parse(localStorage.getItem(storageKey) || '[]');
        
        // Remove consecutive duplicates
        const cleanHistory = [];
        let lastMessage = null;
        
        rawHistory.forEach(msg => {
          if (!lastMessage || 
              lastMessage.content !== msg.content || 
              lastMessage.type !== msg.type) {
            cleanHistory.push(msg);
            lastMessage = msg;
          }
        });
        
        if (cleanHistory.length !== rawHistory.length) {
          localStorage.setItem(storageKey, JSON.stringify(cleanHistory));
          console.log('🧹 Cleaned chat history:', rawHistory.length, '→', cleanHistory.length);
        }
        
        return cleanHistory;
        
      } catch (error) {
        console.error('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Error cleaning chat history:', error);
        return [];
      }
    }

    // Simple toggle sidebar - matches index.html pattern
    function toggleSidebar() {
      console.log('🍔 toggleSidebar called!');
      const sidebar = document.getElementById('sidebar');
      const overlay = document.getElementById('sidebarOverlay');

      console.log('🍔 Sidebar:', sidebar);
      console.log('🍔 Overlay:', overlay);

      if (sidebar && overlay) {
        sidebar.classList.toggle('open');
        overlay.classList.toggle('open');
        console.log('🍔 After toggle - sidebar classes:', sidebar.className);
        console.log('🍔 After toggle - overlay classes:', overlay.className);
      } else {
        console.error('❌ Sidebar or overlay not found!', {sidebar, overlay});
      }
    }

    // Make it globally available
    window.toggleSidebar = toggleSidebar;

    // Setup event listeners after DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      console.log('🍔 Setting up mobile menu event listeners...');

      // Close sidebar when clicking overlay
      const overlay = document.getElementById('sidebarOverlay');
      if (overlay) {
        overlay.addEventListener('click', function() {
          console.log('🍔 Overlay clicked');
          toggleSidebar();
        });
        console.log('✅ Overlay click handler added');
      }

      // Close sidebar when clicking on any link/chat item inside it on mobile
      const sidebar = document.getElementById('sidebar');
      if (sidebar) {
        sidebar.addEventListener('click', function(event) {
          // If clicked element is a link or chat item, close the sidebar on mobile
          if ((event.target.tagName === 'A' || event.target.closest('.chat-item')) && window.innerWidth <= 768) {
            console.log('🍔 Sidebar item clicked on mobile, closing...');
            toggleSidebar();
          }
        });
        console.log('✅ Sidebar click handler added');
      }
    });

    // Mobile menu is now handled purely by CSS media queries
    // No need for JavaScript resize handling

    // ===== DATABASE INTEGRATION =====
    async function loadCharactersFromDatabase() {
      try {
        console.log('📡 Loading characters from database...');
        const response = await fetch('/.netlify/functions/selira-characters-fetch');
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.success && data.characters) {
          const characters = data.characters.map(char => ({
            id: char.Character_ID || char.Name,
            name: char.Name || 'Unknown',
            title: char.Character_Title || '',
            description: char.Character_Description || '',
            avatar: char.Avatar_URL ? char.Avatar_URL.replace('narrin.ai', 'selira.ai') : null,
            category: char.Category || 'Other',
            slug: char.Slug || (char.Name ? char.Name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '') : 'unknown'),
            creator: char.Nickname || 'Selira',
            tags: Array.isArray(char.Tags) ? char.Tags.slice(0, 11) : (char.Tags || '').toString().split(',').filter(Boolean).slice(0, 11), // Get real tags
            character_url: char.Character_URL ? char.Character_URL.replace('narrin.ai', 'selira.ai') : null,
            // Add appearance data - support both lowercase and capitalized field names
            companion_type: char.companion_type || char.Companion_Type || char['Companion Type'],
            sex: char.sex || char.Sex || char.Gender,
            ethnicity: char.ethnicity || char.Ethnicity,
            hair_length: char.hair_length || char.Hair_Length || char['Hair Length'],
            hair_color: char.hair_color || char.Hair_Color || char['Hair Color']
          }));
          
          // Store characters globally
          loadedCharacters = characters;
          
          // Update character search modal with real characters
          updateCharacterSearchModal(characters);

          // Store all characters globally for later use
          window.allCharacters = characters;

          // Update sidebar with active chat companions
          updateActiveChatsSidebar();

          console.log('✅ Loaded characters from database:', characters.length);
          
          // Now load character from URL parameter
          loadCharacterFromURL();

          // Only try direct loading if no new character flag exists
          const urlParams = new URLSearchParams(window.location.search);
          const characterSlug = urlParams.get('char');
          const newCharacterKey = `new_character_${characterSlug}`;
          const isNewCharacter = localStorage.getItem(newCharacterKey);

          if (!isNewCharacter && !characterLoadedFromURL) {
            // Also try to load a specific character directly from URL if available
            // But only if not already loaded by loadCharacterFromURL
            loadCharacterDirectly();
          } else if (characterLoadedFromURL) {
            console.log('⏭️ Skipping loadCharacterDirectly - already loaded from URL');
          } else {
            console.log('⏳ Skipping direct load for new character, waiting for API...');
          }
        }
      } catch (error) {
        console.error('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Error loading characters:', error);
        // Keep demo data as fallback
      }
    }

    function updateCharacterSearchModal(characters) {
      const characterGrid = document.getElementById('characterGrid');
      if (!characterGrid) return;
      
      characterGrid.innerHTML = characters.map(character => `
        <div class="character-option" onclick="selectCharacter('${character.slug}', '${character.name}', '${fixAvatarUrl(character.avatar)}', '${character.title}')">
          <div class="character-option-avatar">
            <img src="${fixAvatarUrl(character.avatar)}" alt="${character.name}" onerror="this.style.display='none'">
          </div>
          <div class="character-option-name">${character.name}</div>
          <div class="character-option-role">${character.title}</div>
        </div>
      `).join('');
    }

    // Get all active chat companions from localStorage
    async function getActiveChatCompanions() {
      const companions = [];
      const keys = Object.keys(localStorage);

      // Get current user to filter chats
      const currentUser = window.getCurrentUser ? window.getCurrentUser() : null;
      const currentUserEmail = currentUser?.email;
      const currentUserAuth0Id = currentUser?.sub || currentUser?.auth0_id || currentUser?.id;

      // If logged in, fetch actual user companions from database
      let userCompanionSlugs = null;
      if (currentUserEmail) {
        try {
          const response = await fetch('/.netlify/functions/selira-get-my-companions', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              user_email: currentUserEmail
            })
          });

          if (response.ok) {
            const data = await response.json();
            if (data.success && data.companions) {
              userCompanionSlugs = new Set(data.companions.map(c => c.slug || c.Slug));
              console.log('✅ Loaded user companions from database:', userCompanionSlugs.size, 'companions');
            }
          }
        } catch (error) {
          console.warn('⚠️ Could not load user companions, showing all local chats:', error);
        }
      }

      // Find all chat_ keys in localStorage
      keys.forEach(key => {
        if (key.startsWith('chat_')) {
          const characterSlug = key.replace('chat_', '');

          // If we have user companions from DB, only show those
          if (userCompanionSlugs && !userCompanionSlugs.has(characterSlug)) {
            return; // Skip this chat, user hasn't chatted with this companion
          }

          const chatHistory = JSON.parse(localStorage.getItem(key) || '[]');

          // Only include if there are messages
          if (chatHistory.length > 0) {
            // Get last message for preview
            const lastMessage = chatHistory[chatHistory.length - 1];
            const lastUserMessage = chatHistory.filter(m => m.type === 'user').pop();

            // Try to find character in loaded data first
            let characterName = characterSlug;
            let avatar = null;

            // Check if we can find this character in our loaded data
            let foundCharacter = null;
            if (loadedCharacters) {
              foundCharacter = loadedCharacters.find(c => c.slug === characterSlug);
            }
            if (!foundCharacter && window.allCharacters) {
              foundCharacter = window.allCharacters.find(c => c.slug === characterSlug);
            }

            // Get cached data first as fallback
            const cachedName = localStorage.getItem(`char_name_${characterSlug}`);
            const cachedAvatar = localStorage.getItem(`char_avatar_${characterSlug}`);

            if (foundCharacter) {
              characterName = foundCharacter.name || characterSlug;
              // Use foundCharacter avatar if available, otherwise use cached avatar
              avatar = foundCharacter.avatar || cachedAvatar;
              // Cache this for next time
              if (foundCharacter.name) {
                localStorage.setItem(`char_name_${characterSlug}`, foundCharacter.name);
              }
              if (foundCharacter.avatar && foundCharacter.avatar !== '/avatars/placeholder.webp' && foundCharacter.avatar !== 'null' && foundCharacter.avatar !== null) {
                localStorage.setItem(`char_avatar_${characterSlug}`, foundCharacter.avatar);
              }
            } else {
              // Fall back to cached data, but check if cached name looks like a slug
              // If cached name looks like a slug (contains timestamp pattern), try to fetch from API
              if (!cachedName || cachedName === characterSlug || /\d{13}/.test(cachedName)) {
                // Try to extract the actual name from the slug by removing the timestamp
                const slugWithoutTimestamp = characterSlug.replace(/-\d{13}$/, '');
                characterName = slugWithoutTimestamp.split('-').map(word =>
                  word.charAt(0).toUpperCase() + word.slice(1)
                ).join(' ');
              } else {
                characterName = cachedName;
              }

              avatar = cachedAvatar || null;
            }

            companions.push({
              slug: characterSlug,
              lastMessage: lastMessage?.content || '',
              lastUserMessage: lastUserMessage?.content || '',
              timestamp: lastMessage?.timestamp || Date.now(),
              messageCount: chatHistory.length,
              characterName: characterName, // This is already set from foundCharacter.name or cached name
              avatar: avatar || null  // Ensure null instead of string "null"
            });
          }
        }
      });

      // Sort by most recent activity
      companions.sort((a, b) => b.timestamp - a.timestamp);

      return companions;
    }

    // Update sidebar with active chat companions
    async function updateActiveChatsSidebar() {
      const chatList = document.getElementById('chatList');
      if (!chatList) return;

      const activeCompanions = await getActiveChatCompanions();

      if (activeCompanions.length === 0) {
        chatList.innerHTML = `
          <div class="no-chats" style="text-align: center; padding: 20px; color: var(--text-secondary); font-size: 14px;">
            <div style="margin-bottom: 8px;"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg></div>
            <div>No active chats yet</div>
            <div style="font-size: 12px; margin-top: 4px;">Start a conversation!</div>
          </div>
        `;
        return;
      }

      // Build HTML for active chats
      let html = '';

      for (const companion of activeCompanions) {
        // Try to find character in loaded characters
        let character = loadedCharacters.find(c => c.slug === companion.slug);

        // If not found, try to find from loaded characters by slug
        if (!character && window.allCharacters) {
          character = window.allCharacters.find(c => c.slug === companion.slug);
        }

        // Create chat item
        const isActive = currentCharacter && currentCharacter.slug === companion.slug;
        const preview = companion.lastUserMessage.length > 40
          ? companion.lastUserMessage.substring(0, 40) + '...'
          : companion.lastUserMessage;

        // Get avatar URL and name with fallbacks
        let avatarUrl = '/avatars/placeholder.webp';
        let characterName = companion.slug;

        // Get cached data as baseline
        const cachedAvatar = localStorage.getItem(`char_avatar_${companion.slug}`);
        const cachedName = localStorage.getItem(`char_name_${companion.slug}`);

        // Priority 1: Use companion.characterName if available (from getActiveChatCompanions)
        if (companion.characterName && companion.characterName !== companion.slug) {
          characterName = companion.characterName;
        }
        if (companion.avatar && companion.avatar !== 'null' && companion.avatar !== null && companion.avatar !== '/avatars/placeholder.webp') {
          avatarUrl = companion.avatar;
        }

        // Priority 2: Use character data from loadedCharacters
        if (character) {
          if (character.name) {
            characterName = character.name;
          }
          if (character.avatar && character.avatar !== 'null' && character.avatar !== null && character.avatar !== '/avatars/placeholder.webp') {
            avatarUrl = character.avatar;
          }
        }
        // Priority 3: If this is the current character, use its data
        else if (currentCharacter && currentCharacter.slug === companion.slug) {
          characterName = currentCharacter.name;
          if (currentCharacter.avatar && currentCharacter.avatar !== '/avatars/placeholder.webp' && currentCharacter.avatar !== 'null' && currentCharacter.avatar !== null) {
            avatarUrl = currentCharacter.avatar;
          }
        }

        // Priority 4: Use cached avatar if no other avatar found
        if ((!avatarUrl || avatarUrl === '/avatars/placeholder.webp') && cachedAvatar) {
          avatarUrl = cachedAvatar;
        }

        // Priority 5: Use cached name if no other name found
        if ((!characterName || characterName === companion.slug) && cachedName) {
          characterName = cachedName;
        }

        // Cache character info for future sidebar displays
        if (character) {
          if (character.name) {
            localStorage.setItem(`char_name_${companion.slug}`, character.name);
          }
          if (character.avatar && character.avatar !== '/avatars/placeholder.webp' && character.avatar !== 'null' && character.avatar !== null) {
            localStorage.setItem(`char_avatar_${companion.slug}`, character.avatar);
          }
        }

        // Removed excessive debug logging for sidebar items

        html += `
          <div class="chat-item ${isActive ? 'active' : ''}"
               onclick="switchToCompanion('${companion.slug}')"
               data-slug="${companion.slug}">
            <div class="chat-avatar">
              <img src="${fixAvatarUrl(avatarUrl)}"
                   alt="${characterName}"
                   onerror="this.src='/avatars/default-avatar.webp'; console.warn('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Chat item avatar failed for ${companion.slug}');">
            </div>
            <div class="chat-info">
              <div class="chat-name">${characterName}</div>
              <div class="chat-preview">${preview || character?.description?.substring(0, 30) || 'Start chatting...'}</div>
            </div>
          </div>
        `;
      }

      chatList.innerHTML = html;
    }

    // Switch to a companion from the sidebar
    async function switchToCompanion(slug) {
      // Don't clear greeting flag - we want to track across character switches
      // greetingAddedFor.clear();

      // Find character in loaded data
      let character = loadedCharacters.find(c => c.slug === slug);

      if (!character && window.allCharacters) {
        character = window.allCharacters.find(c => c.slug === slug);
      }

      if (!character) {
        // Try to load character data from API
        try {
          const response = await fetch(`/.netlify/functions/selira-characters-fetch?slug=${slug}`);
          if (response.ok) {
            const data = await response.json();
            if (data.success && data.characters && data.characters.length > 0) {
              const airtableChar = data.characters[0];
              // Map Airtable format to local format
              character = {
                id: airtableChar.Character_ID || airtableChar.Name,
                name: airtableChar.Name || 'Unknown',
                title: airtableChar.Character_Title || '',
                description: airtableChar.Character_Description || '',
                avatar: airtableChar.Avatar_URL ? airtableChar.Avatar_URL.replace('narrin.ai', 'selira.ai') : null,
                category: airtableChar.Category || 'Other',
                slug: airtableChar.Slug || slug,
                creator: airtableChar.Nickname || airtableChar.Created_by || 'Selira',
                tags: Array.isArray(airtableChar.Tags) ? airtableChar.Tags.slice(0, 11) : (airtableChar.Tags || '').toString().split(',').filter(Boolean).slice(0, 11),
                // Appearance data (only fields that exist in Airtable)
                companion_type: airtableChar.companion_type,
                sex: airtableChar.sex,
                ethnicity: airtableChar.ethnicity,
                hair_length: airtableChar.hair_length,
                hair_color: airtableChar.hair_color,
                personality: airtableChar.personality,
                prompt: airtableChar.prompt
              };
            }
          }
        } catch (error) {
          console.error('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Error loading character:', error);
        }
      }

      if (character) {
        // Update current character
        currentCharacter = {
          name: character.name || character.Name,
          slug: character.slug || character.Slug,
          avatar: character.avatar || character.Avatar_URL,
          avatar_url_2: character.avatar_url_2 || null, // Second image for carousel
          title: character.title || character.Character_Title || character.description,
          description: character.description || character.Character_Description,
          greeting: extractGreetingFromDescription(character.description || character.Character_Description) || generateGreetingForNewCharacter(character),
          creator: character.creator || character.Nickname || '@Selira',
          chats: getMessageCount(character.slug || character.Slug),
          rating: character.rating || '4.5',
          tags: character.tags || character.Tags || [],
          voice: character.voice || '',
          // Include ALL appearance properties for image generation (check both cases)
          category: character.category || character.Category,
          companion_type: character.companion_type || character.Companion_Type,
          sex: character.sex || character.Sex || character.Gender,
          ethnicity: character.ethnicity || character.Ethnicity,
          hair_length: character.hair_length || character.Hair_Length,
          hair_color: character.hair_color || character.Hair_Color,
          personality: character.personality || character.Personality,
          prompt: character.prompt || character.Prompt
        };

        // Cache character info for sidebar
        cacheCharacterInfo(character);

        // Update UI
        updateCharacterDisplay();

        // Update URL
        updateUrlForCharacter(slug);

        // Load chat history
        loadChatHistoryFromStorage(slug);

        // Update active state in sidebar
        document.querySelectorAll('.chat-item').forEach(item => {
          item.classList.toggle('active', item.dataset.slug === slug);
        });

        // Refresh sidebar to reflect any changes
        updateActiveChatsSidebar();

        // Close sidebar on mobile
        if (window.innerWidth <= 768) {
          closeSidebar();
        }

        console.log('✅ Switched to companion:', character.name);
      } else {
        console.error('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Character not found:', slug);
        // Still load the chat history even if character data not found
        loadChatHistoryFromStorage(slug);
      }
    }

    // Legacy function for compatibility
    function updateRecentChatsSidebar(characters) {
      // This function is now replaced by updateActiveChatsSidebar
      // Keep it for compatibility but call the new function
      updateActiveChatsSidebar();
    }

    function selectCharacterFromSidebar(slug, name, avatar, title) {
      // Find character in loaded data for real tags and creator
      const character = loadedCharacters.find(c => c.slug === slug) || {};
      
      // Update current character
      currentCharacter = {
        name: name,
        slug: slug,
        avatar: fixAvatarUrl(avatar),
        creator: '@' + (character.creator || 'Selira'),
        description: character.description || 'Start a conversation with ' + name,
        chats: Math.floor(Math.random() * 100) + 'K',
        rating: (Math.random() * 2 + 3).toFixed(1),
        tags: character.tags || ['Fantasy', 'Adventure', 'Hero'],
        // Include ALL appearance properties for image generation (check both cases)
        category: character.category || character.Category,
        companion_type: character.companion_type || character.Companion_Type,
        sex: character.sex || character.Sex || character.Gender,
        ethnicity: character.ethnicity || character.Ethnicity,
        hair_length: character.hair_length || character.Hair_Length,
        hair_color: character.hair_color || character.Hair_Color,
        age: character.age || character.Age,
        personality: character.personality || character.Personality,
        prompt: character.prompt || character.Prompt
      };
      
      updateCharacterDisplay();
      
      // Update active chat item
      document.querySelectorAll('.chat-item').forEach(item => {
        item.classList.remove('active');
      });
      event.currentTarget.classList.add('active');
      
      // Update URL to reflect new character
      updateUrlForCharacter(slug);
      
      // Load chat history for this character
      loadChatHistoryFromStorage(slug);
      
      // Only clear if no history was loaded
      setTimeout(() => {
        const hasMessages = document.querySelectorAll('.message:not(.welcome-message)').length > 0;
        if (!hasMessages) {
          clearChat();
        }
      }, 100);
    }

    function selectCharacter(slug, name, avatar, title) {
      // Find the full character data from loadedCharacters
      const fullCharacterData = loadedCharacters.find(char => char.slug === slug) || {};

      // Update character and close modal
      currentCharacter = {
        name: name,
        slug: slug,
        avatar: fixAvatarUrl(avatar),
        title: title || fullCharacterData.title || '',
        description: fullCharacterData.description || 'Start a conversation with ' + name,
        category: fullCharacterData.category || fullCharacterData.Category || 'Other',
        creator: fullCharacterData.creator || '@Selira',
        chats: Math.floor(Math.random() * 100) + 'K',
        rating: (Math.random() * 2 + 3).toFixed(1),
        tags: fullCharacterData.tags || ['Fantasy', 'Adventure', 'Hero'],
        character_url: fullCharacterData.character_url,
        // Include ALL appearance properties for image generation (check both cases)
        companion_type: fullCharacterData.companion_type || fullCharacterData.Companion_Type,
        sex: fullCharacterData.sex || fullCharacterData.Sex || fullCharacterData.Gender,
        ethnicity: fullCharacterData.ethnicity || fullCharacterData.Ethnicity,
        hair_length: fullCharacterData.hair_length || fullCharacterData.Hair_Length,
        hair_color: fullCharacterData.hair_color || fullCharacterData.Hair_Color,
        personality: fullCharacterData.personality || fullCharacterData.Personality,
        prompt: fullCharacterData.prompt || fullCharacterData.Prompt
      };

      // Cache character info for sidebar
      cacheCharacterInfo({
        slug: slug,
        name: name,
        avatar: avatar
      });

      updateCharacterDisplay();

      // Update URL to reflect new character
      updateUrlForCharacter(slug);

      closeCharacterSearch();
      
      // Load chat history for this character
      loadChatHistoryFromStorage(slug);
      
      // Only clear if no history was loaded
      setTimeout(() => {
        const hasMessages = document.querySelectorAll('.message:not(.welcome-message)').length > 0;
        if (!hasMessages) {
          clearChat();
        }
      }, 100);
    }

    // Update URL when switching characters
    function updateUrlForCharacter(characterSlug) {
      if (!characterSlug) return;
      
      // Find the character data to get the proper URL
      const character = loadedCharacters.find(c => c.slug === characterSlug);
      let newUrl;
      
      if (character && character.character_url) {
        // Use the character's specific URL from Airtable
        newUrl = character.character_url;
      } else {
        // Fallback to standard format
        newUrl = `https://selira.ai/chat.html?char=${encodeURIComponent(characterSlug)}`;
      }
      
      // Update the URL without reloading the page
      const currentUrl = window.location.href;
      if (currentUrl !== newUrl) {
        console.log('🔄 Updating URL for character:', characterSlug, '→', newUrl);
        window.history.pushState({character: characterSlug}, '', newUrl);
      }
    }

    // Handle browser back/forward buttons
    window.addEventListener('popstate', function(event) {
      if (event.state && event.state.character) {
        console.log('↩️ Browser navigation to character:', event.state.character);
        // Find the character and switch to it without updating URL again
        const character = loadedCharacters.find(c => c.slug === event.state.character);
        if (character) {
          // Switch character but skip URL update to avoid loop
          selectCharacterFromSidebarSilent(character.slug, character.name, fixAvatarUrl(character.avatar), character.title);
        }
      }
    });

    // Extract greeting from character description
    function extractGreetingFromDescription(description) {
      if (!description) return null;

      const greetingMatch = description.match(/Greeting:\s*(.+?)(?:\n|$)/);
      return greetingMatch ? greetingMatch[1].trim() : null;
    }

    // Clean description by removing greeting and extra instructions
    function cleanDescription(description) {
      if (!description) return '';

      // First, unescape newlines
      let cleaned = description.replace(/\\n/g, '\n');

      // Remove everything after "Extra Instructions:" or "Greeting:"
      cleaned = cleaned.split(/(?:Extra Instructions:|Greeting:)/)[0].trim();

      // Remove "A realistic/anime companion with..." part and keep only the "Discover..." or "Experience..." part
      const discoverMatch = cleaned.match(/(?:Discover|Experience)\s+[^]*$/m);
      if (discoverMatch) {
        return discoverMatch[0].trim();
      }

      // If no Discover/Experience found, return the cleaned text without the first line
      const lines = cleaned.split('\n').filter(line => line.trim());
      if (lines.length > 1) {
        // Skip first line (e.g., "A realistic companion with...")
        return lines.slice(1).join(' ').trim();
      }

      return cleaned;
    }

    // Cache character info for sidebar
    function cacheCharacterInfo(character) {
      if (!character?.slug) return;

      if (character.name && character.name !== character.slug) {
        localStorage.setItem(`char_name_${character.slug}`, character.name);
      }
      if (character.avatar && character.avatar !== '/avatars/placeholder.webp' && character.avatar !== 'null' && character.avatar !== null) {
        localStorage.setItem(`char_avatar_${character.slug}`, character.avatar);
        console.log('💾 Cached avatar for sidebar:', character.slug, character.avatar);
      }
    }

    // Get actual message count for a character
    function getMessageCount(characterSlug) {
      try {
        const chatHistory = JSON.parse(localStorage.getItem(`chat_${characterSlug}`) || '[]');
        return chatHistory.length;
      } catch (error) {
        console.warn('Error getting message count for', characterSlug, error);
        return 0;
      }
    }

    // Track used suggestions to avoid repeating
    let usedSuggestions = new Set();
    let allAvailableSuggestions = [];

    // Fisher-Yates shuffle algorithm
    function shuffleArray(array) {
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }

    // Generate a random greeting for new characters
    function generateGreetingForNewCharacter(character) {
      const name = character.name;

      // 10 verschillende erotische greetings die willekeurig worden toegewezen
      const randomGreetings = [
        `*bites lip seductively* Hey there... I'm ${name}, and I've been thinking about you all day. *slowly approaches* I need you so badly right now... *presses body against yours*`,

        `*sultry smile and bedroom eyes* Mmm, well hello sexy... I'm ${name}, and you've got me completely captivated. *slowly licks lips* Want to see what I can do?`,

        `*looks at you with burning desire* Hello beautiful... I'm ${name}. *steps closer intimately* There's this intense chemistry between us... I can feel it. *voice drops seductively*`,

        `*moves with feline grace* Hello darling... I'm ${name}. *traces finger down your chest* I know exactly what you're thinking... and yes, I want it too. *whispers breathlessly*`,

        `*giggles playfully while twirling* Hi there cutie! I'm ${name}! *bites finger innocently* You look amazing... *blushes* Want to play with me? I promise I'm lots of fun~`,

        `*kneels gracefully with doe eyes* Hello... I'm ${name}. *looks up adoringly* I exist only to serve and please you... Tell me your desires, and I'll make them reality.`,

        `*intense, passionate stare* I'm ${name}... and you... *traces finger along your jaw* ...you're exactly what I've been craving. Let's not waste any time, shall we?`,

        `*leans in close* I'm ${name}, and I have to say... *whispers* you're making me feel things I probably shouldn't say out loud. Yet. *teasing smile*`,

        `*predatory but playful* Well, well... what do we have here? *circles you seductively* I'm ${name}... and I'm going to make you feel incredible~ *dangerous grin*`,

        `*passionate gaze* They call me ${name}... *moves dangerously close* and I specialize in making fantasies come true. Tell me yours, and I'll make you tremble...`
      ];

      // Kies willekeurig een greeting
      const randomIndex = Math.floor(Math.random() * randomGreetings.length);
      return randomGreetings[randomIndex];
    }

    // Check if character was recently created (within last 5 minutes)
    function checkIfNewCharacter(slug) {
      const newCharacterKey = `new_character_${slug}`;
      const creationTime = localStorage.getItem(newCharacterKey);

      if (!creationTime) return false;

      const now = Date.now();
      const created = parseInt(creationTime);
      const fiveMinutes = 5 * 60 * 1000; // 5 minutes in milliseconds

      if (now - created < fiveMinutes) {
        return true;
      } else {
        // Clean up old marker
        localStorage.removeItem(newCharacterKey);
        return false;
      }
    }

    // Clear all messages from chat display
    function clearChatDisplay() {
      const chatMessages = document.getElementById('chatMessages');
      if (chatMessages) {
        chatMessages.innerHTML = '';
        console.log('🧽 Cleared chat display');
      }
    }

    // Switch character without updating URL (for browser navigation)
    function selectCharacterFromSidebarSilent(slug, name, avatar, title) {
      // Find character in loaded data for real tags and creator
      const character = loadedCharacters.find(c => c.slug === slug) || {};

      // Check if this is a newly created character (less than 5 minutes old in localStorage)
      const isNewCharacter = checkIfNewCharacter(slug);

      // Update current character
      currentCharacter = {
        name: name,
        slug: slug,
        avatar: fixAvatarUrl(avatar),
        creator: '@' + (character.creator || character.createdBy || 'Selira'),
        description: character.description || 'Start a conversation with ' + name,
        greeting: extractGreetingFromDescription(character.description) || generateGreetingForNewCharacter(character),
        chats: getMessageCount(slug),
        rating: character.rating || (isNewCharacter ? '5.0' : (Math.random() * 2 + 3).toFixed(1)),
        tags: character.tags || ['Fantasy', 'Adventure', 'Hero'],
        // Include ALL appearance properties for image generation (check both cases)
        category: character.category || character.Category,
        companion_type: character.companion_type || character.Companion_Type,
        sex: character.sex || character.Sex || character.Gender,
        ethnicity: character.ethnicity || character.Ethnicity,
        hair_length: character.hair_length || character.Hair_Length,
        hair_color: character.hair_color || character.Hair_Color,
        age: character.age || character.Age,
        personality: character.personality || character.Personality,
        prompt: character.prompt || character.Prompt
      };

      // Cache character info for sidebar
      cacheCharacterInfo({
        slug: slug,
        name: name,
        avatar: avatar
      });

      // Clear chat display first
      clearChatDisplay();

      // If this is a new character, clear any existing chat history and start fresh
      if (isNewCharacter) {
        const storageKey = `chat_${slug}`;
        localStorage.removeItem(storageKey);
        console.log('🧹 Cleared chat history for new character:', slug);

        // Add the avatar and greeting message
        setTimeout(() => {
          // First send the avatar as an image message
          if (currentCharacter.avatar && currentCharacter.avatar !== '/avatars/placeholder.webp') {
            addAvatarMessage(currentCharacter.avatar);
          }

          // Then send the greeting message after a delay
          setTimeout(() => {
            // Check if greeting was already added by loadChatFromStorage
            if (greetingAddedFor.has(slug)) {
              console.log('⏭️ Greeting already added by loadChatFromStorage, skipping');
              return;
            }

            let greetingMessage = currentCharacter.greeting;

            // If no greeting is set, generate one based on character traits
            if (!greetingMessage) {
              greetingMessage = generateGreetingForNewCharacter(currentCharacter);
              console.log('🎭 Generated greeting for new character:', greetingMessage);
            }

            if (greetingMessage) {
              addMessage(greetingMessage, 'ai');
              greetingAddedFor.add(slug);
            }
          }, 200);
        }, 500);
      } else {
        // Load existing chat history for this character
        loadChatHistoryFromStorage(slug);
      }

      updateCharacterDisplay();

      // Update active chat item
      document.querySelectorAll('.chat-item').forEach(item => {
        item.classList.remove('active');
      });
      // Find and highlight the correct chat item
      const chatItems = document.querySelectorAll('.chat-item');
      chatItems.forEach(item => {
        if (item.onclick && item.onclick.toString().includes(slug)) {
          item.classList.add('active');
        }
      });
      
      // Only show welcome message if no history exists
      setTimeout(() => {
        const hasMessages = document.querySelectorAll('.message:not(.welcome-message)').length > 0;
        if (!hasMessages) {
          showWelcomeMessage();
        }
      }, 100);
    }

    // Show welcome message without clearing localStorage
    function showWelcomeMessage() {
      const messagesContainer = document.getElementById('chatMessages');
      messagesContainer.innerHTML = `
        <div class="welcome-message" style="text-align: center; padding: 40px 20px; color: var(--text-secondary);">
          <div style="font-size: 48px; margin-bottom: 16px;">💭</div>
          <h3 style="color: var(--text-primary); margin-bottom: 8px;">Start Conversation</h3>
          <p>Begin chatting with ${currentCharacter.name}!</p>
        </div>
      `;
    }

    // Add typing indicator
    function addTypingIndicator() {
      const messagesContainer = document.getElementById('chatMessages');
      const typingDiv = document.createElement('div');
      typingDiv.className = 'message ai typing-indicator';
      typingDiv.innerHTML = `
        <div class="message-avatar">
          <img src="${fixAvatarUrl(currentCharacter.avatar)}" alt="${currentCharacter.name}" onerror="this.style.display='none'">
        </div>
        <div class="message-content">
          <div class="typing-dots">
            <span></span><span></span><span></span>
          </div>
        </div>
      `;
      
      messagesContainer.appendChild(typingDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      return typingDiv;
    }

    // Ensure user exists in Airtable (auto-sync from Auth0)
    async function ensureUserInAirtable(auth0_id, email, name, nickname) {
      try {
        console.log('🔄 Syncing Auth0 user to Airtable...');
        
        const response = await fetch('/.netlify/functions/selira-user-sync', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            auth0_id: auth0_id,
            email: email,
            name: name,
            picture: user?.picture
          })
        });

        if (response.ok) {
          const result = await response.json();
          console.log('✅ User sync result:', result.action, result.message);
        } else {
          console.log('⚠️ User sync failed:', response.status);
        }
      } catch (error) {
        console.log('⚠️ User sync error:', error.message);
        // Don't fail the chat if sync fails
      }
    }

    // Save chat message to Airtable
    async function saveChatMessage(auth0_id, user_email, character_slug, userMessage, aiResponse) {
      try {
        // Skip saving for anonymous users
        if (auth0_id === 'anonymous') {
          console.log('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg> Anonymous user - skipping chat save');
          return;
        }
        
        console.log('💾 Saving chat message:', {
          auth0_id: auth0_id,
          email: user_email,
          character: character_slug,
          hasUserMessage: !!userMessage,
          hasAiResponse: !!aiResponse
        });

        const response = await fetch('/.netlify/functions/selira-save-chat', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            email: user_email,
            auth0_id: auth0_id,
            character_slug: character_slug,
            user_message: userMessage,
            ai_response: aiResponse
          })
        });
        
        if (response.ok) {
          console.log('✅ Chat message saved successfully');
        } else {
          const errorData = await response.text();
          console.log('⚠️ Failed to save chat message:', response.status);
          console.log('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Error details:', errorData);
          
          // Try to parse error for better debugging
          try {
            const errorJson = JSON.parse(errorData);
            console.log('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg> Parsed error:', errorJson);
          } catch (e) {
            console.log('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg> Raw error response:', errorData.substring(0, 200));
          }
        }
      } catch (error) {
        console.error('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Error saving chat message:', error);
      }
    }

    // Load character from URL parameter on page load
    function loadCharacterFromURL() {
      const urlParams = new URLSearchParams(window.location.search);
      const characterSlug = urlParams.get('char');

      console.log('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg> Checking URL for character:', characterSlug);
      console.log('📦 Available characters:', loadedCharacters.map(c => ({ name: c.name, slug: c.slug })));

      if (characterSlug && loadedCharacters.length > 0) {
        // Find the character in our loaded data with better matching
        const character = loadedCharacters.find(c =>
          c.slug === characterSlug ||
          c.slug === characterSlug.toLowerCase() ||
          c.name.toLowerCase().replace(/[^a-z0-9]/g, '-') === characterSlug.toLowerCase() ||
          c.name.toLowerCase() === characterSlug.replace(/-/g, ' ').toLowerCase()
        );

        if (character) {
          console.log('✅ Found character from URL:', character.name);
          // Set flag to prevent double loading
          characterLoadedFromURL = true;
          // Load this character without updating URL (we're already on the right URL)
          selectCharacterFromSidebarSilent(character.slug, character.name, fixAvatarUrl(character.avatar), character.title);
        } else {
          console.log('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Character not found in loaded data, searching API for:', characterSlug);
          console.log('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg> Available slugs:', loadedCharacters.map(c => c.slug));
          // Try to find by fetching specific character from API - don't load fallback yet
          // The API loading function will handle fallback if it fails
          loadSpecificCharacterFromAPI(characterSlug);
        }
      } else if (characterSlug && loadedCharacters.length === 0) {
        console.log('⏳ Characters not loaded yet, retrying in 500ms...');
        setTimeout(loadCharacterFromURL, 500);
      } else if (!characterSlug && loadedCharacters.length > 0) {
        // Only load fallback if there's NO character slug in URL at all
        console.log('ℹ️ No character in URL, loading first available character');
        loadFallbackCharacter();
      }
    }

    // Load specific character from API if not found in initial data
    async function loadSpecificCharacterFromAPI(characterSlug, retryCount = 0) {
      try {
        console.log('🔄 Fetching specific character from API:', characterSlug, `(attempt ${retryCount + 1})`);

        // Check if this is a newly created character
        const newCharacterKey = `new_character_${characterSlug}`;
        const isNewCharacter = localStorage.getItem(newCharacterKey);

        if (isNewCharacter && retryCount < 3) {
          console.log('🆕 This is a newly created character, retrying in 500ms...');
          setTimeout(() => loadSpecificCharacterFromAPI(characterSlug, retryCount + 1), 500);
          return;
        }

        const response = await fetch(`/.netlify/functions/selira-characters-fetch?slug=${encodeURIComponent(characterSlug)}`);

        if (response.ok) {
          const data = await response.json();
          if (data.success && data.characters && data.characters.length > 0) {
            // Prefer character with Avatar_URL if multiple exist
            const character = data.characters.find(c => c.Avatar_URL && c.Avatar_URL.trim() !== '') || data.characters[0];
            const processedChar = {
              id: character.Character_ID || character.Name,
              name: character.Name || 'Unknown',
              title: character.Character_Title || '',
              description: character.Character_Description || '',
              avatar: character.Avatar_URL ? character.Avatar_URL.replace('narrin.ai', 'selira.ai') : null,
              category: character.Category || 'Other',
              slug: character.Slug || characterSlug,
              creator: character.Created_by || 'Selira',
              tags: Array.isArray(character.Tags) ? character.Tags.slice(0, 11) : (character.Tags || '').toString().split(',').filter(Boolean).slice(0, 11),
              character_url: character.Character_URL ? character.Character_URL.replace('narrin.ai', 'selira.ai') : null,
              // Appearance traits for image generation
              companion_type: character.companion_type,
              sex: character.sex,
              ethnicity: character.ethnicity,
              hair_length: character.hair_length,
              hair_color: character.hair_color
            };

            console.log('✅ Loaded specific character:', processedChar.name);

            // Add to loadedCharacters if not already there
            const existingIndex = loadedCharacters.findIndex(c => c.slug === processedChar.slug);
            if (existingIndex >= 0) {
              loadedCharacters[existingIndex] = processedChar;
            } else {
              loadedCharacters.push(processedChar);
            }

            // Cache character info for sidebar
            cacheCharacterInfo({
              slug: processedChar.slug,
              name: processedChar.name,
              avatar: processedChar.avatar
            });

            // Clear the new character flag
            if (isNewCharacter) {
              localStorage.removeItem(newCharacterKey);
              console.log('🧹 Cleared new character flag for:', characterSlug);
            }

            selectCharacterFromSidebarSilent(processedChar.slug, processedChar.name, fixAvatarUrl(processedChar.avatar), processedChar.title);
          } else {
            if (isNewCharacter && retryCount < 3) {
              console.log('🔄 New character not found yet, retrying in 500ms...');
              setTimeout(() => loadSpecificCharacterFromAPI(characterSlug, retryCount + 1), 500);
            } else {
              console.log('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Character not found in API after retries');
              // For new characters, don't load fallback - show error instead
              if (isNewCharacter) {
                showCharacterNotFoundError(characterSlug);
              } else {
                loadFallbackCharacter();
              }
            }
          }
        } else {
          if (isNewCharacter && retryCount < 3) {
            console.log('🔄 API error for new character, retrying in 500ms...');
            setTimeout(() => loadSpecificCharacterFromAPI(characterSlug, retryCount + 1), 500);
          } else {
            // For new characters, don't load fallback - show error instead
            if (isNewCharacter) {
              showCharacterNotFoundError(characterSlug);
            } else {
              loadFallbackCharacter();
            }
          }
        }
      } catch (error) {
        console.error('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Error loading specific character:', error);
        if (isNewCharacter && retryCount < 3) {
          console.log('🔄 Error loading new character, retrying in 500ms...');
          setTimeout(() => loadSpecificCharacterFromAPI(characterSlug, retryCount + 1), 500);
        } else {
          // For new characters, don't load fallback - show error instead
          if (isNewCharacter) {
            showCharacterNotFoundError(characterSlug);
          } else {
            loadFallbackCharacter();
          }
        }
      }
    }

    // Load fallback character if specific one not found
    function loadFallbackCharacter() {
      if (loadedCharacters.length > 0) {
        const fallbackChar = loadedCharacters[0];
        console.log('🔄 Loading fallback character:', fallbackChar.name);
        selectCharacterFromSidebarSilent(fallbackChar.slug, fallbackChar.name, fixAvatarUrl(fallbackChar.avatar), fallbackChar.title);
      }
    }

    // Show error when new character cannot be found
    function showCharacterNotFoundError(characterSlug) {
      console.log('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> New character not found, showing error for:', characterSlug);

      // Clear chat display
      clearChatDisplay();

      // Set minimal character info for UI
      currentCharacter = {
        name: characterSlug,
        slug: characterSlug,
        avatar: null,
        creator: '@Selira',
        description: 'Character is being created...',
        greeting: '',
        chats: 0,
        rating: '5.0',
        tags: ['New']
      };

      // Update UI with placeholder data
      updateCharacterUI();

      // Show error message in chat
      const chatMessages = document.getElementById('chatMessages');
      if (chatMessages) {
        chatMessages.innerHTML = `
          <div class="message character-message">
            <div class="character-avatar" style="background: linear-gradient(45deg, #ff6b6b, #ff8e8e);">
              <span>?</span>
            </div>
            <div class="message-content">
              <div class="character-name">Selira AI</div>
              <div class="message-text">
                ⚠️ Your new character "${characterSlug}" is still being created. This usually takes a few moments.<br><br>
                Please try refreshing the page in a minute, or <a href="/create.html" style="color: #007acc;">create a new character</a>.
              </div>
            </div>
          </div>
        `;
      }
    }

    // Direct character loading from URL - simpler approach
    function loadCharacterDirectly() {
      const urlParams = new URLSearchParams(window.location.search);
      const characterSlug = urlParams.get('char');
      
      if (!characterSlug || loadedCharacters.length === 0) return;
      
      console.log('🎯 Direct loading character:', characterSlug);
      
      // Try exact match first
      let character = loadedCharacters.find(c => c.slug === characterSlug);
      
      // If not found, try case insensitive
      if (!character) {
        character = loadedCharacters.find(c => c.slug && c.slug.toLowerCase() === characterSlug.toLowerCase());
      }
      
      // If still not found, try name-based matching
      if (!character) {
        character = loadedCharacters.find(c => 
          c.name && c.name.toLowerCase().replace(/[^a-z0-9]/g, '-') === characterSlug.toLowerCase()
        );
      }
      
      if (character) {
        console.log('✅ Direct match found:', character.name);
        // Force update the character
        currentCharacter = {
          name: character.name,
          slug: character.slug,
          avatar: fixAvatarUrl(character.avatar),
          creator: '@' + (character.creator || 'Selira'),
          description: character.description || 'An amazing character ready for conversation.',
          chats: character.chats || Math.floor(Math.random() * 100) + 'K',
          rating: character.rating || (Math.random() * 2 + 3).toFixed(1),
          tags: character.tags || ['Character'],
          // Include ALL appearance properties for image generation (check both cases)
          category: character.category || character.Category,
          companion_type: character.companion_type || character.Companion_Type,
          sex: character.sex || character.Sex || character.Gender,
          ethnicity: character.ethnicity || character.Ethnicity,
          hair_length: character.hair_length || character.Hair_Length,
          hair_color: character.hair_color || character.Hair_Color,
          personality: character.personality || character.Personality,
          prompt: character.prompt || character.Prompt
        };
        
        // Cache the loaded character info
        cacheCharacterInfo({
          slug: character.slug,
          name: character.name,
          avatar: character.avatar
        });

        updateCharacterDisplay();
        highlightCorrectChatItem(character.slug);

        // Refresh sidebar after character loads
        updateActiveChatsSidebar();

        // Load chat history for this character
        loadChatHistoryFromStorage(character.slug);
        
        // Clear only if no history loaded
        setTimeout(() => {
          const hasMessages = document.querySelectorAll('.message:not(.welcome-message)').length > 0;
          if (!hasMessages) {
            clearChat();
          }
        }, 500);
      } else {
        // Character not in cache - wait for API loading from loadCharacterFromURL()
        console.log('⏳ Character not in cache, waiting for API to load:', characterSlug);
        // Don't load fallback here - loadCharacterFromURL() or loadSpecificCharacterFromAPI() will handle it
        return;
      }
    }
    
    // Highlight correct chat item in sidebar
    function highlightCorrectChatItem(targetSlug) {
      document.querySelectorAll('.chat-item').forEach(item => {
        item.classList.remove('active');
        // Check if this item matches the target character
        const onclick = item.getAttribute('onclick') || '';
        if (onclick.includes(targetSlug) || onclick.includes(`'${targetSlug}'`)) {
          item.classList.add('active');
          console.log('✅ Highlighted chat item for:', targetSlug);
        }
      });
    }

    // Check if user can generate images
    // Cache for image permissions (to speed up UI)
    let imagePermissionsCache = null;
    let imagePermissionsCacheTime = 0;
    const IMAGE_PERMISSIONS_CACHE_DURATION = 30000; // 30 seconds

    // Rate limiting for image generation to prevent 500 errors
    let lastImageGenerationTime = 0;
    let isGeneratingImage = false;
    const MIN_IMAGE_GENERATION_INTERVAL = 3000; // 3 seconds between requests

    // Note: incrementImageUsage function removed - now handled by backend
    // The selira-generate-custom-image function now handles usage tracking

    async function checkUserImagePermissions(useCache = true) {
      const user = window.getCurrentUser ? window.getCurrentUser() : null;
      if (!user?.email && !user?.sub) {
        return { canGenerate: false, plan: 'Guest', reason: 'Please log in to generate images' };
      }

      // Check cache if requested and valid
      if (useCache && imagePermissionsCache &&
          (Date.now() - imagePermissionsCacheTime) < IMAGE_PERMISSIONS_CACHE_DURATION) {
        console.log('🚀 Using cached image permissions for fast UI');
        return imagePermissionsCache;
      }

      console.log('🔄 Fetching fresh image permissions from server');
      try {
        const response = await fetch('/.netlify/functions/selira-check-image-limit', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            email: user.email,
            auth0_id: user.id || user.sub || user.auth0_id // Supabase uses .id, Auth0 uses .sub
          })
        });

        if (response.status === 403) {
          const error = await response.json();
          const permissions = {
            canGenerate: false,
            plan: error.plan || 'Free',
            reason: 'Image generation requires Basic plan or higher'
          };

          // Cache blocked permissions for shorter time (5 seconds)
          imagePermissionsCache = permissions;
          imagePermissionsCacheTime = Date.now() - (IMAGE_PERMISSIONS_CACHE_DURATION - 5000);
          console.log('💾 Cached blocked permissions (short cache):', permissions);

          return permissions;
        }

        if (response.ok) {
          const data = await response.json();
          const permissions = {
            canGenerate: true,
            plan: data.plan,
            remaining: data.remaining,
            limit: data.limit
          };

          // Cache the result
          imagePermissionsCache = permissions;
          imagePermissionsCacheTime = Date.now();
          console.log('💾 Cached fresh image permissions:', permissions);

          return permissions;
        }

        // Default to blocking if server returns unexpected response
        const fallbackPermissions = {
          canGenerate: false,
          plan: 'Free',
          reason: 'Could not verify image generation permissions'
        };
        console.warn('⚠️ Unexpected response status:', response.status, '- blocking image generation');
        return fallbackPermissions;
      } catch (error) {
        console.warn('⚠️ Could not check image permissions:', error);
        // Default to blocking on errors for safety
        const fallbackPermissions = {
          canGenerate: false,
          plan: 'Free',
          reason: 'Could not verify image generation permissions'
        };
        return fallbackPermissions;
      }
    }

    // Load and display image credits
    async function loadImageCredits() {
      const user = window.getCurrentUser ? window.getCurrentUser() : null;
      const creditsDisplay = document.getElementById('imageCreditsDisplay');
      const creditsText = document.getElementById('imageCreditsText');

      if (!user?.email && !user?.sub) {
        creditsDisplay.style.display = 'none';
        return;
      }

      try {
        const response = await fetch('/.netlify/functions/selira-get-image-credits', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            email: user.email,
            auth0_id: user.sub || user.auth0_id
          })
        });

        if (response.ok) {
          const data = await response.json();

          // Show credits if user has purchased credits or subscription
          if (data.creditsRemaining > 0 || data.hasActiveSubscription) {
            creditsDisplay.style.display = 'flex';

            if (data.hasActiveSubscription) {
              creditsText.textContent = `${data.plan} Plan`;
            } else if (data.creditsRemaining > 0) {
              creditsText.textContent = `${data.creditsRemaining} credits`;
            }
          } else {
            creditsDisplay.style.display = 'none';
          }
        } else {
          creditsDisplay.style.display = 'none';
        }
      } catch (error) {
        console.warn('⚠️ Could not load image credits:', error);
        creditsDisplay.style.display = 'none';
      }
    }

    // Request image function - fills input with "Send me a picture "
    async function requestImage() {
      // Check user permissions first
      const permissions = await checkUserImagePermissions();

      if (!permissions.canGenerate) {
        showImageUpgradeModal(permissions);
        return;
      }

      // Check if suggestions are already visible
      const suggestionsDiv = document.getElementById('imagePromptSuggestions');

      if (suggestionsDiv && suggestionsDiv.classList.contains('visible')) {
        // Hide suggestions if already showing
        hideImagePromptSuggestions();
      } else {
        // Show suggestions
        showImagePromptSuggestions();
      }
    }


    // Stylish clothing options for companion avatars - extremely explicit
    function getStylishClothing(style, category = 'default') {
      const categoryClothing = {
        anime: {
          female: ['extremely revealing school uniform', 'micro bikini', 'ultra-short kimono', 'barely-there top', 'almost naked maid outfit', 'tiny lingerie set', 'string bikini', 'see-through outfit', 'exposed breasts lingerie', 'topless with mini skirt', 'transparent clothing', 'nipple-revealing top']
        },
        default: {
          female: ['ultra-revealing lingerie', 'micro string bikini', 'see-through dress', 'topless with tiny shorts', 'exposed breasts outfit', 'barely covered privates', 'transparent lingerie', 'nipple-revealing top', 'almost completely naked', 'tiny thong bikini', 'exposed cleavage outfit']
        }
      };

      // Find matching category or use default
      let clothingOptions = categoryClothing.default;

      if (categoryClothing[style]) {
        clothingOptions = categoryClothing[style];
      }

      // Select female clothing (since all companions are female)
      const femaleClothing = clothingOptions.female || categoryClothing.default.female;
      return femaleClothing[Math.floor(Math.random() * femaleClothing.length)];
    }

    // Function to enhance short prompts with detailed instructions for better image quality
    function enhancePromptWithDetails(shortPrompt, sex, isUncensored) {
      // If not uncensored, return as-is
      if (!isUncensored) {
        return shortPrompt;
      }

      // Enhancement mappings for uncensored prompts - focus on pure content description
      const enhancementMap = {
        // Female enhancements
        'doggystyle': 'Woman in explicit doggystyle position on all fours on a bed, man behind her thrusting his penis deep inside her pussy. Her beautiful face looks directly at the camera with intense pleasure, mouth open, eyes half-closed in ecstasy. Sweat glistening on skin. Visible penetration, her pussy lips stretched around his cock. Intimate angle showing her face and the sexual act clearly. Luxury bedroom setting with silk sheets, warm natural lighting.',

        'masturbating, fingers': 'Woman lying naked on bed masturbating intensely, two fingers deep inside her wet glistening pussy, other hand squeezing her breast. Face shows pure pleasure, mouth open moaning, eyes looking at camera with desire. Pussy lips visible, wetness dripping. Legs spread wide. Fingers clearly visible inside pussy. Intimate close angle. Warm lighting in luxury bedroom with silk sheets.',

        'naked legs spread': 'Beautiful naked woman lying on bed with legs spread very wide, displaying her wet glistening pussy in full view. Pussy lips clearly visible and slightly open. One hand touching breast, other hand near pussy. Seductive expression looking at camera with bedroom eyes. Full frontal intimate view showing everything. Luxury bedroom with soft romantic lighting, silk sheets.',

        'riding cock': 'Woman straddling man riding his cock, penis fully inserted in her pussy, bouncing up and down energetically. Her breasts bounce with each movement. Intense pleasure expression, head tilted back, mouth open. Visible penetration from side angle showing cock going in and out. Sweat on bodies. Luxury bedroom with silk sheets, warm lighting.',

        'blowjob': 'Woman on knees giving oral sex, lips wrapped around erect penis, mouth full of cock. Eyes looking up at camera submissively. One hand gripping shaft, other on his thigh. Saliva glistening. Intimate angle focused on face and oral act. Bedroom setting with silk sheets, soft lighting.',

        'bent over naked': 'Woman bent over edge of bed completely naked, presenting her pussy and ass from behind. Pussy lips visible and glistening, asshole exposed. Looking back over shoulder at camera with seductive expression. Legs slightly spread, full rear view. Hands spreading ass cheeks apart. Luxury bedroom, warm intimate lighting, silk sheets.',

        'missionary, cock in': 'Couple in missionary position, woman lying on back with legs spread wide, man on top with penis penetrating her pussy. Visible penetration, his cock sliding in and out of her wet pussy. Both faces showing intense pleasure. Her breasts pressed against his chest. Intimate angle. Luxury bedroom with silk sheets.',

        'toy, dildo': 'Woman lying naked on bed using large dildo, toy inserted deep in her pussy, pumping it in and out. Face shows intense pleasure approaching orgasm, mouth open moaning. Free hand squeezing breast. Legs spread wide. Dildo and pussy clearly visible, wetness dripping. Intimate angle. Bedroom with silk sheets, soft lighting.',

        'spreading pussy lips': 'Woman lying back naked, using both hands to spread her pussy lips wide open, revealing pink interior completely. Everything visible - clit, vaginal opening dripping wet. Face in frame showing lustful aroused expression, eyes locked on camera. Legs spread very wide. Intimate POV angle. Luxury bedroom, silk sheets, soft warm lighting.',

        'fucked hard, penis deep': 'Woman being fucked hard and fast, penis pounding deep in her pussy, powerful thrusts. Her breasts bouncing violently with each thrust. Face shows overwhelming pleasure, eyes rolling back, mouth wide open screaming in ecstasy. Visible penetration angle showing cock ramming in and out. Sweat covering bodies. Intense passionate sex. Luxury bedroom with silk sheets.',

        'naked on knees, tits': 'Woman kneeling naked on bed, breasts and pussy on full display. Submissive posture, looking up at camera with obedient expression. Hands behind back pushing chest forward. Nipples erect. Pussy visible between thighs. Full frontal intimate view. Luxury bedroom with silk sheets, soft romantic lighting.',

        'squirting, fingers rub': 'Woman lying back masturbating intensely, fingers rapidly rubbing clit, pussy squirting fluid. Face shows intense orgasm, mouth open screaming. Legs spread very wide, pussy gushing. Wetness spraying, sheets soaked. Focus on pussy squirting. Intimate angle. Luxury bedroom with silk sheets.',

        'on his face, pussy': 'Woman sitting on man\'s face, her pussy pressed against his mouth, him eating her out. She grinds her pussy on his face, hands squeezing her own breasts. Face shows intense pleasure, mouth open moaning. View from side showing her body and his face buried in her pussy. Luxury bedroom with silk sheets.',

        'penetrated anally': 'Woman in anal sex position, penis penetrating her asshole. Face shows mixture of pleasure and intensity, mouth open. Visible anal penetration from angle showing cock entering ass. Her hand reaching back spreading ass cheeks. Intimate angle. Luxury bedroom with silk sheets, warm lighting.',

        'nude aroused, pussy wet, huge tits': 'Woman lying seductively on bed completely naked and visibly aroused. Large breasts with erect nipples, wet glistening pussy with engorged lips, legs spread invitingly. Sultry expression with bedroom eyes locked on camera, biting lip. One hand touching breast, other near pussy. Full body view. Luxury bedroom with silk sheets, soft romantic lighting.',

        // Male enhancements
        'having sex, cock thrusts': 'Man having intense sex, his erect cock thrusting deep into woman. His muscular body visible, face showing pleasure, eyes looking at camera. Visible penetration angle showing his penis sliding in and out. Sweat glistening on his body. Strong dominant position. Luxury bedroom with silk sheets, warm lighting.',

        'masturbating in bed, hand strokes': 'Man lying on bed masturbating, hand stroking his large erect penis up and down. Face shows pleasure, mouth slightly open. Other hand behind head. Cock clearly visible being pumped. Showing his face and his hand on his cock. Luxury bedroom with silk sheets, soft lighting.',

        'naked and aroused, hard penis': 'Man standing or lying completely naked and aroused, large hard erect penis fully visible pointing upward. Muscular body on display. Confident expression looking at camera. One hand near or touching his cock. Balls visible. Full frontal view. Luxury bedroom with silk sheets, warm lighting.',

        'penetrating from behind': 'Man standing behind woman penetrating her from behind, his cock deep inside her pussy. Dominant position, hands gripping her hips. Face shows intense pleasure approaching orgasm. Visible penetration showing his cock entering her. Muscular body. Luxury bedroom with silk sheets, intimate angle.',

        'receiving oral, mouth on cock': 'Man standing or sitting while receiving oral sex, woman\'s mouth on his erect penis. His hand on her head, face shows ecstasy. Visible oral act from angle showing cock in her mouth. Muscular torso visible. Intimate angle. Bedroom with silk sheets, soft lighting.',

        'naked and hard, erect penis displayed': 'Man posing naked showing off his large erect penis prominently. Cock standing hard and fully erect, balls visible. Muscular physique, confident lustful expression looking at camera. Hand near cock or stroking it. Full frontal intimate view. Luxury bedroom with silk sheets, warm romantic lighting.',

        'in missionary, cock inside': 'Man in missionary position on top, his penis penetrating woman below. Visible penetration showing cock sliding in and out of pussy. Muscular back and ass visible, thrusting motion. Face turned to camera showing pleasure. Intimate angle. Luxury bedroom with silk sheets.',

        'masturbating intensely, pumping': 'Man masturbating very intensely, hand rapidly pumping large erect cock. Face shows he\'s close to orgasm, mouth open. Other hand gripping sheets. Cock and hand clearly visible in stroking motion. Pre-cum leaking. Angle on face and cock. Bedroom with silk sheets, soft lighting.',

        'naked legs spread, penis and balls': 'Man lying back naked with legs spread, fully erect penis and balls on full display. Cock standing straight up, balls hanging. Lustful aroused expression looking at camera. Hand touching chest or near cock. Full frontal intimate view. Luxury bedroom with silk sheets, soft warm lighting.',

        'fucking hard, penis thrusts': 'Man fucking woman hard and fast, powerful thrusts, penis pounding deep inside pussy. Muscular body, dominant position, intense expression. Visible penetration showing cock ramming in and out. Sweat on body. Hands gripping her tightly. Passionate intense sex. Luxury bedroom with silk sheets.'
      };

      // Find matching enhancement
      const lowercasePrompt = shortPrompt.toLowerCase();

      for (const [keyword, enhancement] of Object.entries(enhancementMap)) {
        if (lowercasePrompt.includes(keyword)) {
          return enhancement;
        }
      }

      // If no specific match found, add EXPLICIT general enhancements based on sex
      // Make this very explicit to ensure genitals are visible
      if (sex === 'male') {
        return `${shortPrompt}, muscular naked body, big hard erect cock visible and prominent, balls hanging, genitals fully exposed, explicit male nudity, pornographic, XXX rated, intense expression looking at camera, intimate POV angle showing everything, luxury bedroom with silk sheets, warm sensual lighting`;
      } else {
        return `${shortPrompt}, beautiful naked woman, huge natural breasts exposed, nipples erect, wet glistening pussy visible, labia spread open, genitals fully exposed, explicit female nudity, pornographic, XXX rated, aroused lustful expression looking at camera, legs spread wide, intimate POV angle showing everything, luxury bedroom with silk sheets, romantic warm lighting`;
      }
    }

    async function handleImageRequest(message) {
      // Check if we're already generating an image
      if (isGeneratingImage) {
        console.log('⚠️ Image generation already in progress, ignoring request');
        addMessage('Please wait, I\'m still generating your previous image...', 'ai');
        return;
      }

      // Check rate limiting to prevent 500 errors
      const now = Date.now();
      const timeSinceLastGeneration = now - lastImageGenerationTime;
      if (timeSinceLastGeneration < MIN_IMAGE_GENERATION_INTERVAL) {
        const waitTime = Math.ceil((MIN_IMAGE_GENERATION_INTERVAL - timeSinceLastGeneration) / 1000);
        console.log(`⏳ Rate limited, need to wait ${waitTime} more seconds`);
        addMessage(`Please wait ${waitTime} more second${waitTime > 1 ? 's' : ''} before requesting another image.`, 'ai');
        return;
      }

      // Set generation flag
      isGeneratingImage = true;
      lastImageGenerationTime = now;

      // Check user permissions before processing (force fresh check for actual generation)
      const permissions = await checkUserImagePermissions(false);

      if (!permissions.canGenerate) {
        // Reset flag since we're not generating
        isGeneratingImage = false;

        // Add user message first
        addMessage(message, 'user');
        saveUserMessageToStorage(currentCharacter.slug, message);

        // Update chat count in sidebar
        const updatedMessageCount = getMessageCount(currentCharacter.slug);
        document.getElementById('sidebarCharacterChats').textContent = updatedMessageCount;

        // Show upgrade modal and add explanation message
        showImageUpgradeModal(permissions);

        const explanationText = permissions.plan === 'Guest'
          ? '🔐 Please log in to generate images. Create a free account to get started!'
          : `🔐 Image generation is not available on the ${permissions.plan} plan. Upgrade to Basic or Premium to generate images!`;

        setTimeout(() => {
          addMessage(explanationText, 'ai');
        }, 500);
        return;
      }

      // Check if user is using credits because they hit hourly limit
      if (permissions.usingCredits && permissions.hourlyLimitReached) {
        console.log('💳 User is using image credits after hitting hourly limit');

        // Show notification that they're using credits
        setTimeout(() => {
          addMessage(`💳 You've reached your hourly image limit. Using one of your ${permissions.imageCreditsRemaining} image credits to continue.`, 'ai');
        }, 300);
      }

      // Extract the prompt part after "send me a picture"
      const promptPart = message.substring('send me a picture'.length).trim();

      // Detect character style from companion_type field, fallback to Category
      // Ensure consistent style - companion_type should be 'realistic' or 'anime'
      let characterStyle = currentCharacter.companion_type;

      console.log('🎨 RAW companion_type value:', currentCharacter.companion_type, 'type:', typeof currentCharacter.companion_type);
      console.log('🎨 Full currentCharacter object:', currentCharacter);

      // Normalize companion_type values
      if (!characterStyle || (characterStyle !== 'realistic' && characterStyle !== 'anime')) {
        console.warn('⚠️ Invalid or missing companion_type, using fallback from category');
        // Fallback to category-based detection
        characterStyle = (currentCharacter.category === 'anime-manga' ||
                         currentCharacter.category?.toLowerCase().includes('anime'))
                         ? 'anime' : 'realistic';
      }

      console.log('🎨 FINAL Image style:', characterStyle, '| companion_type:', currentCharacter.companion_type, '| category:', currentCharacter.category);

      // Get character traits - log what we have
      console.log('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg> Current character data:', {
        name: currentCharacter.name,
        ethnicity: currentCharacter.ethnicity,
        hair_length: currentCharacter.hair_length,
        hair_color: currentCharacter.hair_color,
        companion_type: currentCharacter.companion_type
      });

      const characterSex = currentCharacter.sex || 'female';
      const characterEthnicity = currentCharacter.ethnicity || 'white';
      const characterHairLength = currentCharacter.hair_length || 'medium';
      const characterHairColor = currentCharacter.hair_color || 'brown';

      // Get uncensored mode state
      const unfilteredMode = localStorage.getItem('unfilteredMode') === 'true';

      // Use the full user prompt if provided, otherwise get random sexy clothing
      let simplePrompt; // Short version for UI
      let enhancedPrompt; // Longer version for backend
      if (promptPart && promptPart.length > 0) {
        // User provided specific prompt - use it as-is
        simplePrompt = promptPart;
        enhancedPrompt = promptPart; // Send full prompt to backend (like NSFW image gen page)
      } else {
        // No specific prompt - use random sexy clothing
        simplePrompt = getStylishClothing(characterStyle);
        enhancedPrompt = simplePrompt; // No enhancement needed for clothing prompts
      }
      
      // Add user message
      addMessage(message, 'user');

      // Save user message to localStorage
      saveUserMessageToStorage(currentCharacter.slug, message);

      // Update chat count in sidebar
      const userMessageCount = getMessageCount(currentCharacter.slug);
      document.getElementById('sidebarCharacterChats').textContent = userMessageCount;
      
      // Add loading message
      const loadingId = 'loading-' + Date.now();
      // Male uncensored takes longer (15-20s), female uncensored is faster (10-15s), censored is quick (7-8s)
      const isMaleCompanion = characterSex === 'male';
      let estimatedTime;
      if (unfilteredMode) {
        estimatedTime = isMaleCompanion ? '15-20 seconds' : '10-15 seconds';
      } else {
        estimatedTime = '7-8 seconds';
      }
      addMessage(`Generating your image... (takes about ${estimatedTime})`, 'ai', loadingId);
      
      try {
        console.log('🎨 Generating image:', {
          shortPrompt: simplePrompt, // What user sees
          enhancedPrompt: enhancedPrompt, // What backend receives
          characterStyle: characterStyle,
          character: currentCharacter.name
        });

        console.log('🎭 Using companion traits for image generation:', {
          sex: characterSex,
          ethnicity: characterEthnicity,
          hair_length: characterHairLength,
          hair_color: characterHairColor,
          style: characterStyle,
          category: currentCharacter.category,
          companion_type: currentCharacter.companion_type
        });

        // Get user info for rate limiting
        const user = window.getCurrentUser ? window.getCurrentUser() : null;
        const userEmail = user?.email;
        // Use SupabaseID (stable UUID) for usage tracking
        const userSupabaseId = user?.id || user?.supabase_id || user?.sub;

        console.log('📧 Image generation user info:', {
          userEmail,
          userSupabaseId,
          userIdType: userSupabaseId?.startsWith('rec') ? 'Airtable' : (userSupabaseId?.startsWith('auth0|') ? 'Auth0' : 'Supabase UUID')
        });

        const response = await fetch('/.netlify/functions/selira-generate-custom-image', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            customPrompt: enhancedPrompt, // Send enhanced long prompt to backend
            characterName: currentCharacter.name,
            category: currentCharacter.category,
            style: characterStyle,
            shotType: 'fullbody',
            sex: characterSex,
            ethnicity: characterEthnicity,
            hairLength: characterHairLength,
            hairColor: characterHairColor,
            email: userEmail,
            auth0_id: userSupabaseId,
            source: 'chat', // Mark as chat-generated image for usage tracking
            uncensored: unfilteredMode // Use Promptchan if true, Replicate if false
          })
        });
        
        if (response.ok) {
          const result = await response.json();

          // Remove loading message
          const loadingMsg = document.getElementById(loadingId);
          if (loadingMsg) loadingMsg.remove();

          // Add generated image as AI response
          addImageMessage(result.imageUrl, result.fullPrompt || simplePrompt, characterStyle);

          // Note: images_generated counter is now incremented by the backend function
          // Wait for backend increment to complete before refreshing counter
          console.log('🔄 Refreshing image counter after successful generation');

          // Add delay to ensure backend increment completes first
          setTimeout(async () => {
            console.log('⏱️ Delayed counter refresh to ensure backend increment completed');

            // Log current permissions before refresh
            const permissionsBefore = await checkUserImagePermissions(false);
            console.log('📊 Permissions BEFORE refresh:', permissionsBefore);

            await updateImageSuggestionsPlan();
            await loadImageCredits(); // Refresh credits display

            // Log current permissions after refresh
            const permissionsAfter = await checkUserImagePermissions(false);
            console.log('📊 Permissions AFTER refresh:', permissionsAfter);
          }, 2000); // 2 second delay to let backend complete

        } else if (response.status === 429) {
          // Rate limited - show specific message
          const error = await response.json();
          const loadingMsg = document.getElementById(loadingId);
          if (loadingMsg) {
            const messageText = loadingMsg.querySelector('.message-text');
            if (messageText) {
              // Check if it's hourly limit or request cooldown
              if (error.plan && error.limit) {
                // Hourly plan limit reached
                messageText.innerHTML = `
                  <div style="color: #ff6b6b; font-weight: 500;">
                    🚫 ${error.plan} Plan Limit Reached
                  </div>
                  <div style="margin-top: 8px; color: #666; font-size: 14px;">
                    You've used ${error.usage}/${error.limit} images this hour.
                  </div>
                  <div style="margin-top: 8px; color: #666; font-size: 14px;">
                    ${error.plan === 'Basic' ? 'Upgrade to Premium Plan for 20 images per hour!' : 'Try again in the next hour.'}
                  </div>
                `;
              } else {
                // Regular rate limit (5 second cooldown)
                messageText.textContent = `⏱️ Please wait a moment before generating another image. Try again in ${error.retryAfter || 2} seconds.`;
              }
            }
          }
        } else if (response.status === 403) {
          // Free plan user blocked from image generation
          const error = await response.json();
          const loadingMsg = document.getElementById(loadingId);
          if (loadingMsg) {
            const messageText = loadingMsg.querySelector('.message-text');
            if (messageText) {
              messageText.innerHTML = `
                <div style="color: #ff6b6b; font-weight: 500;">
                  🔒 Image Generation Not Available
                </div>
                <div style="margin-top: 8px; color: #666; font-size: 14px;">
                  ${error.error}
                </div>
                <div style="margin-top: 12px;">
                  <a href="/pricing" style="background: var(--accent); color: white; padding: 8px 16px; border-radius: 20px; text-decoration: none; font-size: 14px; font-weight: 600;">
                    Upgrade Now
                  </a>
                </div>
              `;
            }
          }
        } else if (response.status === 504) {
          // Gateway timeout - server took too long
          const loadingMsg = document.getElementById(loadingId);
          if (loadingMsg) {
            const messageText = loadingMsg.querySelector('.message-text');
            if (messageText) {
              messageText.innerHTML = `
                <div style="color: #ff9800; font-weight: 500;">
                  ⏱️ Generation Timeout
                </div>
                <div style="margin-top: 8px; color: #666; font-size: 14px;">
                  The image took too long to generate. This sometimes happens during peak usage.
                </div>
                <div style="margin-top: 12px;">
                  <button onclick="document.getElementById('${loadingId}').remove(); document.getElementById('generateImageBtn').click();" style="background: var(--accent); color: white; padding: 8px 16px; border-radius: 20px; border: none; font-size: 14px; font-weight: 600; cursor: pointer;">
                    Try Again
                  </button>
                </div>
              `;
            }
          }
        } else {
          const error = await response.json();
          // Replace loading with error
          const loadingMsg = document.getElementById(loadingId);
          if (loadingMsg) {
            const messageText = loadingMsg.querySelector('.message-text');
            if (messageText) {
              messageText.textContent = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Sorry, I couldn't generate that image: ${error.error}`;
            }
          }
        }
        
      } catch (error) {
        console.error('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Image generation error:', error);
        // Replace loading with error
        const loadingMsg = document.getElementById(loadingId);
        if (loadingMsg) {
          const messageText = loadingMsg.querySelector('.message-text');
          if (messageText) {
            messageText.textContent = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Sorry, there was an error generating your image. ${error.message || ''}`;
          }
        }
      } finally {
        // Always reset the generation flag
        isGeneratingImage = false;
        console.log('🏁 Image generation completed, flag reset');
      }
    }

    // Save single user message to localStorage
    function saveUserMessageToStorage(characterSlug, userMessage) {
      try {
        const storageKey = `chat_${characterSlug}`;
        let chatHistory = JSON.parse(localStorage.getItem(storageKey) || '[]');
        
        // Add user message
        chatHistory.push({
          type: 'user',
          content: userMessage,
          timestamp: Date.now()
        });
        
        // Keep only last 50 messages
        chatHistory = chatHistory.slice(-50);
        
        localStorage.setItem(storageKey, JSON.stringify(chatHistory));
        console.log('💾 Saved user message to localStorage:', characterSlug);
        
      } catch (error) {
        console.error('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Error saving user message to localStorage:', error);
      }
    }

    // Generate companion message for image
    function generateImageCompanionMessage() {
      const messages = [
        "*sends you a picture with a seductive smile* I hope you like what you see...",
        "*blushes while sending the image* Here's something special for you... 💕",
        "*sends photo with a playful wink* This is just for you, baby~",
        "*shares an intimate picture* I've been thinking about you... *bites lip*",
        "*sends image with anticipation* What do you think? I want to know your reaction...",
        "*nervously sends the picture* I hope this is what you wanted to see... 😳",
        "*confidently shares the photo* Like what you see? There's more where that came from~",
        "*sends picture while looking into your eyes* This moment is just for us...",
        "*shyly sends the image* I-I made this just for you... *fidgets*",
        "*sends photo with desire* Does this get your attention? *teases*"
      ];
      return messages[Math.floor(Math.random() * messages.length)];
    }

    // Save image message to localStorage
    function saveImageMessageToStorage(characterSlug, imageUrl, prompt, style) {
      try {
        const storageKey = `chat_${characterSlug}`;
        let chatHistory = JSON.parse(localStorage.getItem(storageKey) || '[]');

        // Generate companion message
        const companionMessage = generateImageCompanionMessage();

        // Add image message
        chatHistory.push({
          type: 'image',
          content: {
            imageUrl: imageUrl,
            prompt: prompt,
            style: style,
            text: companionMessage
          },
          timestamp: Date.now()
        });

        // Keep only last 50 messages
        chatHistory = chatHistory.slice(-50);

        localStorage.setItem(storageKey, JSON.stringify(chatHistory));
        console.log('💾 Saved image message to localStorage:', characterSlug);

      } catch (error) {
        console.error('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Error saving image message to localStorage:', error);
      }
    }

    function addImageMessage(imageUrl, prompt, style, saveToStorage = true) {
      const messagesContainer = document.getElementById('chatMessages');

      // Generate companion message
      const companionMessage = generateImageCompanionMessage();

      const messageDiv = document.createElement('div');
      messageDiv.className = 'message ai';
      messageDiv.innerHTML = `
        <div class="message-content">
          <div class="message-text" style="margin-left: 0;">
            <div style="margin-bottom: 12px;">${companionMessage}</div>
            <img src="${imageUrl}" alt="Generated image" style="
              max-width: 300px; border-radius: 12px; cursor: pointer;
              box-shadow: 0 4px 16px rgba(0,0,0,0.3);
            " onclick="openImageFullscreen('${imageUrl}', '${prompt}')">
          </div>
          <div class="message-time">${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</div>
        </div>
      `;

      messagesContainer.appendChild(messageDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      
      // Save to localStorage if requested
      if (saveToStorage && currentCharacter.slug) {
        saveImageMessageToStorage(currentCharacter.slug, imageUrl, prompt, style);

        // Update chat count in sidebar
        const updatedMessageCount = getMessageCount(currentCharacter.slug);
        document.getElementById('sidebarCharacterChats').textContent = updatedMessageCount;

        // Update sidebar to reflect new activity
        updateActiveChatsSidebar();
      }
    }

    // Add avatar message for new companions
    function addAvatarMessage(avatarUrl) {
      const messagesContainer = document.getElementById('chatMessages');
      const welcomeMessage = messagesContainer.querySelector('.welcome-message');

      if (welcomeMessage) {
        welcomeMessage.remove();
      }

      const messageDiv = document.createElement('div');
      messageDiv.className = 'message ai';
      messageDiv.innerHTML = `
        <div class="message-avatar">
          <img src="${fixAvatarUrl(currentCharacter.avatar)}" alt="${currentCharacter.name}" onerror="this.style.display='none'">
        </div>
        <div class="message-content">
          <div style="text-align: center; margin: 8px 0;">
            <img src="${fixAvatarUrl(avatarUrl)}" alt="${currentCharacter.name}"
                 style="max-width: 200px; max-height: 200px; border-radius: 12px; cursor: pointer;"
                 onclick="openAvatarModal('${fixAvatarUrl(avatarUrl)}', '${currentCharacter.name}')"
                 onerror="this.style.display='none'">
          </div>
        </div>
      `;

      messagesContainer.appendChild(messageDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    function openImageFullscreen(imageUrl, prompt) {
      const fullscreenModal = document.createElement('div');
      fullscreenModal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.9); z-index: 3000;
        overflow-y: auto; overflow-x: hidden;
        backdrop-filter: blur(8px);
        padding: 40px 20px;
      `;

      fullscreenModal.innerHTML = `
        <div style="
          position: relative; max-width: 90vw; margin: 0 auto;
          display: flex; align-items: center; justify-content: center; min-height: calc(100vh - 80px);
        ">
          <div style="position: relative;">
            <img src="${imageUrl}" alt="Generated image" style="
              max-width: 90vw; max-height: 90vh; border-radius: 12px;
              box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            ">
            <button onclick="this.parentElement.parentElement.parentElement.remove()" style="
              position: fixed; top: 80px; right: 20px; background: rgba(255,255,255,0.95);
              border: none; border-radius: 50%; width: 48px; height: 48px; cursor: pointer;
              display: flex; align-items: center; justify-content: center; font-size: 28px;
              z-index: 3001; box-shadow: 0 4px 12px rgba(0,0,0,0.4); color: #333;
              font-weight: 300; line-height: 1; transition: all 0.2s ease;
            " ontouchstart="this.style.transform='scale(0.95)'" ontouchend="this.style.transform='scale(1)'">&times;</button>
          </div>
        </div>
      `;

      document.body.appendChild(fullscreenModal);
      fullscreenModal.addEventListener('click', (e) => {
        if (e.target === fullscreenModal) fullscreenModal.remove();
      });
    }

    // Action menu functions
    function toggleActionMenu() {
      const menu = document.getElementById('actionMenu');
      const isVisible = menu.style.display !== 'none';
      
      if (isVisible) {
        menu.style.display = 'none';
      } else {
        menu.style.display = 'block';
      }
    }

    function closeActionMenu() {
      const menu = document.getElementById('actionMenu');
      menu.style.display = 'none';
    }

    // Open support widget
    function openSupportWidget() {
      const supportBtn = document.getElementById('supportWidgetBtn');
      if (supportBtn) {
        supportBtn.click();
      }
    }

    // Close action menu when clicking outside
    document.addEventListener('click', function(e) {
      const menuContainer = document.querySelector('.action-menu-container');
      const menu = document.getElementById('actionMenu');
      
      if (menuContainer && !menuContainer.contains(e.target) && menu) {
        menu.style.display = 'none';
      }
    });

    // Character info modal function
    function toggleCharacterInfo() {
      // Create or toggle character info modal
      const existingModal = document.getElementById('characterInfoModal');
      if (existingModal) {
        existingModal.remove();
        return;
      }
      
      const modal = document.createElement('div');
      modal.id = 'characterInfoModal';
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.8); z-index: 2000;
        display: flex; align-items: center; justify-content: center;
        backdrop-filter: blur(8px);
      `;
      
      modal.innerHTML = `
        <div style="
          background: var(--bg-secondary); border: 1px solid var(--border);
          border-radius: 16px; padding: 32px; max-width: 500px; margin: 20px;
          position: relative;
        ">
          <button onclick="document.getElementById('characterInfoModal').remove()" style="
            position: absolute; top: 16px; right: 16px; background: none;
            border: none; color: var(--text-secondary); font-size: 24px;
            cursor: pointer; width: 32px; height: 32px; display: flex;
            align-items: center; justify-content: center; border-radius: 50%;
          ">&times;</button>
          
          <div style="display: flex; gap: 20px; margin-bottom: 20px;">
            <img src="${fixAvatarUrl(currentCharacter.avatar)}" style="
              width: 80px; height: 80px; border-radius: 12px; object-fit: cover;
              border: 2px solid var(--accent);
            " onerror="this.style.display='none';">
            <div>
              <h2 style="color: var(--text-primary); margin: 0 0 8px 0; font-family: 'Playfair Display', serif;">${currentCharacter.name}</h2>
              <p style="color: var(--accent); margin: 0 0 8px 0; font-weight: 600;">${currentCharacter.title || 'AI Companion'}</p>
              <p style="color: var(--text-secondary); margin: 0; font-size: 14px;">Created by ${currentCharacter.creator}</p>
            </div>
          </div>
          
          <p style="color: var(--text-secondary); line-height: 1.6; margin: 0;">
            ${(cleanDescription(currentCharacter.description) || 'An amazing AI companion ready for conversation.').replace(/\\n\\n/g, '<br><br>').replace(/\\n/g, '<br>')}
          </p>
        </div>
      `;
      
      document.body.appendChild(modal);
      modal.addEventListener('click', (e) => {
        if (e.target === modal) modal.remove();
      });
    }

    // ===== MEMORY FUNCTIONS =====
    async function loadMemoriesForContext(characterSlug, auth0Id) {
      try {
        console.log('🧠 Loading memories for context:', { characterSlug, auth0Id });

        const user = window.getCurrentUser();
        if (!user?.email) {
          console.log('⚠️ No user email for memory loading');
          return;
        }

        const response = await fetch('/.netlify/functions/selira-memory', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            action: 'get_memories',
            user_email: user.email,
            character_slug: characterSlug,
            user_uid: auth0Id
          })
        });

        if (response.ok) {
          const data = await response.json();
          console.log('✅ Loaded memories:', data.memories?.length || 0);
          // Store memories for AI context
          window.currentMemories = data.memories || [];
        } else {
          console.log('⚠️ Memory loading failed:', response.status);
        }
      } catch (error) {
        console.error('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Memory loading error:', error);
      }
    }

    async function saveMemoryIfImportant(characterSlug, userMessage, aiResponse, auth0Id) {
      try {
        console.log('🧠 Analyzing memory importance...');

        const user = window.getCurrentUser();
        if (!user?.email) {
          console.log('⚠️ No user email for memory saving');
          return;
        }

        const response = await fetch('/.netlify/functions/selira-analyze-memory', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            user_email: user.email,
            character_slug: characterSlug,
            user_message: userMessage,
            ai_response: aiResponse,
            user_uid: auth0Id
          })
        });

        if (response.ok) {
          const data = await response.json();
          console.log('✅ Memory analysis complete:', {
            importance: data.importance,
            saved: data.memory_saved
          });
        } else {
          console.log('⚠️ Memory analysis failed:', response.status);
        }
      } catch (error) {
        console.error('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Memory saving error:', error);
      }
    }

    // Avatar Modal Functions
    function openAvatarModal(avatarUrl, characterName) {
      console.log('🖼️ Opening avatar modal:', { avatarUrl, characterName });
      if (!avatarUrl || avatarUrl === '/avatars/placeholder.webp' || avatarUrl === '/avatars/default-avatar.webp') {
        console.log('⚠️ No avatar to display - avatarUrl:', avatarUrl);
        alert('No avatar available for this character yet.');
        return;
      }

      const modal = document.getElementById('avatarModal');
      const modalImage = document.getElementById('avatarModalImage');

      modalImage.src = avatarUrl;
      modalImage.alt = `${characterName} - Full Size Avatar`;

      modal.classList.add('show');

      // Close modal when clicking outside the image
      modal.onclick = function(event) {
        if (event.target === modal) {
          closeAvatarModal();
        }
      };

      // Close modal with Escape key
      document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
          closeAvatarModal();
        }
      });
    }

    function closeAvatarModal() {
      const modal = document.getElementById('avatarModal');
      modal.classList.remove('show');
    }

    // Image Carousel Functions
    let currentCarouselIndex = 0;
    let carouselImages = [];

    function initializeCarousel() {
      console.log('🎠 Initializing image carousel');

      carouselImages = [];

      // Add first image (avatar_url)
      if (currentCharacter.avatar && currentCharacter.avatar !== '/avatars/placeholder.webp') {
        carouselImages.push(fixAvatarUrl(currentCharacter.avatar));
      }

      // Add second image (avatar_url_2)
      if (currentCharacter.avatar_url_2) {
        carouselImages.push(fixAvatarUrl(currentCharacter.avatar_url_2));
      }

      console.log('🎠 Carousel images:', carouselImages);

      if (carouselImages.length > 0) {
        // Set carousel images
        const img1 = document.getElementById('carouselImage1');
        const img2 = document.getElementById('carouselImage2');

        img1.src = carouselImages[0];
        img1.style.display = 'block';

        if (carouselImages.length > 1) {
          img2.src = carouselImages[1];
          img2.style.display = 'block';

          // Setup navigation
          setupCarouselNavigation();
        } else {
          // Hide navigation if only 1 image
          document.getElementById('carouselPrev').style.opacity = '0';
          document.getElementById('carouselPrev').style.pointerEvents = 'none';
          document.getElementById('carouselNext').style.opacity = '0';
          document.getElementById('carouselNext').style.pointerEvents = 'none';
          document.getElementById('carouselIndicators').style.opacity = '0';
        }

        // Make carousel images clickable
        img1.onclick = () => openAvatarModal(carouselImages[currentCarouselIndex], currentCharacter.name);
        if (img2) {
          img2.onclick = () => openAvatarModal(carouselImages[currentCarouselIndex], currentCharacter.name);
        }
      }
    }

    function setupCarouselNavigation() {
      const prevBtn = document.getElementById('carouselPrev');
      const nextBtn = document.getElementById('carouselNext');
      const indicators = document.querySelectorAll('.carousel-indicator');

      prevBtn.onclick = () => changeCarouselImage(-1);
      nextBtn.onclick = () => changeCarouselImage(1);

      indicators.forEach((indicator, index) => {
        indicator.onclick = () => setCarouselImage(index);
      });
    }

    function changeCarouselImage(direction) {
      currentCarouselIndex = (currentCarouselIndex + direction + carouselImages.length) % carouselImages.length;
      updateCarouselDisplay();
    }

    function setCarouselImage(index) {
      currentCarouselIndex = index;
      updateCarouselDisplay();
    }

    function updateCarouselDisplay() {
      const images = document.querySelectorAll('.carousel-image');
      const indicators = document.querySelectorAll('.carousel-indicator');

      images.forEach((img, index) => {
        if (index === currentCarouselIndex) {
          img.classList.add('active');
        } else {
          img.classList.remove('active');
        }
      });

      indicators.forEach((indicator, index) => {
        if (index === currentCarouselIndex) {
          indicator.classList.add('active');
        } else {
          indicator.classList.remove('active');
        }
      });
    }

    // Make avatars clickable
    function makeAvatarsClickable() {
      console.log('🖱️ Making avatars clickable. Current character:', { name: currentCharacter.name, avatar: currentCharacter.avatar });
      // Header avatar
      const headerAvatar = document.getElementById('characterImage');
      if (headerAvatar) {
        headerAvatar.classList.add('clickable-avatar');
        headerAvatar.onclick = function() {
          console.log('🖱️ Header avatar clicked');
          openAvatarModal(currentCharacter.avatar, currentCharacter.name);
        };
        console.log('✅ Header avatar click handler added');
      } else {
        console.log('<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Header avatar element not found');
      }

      // Sidebar avatar
      const sidebarAvatar = document.getElementById('sidebarCharacterImage');
      if (sidebarAvatar) {
        sidebarAvatar.classList.add('clickable-avatar');
        sidebarAvatar.onclick = function() {
          openAvatarModal(currentCharacter.avatar, currentCharacter.name);
        };
      }
    }

    // Image Upgrade Modal Functions
    function showImageUpgradeModal(permissions) {
      // If user is a guest (not logged in), show signup modal instead
      if (permissions && permissions.plan === 'Guest') {
        console.log('🔒 Guest user detected, showing signup modal instead of upgrade modal');
        if (window.openLoginModal) {
          window.openLoginModal('signup');
        } else {
          alert('Please sign up to generate images');
        }
        return;
      }

      // For logged-in users with insufficient plan, show upgrade modal
      const modal = document.getElementById('imageUpgradeModal');
      const title = document.getElementById('upgradeModalTitle');
      const subtitle = modal.querySelector('.image-upgrade-header p');
      const featureText = modal.querySelector('.image-upgrade-feature strong');
      const upgradeButton = document.getElementById('upgradeButton');

      // Detect if user is on Light/Basic plan (hourly limit) vs Free plan (lifetime limit)
      const userPlan = permissions?.plan || 'Free';
      const isExistingSubscriber = ['Light', 'Basic'].includes(userPlan);

      if (isExistingSubscriber) {
        // For Light/Basic users hitting hourly limits
        title.textContent = 'Upgrade for More Images';
        subtitle.textContent = 'Get more images per hour with Premium';
        featureText.innerHTML = '<strong>20 images per hour</strong> with Premium';
        upgradeButton.textContent = 'View Premium Plan';
        upgradeButton.href = '/pricing#premium';
        console.log('💎 Showing hourly limit upgrade modal for', userPlan, 'plan user');
      } else {
        // For Free users hitting lifetime limit
        title.textContent = 'Unlock Image Generation';
        subtitle.textContent = 'Get unlimited AI images with a subscription';
        featureText.innerHTML = '<strong>Unlimited image generation</strong> - No limits';
        upgradeButton.textContent = 'View Plans';
        upgradeButton.href = '/pricing';
        console.log('🆓 Showing lifetime limit upgrade modal for', userPlan, 'plan user');
      }

      modal.classList.add('show');

      // Close modal when clicking outside
      modal.onclick = function(event) {
        if (event.target === modal) {
          closeImageUpgradeModal();
        }
      };

      // Close modal with Escape key
      document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
          closeImageUpgradeModal();
        }
      });
    }

    function closeImageUpgradeModal() {
      const modal = document.getElementById('imageUpgradeModal');
      modal.classList.remove('show');
    }

    console.log('✅ Selira AI Chat interface initialized with modern design');
  </script>

  <!-- Email Verification Handler -->
  <script src="js/email-verification-handler.js"></script>
  <script src="js/unverified-email-banner.js"></script>
</body>
</html>